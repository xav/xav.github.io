<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bevy &amp; WGSL: The Graphics Pipeline Explained</title><meta name="description" content="A beginner's guide to the graphics pipeline in Bevy. Learn how your 3D models become pixels, from the CPU to vertex and fragment shaders in WGSL."><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="stylesheet" href="https://xav.github.io/media/plugins/syntaxHighlighter/prism-black.css"><link rel="canonical" href="https://xav.github.io/11-understanding-the-graphics-pipeline/"><link rel="alternate" type="application/atom+xml" href="https://xav.github.io/feed.xml" title="Hexbee&#x27;s Dev Journal - RSS"><link rel="alternate" type="application/json" href="https://xav.github.io/feed.json" title="Hexbee&#x27;s Dev Journal - JSON"><meta property="og:title" content="1.1 - Understanding the Graphics Pipeline"><meta property="og:image" content="https://xav.github.io/media/posts/3/cover.png"><meta property="og:image:width" content="1344"><meta property="og:image:height" content="768"><meta property="og:site_name" content="Hexbee's Dev Journal"><meta property="og:description" content="A beginner's guide to the graphics pipeline in Bevy. Learn how your 3D models become pixels, from the CPU to vertex and fragment shaders in WGSL."><meta property="og:url" content="https://xav.github.io/11-understanding-the-graphics-pipeline/"><meta property="og:type" content="article"><link rel="stylesheet" href="https://xav.github.io/assets/css/style.css?v=e19cced6341d15e84c3d202e5e386440"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://xav.github.io/11-understanding-the-graphics-pipeline/"},"headline":"1.1 - Understanding the Graphics Pipeline","datePublished":"2025-08-30T22:42+02:00","dateModified":"2025-12-13T19:18+01:00","image":{"@type":"ImageObject","url":"https://xav.github.io/media/posts/3/cover.png","height":768,"width":1344},"description":"A beginner's guide to the graphics pipeline in Bevy. Learn how your 3D models become pixels, from the CPU to vertex and fragment shaders in WGSL.","author":{"@type":"Person","name":"Xavier Basty Kjellberg","url":"https://xav.github.io/authors/xavier-basty-kjellberg/"},"publisher":{"@type":"Organization","name":"Xavier Basty Kjellberg","logo":{"@type":"ImageObject","url":"https://xav.github.io/media/website/Logo-SideName.png","height":2297,"width":5553}}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><div class="container"><header class="header"><div class="header__logo"><a class="logo" href="https://xav.github.io/"><img src="https://xav.github.io/media/website/Logo-SideName.png" alt="Hexbee&#x27;s Dev Journal" width="5553" height="2297"></a></div></header><main class="content"><article class="post"><header><h1 class="post__title">1.1 - Understanding the Graphics Pipeline</h1><div class="post__meta"><time datetime="2025-08-30T22:42" class="post__date">August 30, 2025 </time><span class="post__author"><a href="https://xav.github.io/authors/xavier-basty-kjellberg/" class="feed__author">Xavier Basty Kjellberg</a></span></div><div class="post__tags"><a href="https://xav.github.io/tags/webgpu/" class="invert">bevy</a> <a href="https://xav.github.io/tags/rust/" class="invert">rust</a> <a href="https://xav.github.io/tags/shaders/" class="invert">shaders</a> <a href="https://xav.github.io/tags/wgsl/" class="invert">wgsl</a></div></header><figure class="post__image post__cover"><img src="https://xav.github.io/media/posts/3/cover.png" srcset="https://xav.github.io/media/posts/3/responsive/cover-xs.webp 300w, https://xav.github.io/media/posts/3/responsive/cover-sm.webp 480w, https://xav.github.io/media/posts/3/responsive/cover-md.webp 768w, https://xav.github.io/media/posts/3/responsive/cover-lg.webp 1024w" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" height="768" width="1344" alt=""></figure><div class="post__entry"><h2 id="what-were-learning">What We’re Learning</h2><p>Welcome to the start of your shader programming journey! Before we can write a single line of WGSL code to create shimmering water or a glowing sword, we must first answer a fundamental question: <strong>what exactly is a shader?</strong></p><p>At its core, a shader is a small, highly-focused program that you, the developer, write. Unlike the Rust code that runs on your computer’s main processor (the CPU), a shader runs directly on the thousands of parallel cores of your Graphics Processing Unit (GPU). This gives you direct, low-level control over how your game’s graphics are rendered. Shaders are the modern key to controlling the look, feel, and performance of everything you see in a real-time 3D application.</p><p>This first chapter pulls back the curtain on the rendering process. We will build a complete mental model of the <strong>graphics pipeline</strong> - the step-by-step assembly line a GPU uses to turn the raw data of your 3D models into the final, vibrant pixels on your screen.</p><p>Understanding this pipeline is the single most important foundation for shader programming. Without it, writing shader code is like trying to assemble a car without knowing what an engine or a wheel does. With it, every new concept will have a clear place to belong.</p><p>By the end of this chapter, you’ll understand:</p><ul><li><strong>The Big Picture:</strong> The journey of your 3D model data from the CPU (your Bevy app) to the GPU (the rendering factory).</li><li><strong>The “Why” of GPUs:</strong> Why we need a specialized processor for graphics and how its parallel design is perfect for rendering.</li><li><strong>The Vertex’s Journey:</strong> How a single point in your 3D model travels through a series of “coordinate spaces” - from its local origin to its final position on your screen.</li><li><strong>The Two Programmable Stages:</strong> The specific jobs of the <strong>Vertex Shader</strong> (controlling shape and position) and the <strong>Fragment Shader</strong> (controlling color and appearance), and how your WGSL code fits into this process.</li></ul><h2 id="the-big-picture-cpu-to-screen">The Big Picture: CPU to Screen</h2><p>Let’s start with the fundamental question: <strong>How does a 3D model in your Bevy game become the final, colored pixels on your screen?</strong></p><p>The process is a hand-off of instructions and data from a general-purpose processor (the CPU) to a highly specialized one (the GPU). The CPU decides <em>what</em> needs to be drawn, while the GPU figures out how to draw it at incredible speed. The GPU performs this task using a dedicated assembly line called the <strong>graphics pipeline</strong>.</p><p>Here is a simplified map of that journey:</p><pre><code class="language-plaintext">┌───────────────────────────────────────────┐
│              CPU: The Director            │
│          (Your Bevy / Rust Code)          │
│                                           │
│  - Runs game logic, physics, AI, etc.     │
│  - Decides WHAT to draw this frame.       │
│  - Packages all necessary data for GPU.   │
└───────────────────────────────────────────┘
                       │
                       │ Sends a &quot;Draw Command&quot; with all required data
                       ↓
  ═════════════════════ GPU BOUNDARY ═════════════════════
                       ↓
┌───────────────────────────────────────────┐
│             GPU: The Factory              │
│       (Massively Parallel Hardware)       │
└───────────────────────────────────────────┘
                       │
                       ▼
┌───────────────────────────────────────────┐
│            1. VERTEX SHADER               │ «── [ YOUR WGSL CODE RUNS HERE ]
├───────────────────────────────────────────┤
│ INPUT:  A single vertex from a mesh       │
│         (e.g., its local position, UVs).  │
│                                           │
│ JOB:    Calculate the vertex&#39;s final      │
│         position on the screen.           │
│                                           │
│ OUTPUT: The vertex&#39;s position in          │
│         &quot;Clip Space&quot; &amp; other data         │
│         (like normals) for the next stage.│
└───────────────────────────────────────────┘
                       │
                       │ (GPU groups 3 processed vertices into a triangle)
                       ↓
┌───────────────────────────────────────────┐
│            2. RASTERIZATION               │ «── [ AUTOMATIC HARDWARE STAGE ]
├───────────────────────────────────────────┤
│ INPUT:  A triangle in screen space.       │
│                                           │
│ JOB:    Determine which pixels the        │
│         triangle covers.                  │
│                                           │
│ OUTPUT: A stream of &quot;Fragments.&quot;          │
│         (A fragment is a potential pixel  │
│         with smoothly interpolated data). │
└───────────────────────────────────────────┘
                       │
                       ↓
┌───────────────────────────────────────────┐
│           3. FRAGMENT SHADER              │ «── [ YOUR WGSL CODE RUNS HERE ]
├───────────────────────────────────────────┤
│ INPUT:  A single fragment with its        │
│         interpolated data (e.g., UVs).    │
│                                           │
│ JOB:    Calculate the final color for     │
│         that specific fragment.           │
│                                           │
│ OUTPUT: A single RGBA color.              │
└───────────────────────────────────────────┘
                       │
                       ↓
┌───────────────────────────────────────────┐
│           4. OUTPUT MERGER                │ «── [ AUTOMATIC HARDWARE STAGE ]
├───────────────────────────────────────────┤
│ JOB:    Take the colored fragment and     │
│         merge it into the final image.    │
│                                           │
│       - Performs Depth Test (is this      │
│         fragment behind something else?). │
│       - Performs Blending (for            │
│         transparency effects).            │
│       - Writes the final color.           │
└───────────────────────────────────────────┘
                       │
                       ▼
            ▓▓▓ PIXELS ON SCREEN ▓▓▓
</code></pre><p>This process spans two distinct worlds, each with a specific job.</p><h3 id="the-cpu-side-bevyrust-the-director">The CPU Side (Bevy/Rust): The Director</h3><p>Think of your CPU and your Bevy code as the <strong>director of a film</strong>. It’s smart, flexible, and responsible for all the high-level decision-making. For every single frame (60 times a second!), it runs your game logic, updates physics, handles input, and determines what needs to be on screen and where it should be.</p><p>Its final job for rendering is to prepare a detailed set of instructions and data for the GPU. This “frame package” includes:</p><ul><li><strong>Mesh Data</strong>: The raw vertex information (positions, normals, UV coordinates) for each model.</li><li><strong>Material Data</strong>: Your shader’s settings, like colors, roughness values, and which textures to use.</li><li><strong>Transformation Data</strong>: The matrices that define each object’s position, rotation, and scale in the world.</li><li><strong>Global Data</strong>: Information about the entire scene, like the camera’s position (View Matrix), its lens settings (Projection Matrix), and the location of lights.</li></ul><p>Once this package is assembled, the CPU sends it across the bus to the GPU and effectively says, “Here, render this.” The CPU’s main rendering job for this frame is now complete.</p><h3 id="the-gpu-side-shaders-the-vfx-studio">The GPU Side (Shaders): The VFX Studio</h3><p>Think of the GPU as a state-of-the-art <strong>VFX studio</strong> with an army of digital artists, each with a very specific job. This studio is built for one purpose: turning the director’s brief into a final, beautifully rendered image with incredible speed. Their process is the graphics pipeline.</p><p>When the brief arrives at the studio:</p><ol><li><strong>The Geometry &amp; Layout Artists (Vertex Shader):</strong> The first team gets the brief. This team consists of thousands of artists. Each artist is assigned a single corner (a <strong>vertex</strong>) of an actor or prop. Their only job is to calculate exactly where that specific corner will appear in the final camera shot, based on the actor’s position and the camera’s lens. They don’t color anything; they just map out the structure of the scene from the camera’s perspective.</li><li><strong>The Rendering Artists (Fragment Shader):</strong> After the layout is done, a second, even larger army of artists takes over. There are millions of them - one for every pixel of the final image. Each artist is assigned a single pixel to paint (a <strong>fragment</strong>). They look at the director’s notes for that surface (the material, the textures) and the lighting setup. Then, they calculate and apply the final, precise color for their one tiny pixel.</li></ol><p>This analogy directly maps to the GPU’s strengths:</p><ul><li><strong>Specialization:</strong> The geometry artists only do positioning; the rendering artists only do coloring.</li><li><strong>Parallelism:</strong> Millions of rendering artists can paint their individual pixels all at the exact same time, without needing to talk to each other. This is what makes the GPU so fast.</li></ul><p>Your WGSL shader code is the set of instructions - the “artistic direction” - you give to these two teams of digital artists.</p><h2 id="why-the-gpu-understanding-parallelism">Why the GPU? Understanding Parallelism</h2><p>It’s a fair question: your computer’s Central Processing Unit (CPU) is an incredibly powerful and fast processor. Why can’t it just draw the triangles? Why do we need a separate, specialized piece of hardware like a Graphics Processing Unit (GPU)?</p><p>The answer lies not in raw clock speed, but in a fundamentally different architectural philosophy: <strong>Serial vs. Parallel processing</strong>.</p><h3 id="the-cpu-a-master-chef">The CPU: A Master Chef</h3><p>Think of your CPU as a <strong>master chef in a world-class kitchen</strong>.</p><ul><li><strong>It is brilliant and versatile.</strong> It can follow any recipe (run any program), handle complex sequential steps, improvise when needed (handle interrupts and varied tasks), and manage the entire kitchen (the operating system).</li><li><strong>It has a few, very powerful cores.</strong> Like having 8 or 16 highly trained sous-chefs, it can work on a handful of complex, different dishes at once.</li></ul><p>If you asked this master chef to prepare a single, elaborate seven-course meal, they would excel. But if you asked them to make ten million identical hamburgers, the entire restaurant would grind to a halt. The chef’s genius is wasted on such a simple, repetitive task; its strength is in complexity and flexibility, not mass production.</p><h3 id="the-gpu-a-hyper-efficient-assembly-line">The GPU: A Hyper-Efficient Assembly Line</h3><p>Now, think of your GPU as a <strong>massive hamburger assembly line that stretches for miles</strong>.</p><ul><li><strong>It is highly specialized.</strong> It’s not designed to create new recipes. It’s designed to execute one simple recipe over and over again with breathtaking speed.</li><li><strong>It has thousands of simple cores.</strong> Instead of a few master chefs, you have thousands of line cooks. Each cook is trained for just one or two simple tasks - place the patty, add the cheese - but they all work at the exact same time.</li></ul><p>This factory can’t prepare a seven-course meal, but it can produce those ten million identical hamburgers in the blink of an eye. This is what we call <strong>“pleasingly parallel”</strong> work.</p><h3 id="graphics-is-a-pleasingly-parallel-problem">Graphics is a “Pleasingly Parallel” Problem</h3><p>Rendering a 3D scene is the ultimate assembly-line task. The core operations are simple, repetitive, and most importantly, <strong>independent</strong>.</p><ul><li>The calculation for vertex A’s final position does not depend on vertex B’s position.</li><li>The calculation for pixel #1’s color does not depend on pixel #2’s color.</li></ul><p>They can all be processed simultaneously.</p><p>Let’s put this into perspective. When rendering a moderately complex scene with 100,000 triangles on a standard 1080p display, for a single frame, you are asking the hardware to perform approximately:</p><ul><li><strong>300,000 vertex shader executions</strong> (one for each vertex)</li><li><strong>Millions of fragment shader executions</strong> (one for each pixel covered by a triangle)</li></ul><p>And this has to happen <strong>60 times every second</strong> for smooth gameplay.</p><p>This is the “ten million hamburgers” problem. A CPU, with its few brilliant cores, would be overwhelmed trying to handle these tasks one by one. But a GPU, with its thousands of simple cores, can process huge batches of vertices and pixels all at once.</p><p>This is why we write shaders for the GPU. We are providing the “recipe” for the assembly line workers. The GPU’s architecture is not just “more cores”; it’s a completely different philosophy of computation, one that is perfectly and beautifully matched to the massive, repetitive, and parallel nature of computer graphics.</p><h2 id="the-rendering-pipeline-in-detail">The Rendering Pipeline in Detail</h2><p>Let’s zoom in on the VFX studio’s assembly line. Each stage has a specific responsibility, taking a particular kind of data as input and producing a new kind of data for the next stage to work on.</p><h3 id="stage-1-the-application-stage-cpu---the-directors-brief">Stage 1: The Application Stage (CPU - The Director’s Brief)</h3><p>This stage isn’t on the GPU at all - it’s your Bevy application running on the CPU. Think of it as the “pre-production” step where the director prepares the detailed brief. Before any rendering can happen, your application needs to tell the GPU everything it needs to know about the world for the upcoming frame. Bevy’s renderer orchestrates this for you.</p><p>For every frame, Bevy traverses your scene’s Entity-Component-System (ECS) world and gathers all the necessary information:</p><pre><code class="language-rust">// You write this in Bevy, describing the &quot;what&quot; and &quot;where&quot;
commands.spawn((
 Mesh3d(meshes.add(Sphere::new(1.0))),
 MeshMaterial3d(materials.add(my_custom_material)),
));
</code></pre><p>From code like this, Bevy assembles the “shot list”:</p><ul><li><strong>What to draw</strong>: A list of meshes (the sphere’s vertices and triangles).</li><li><strong>How to draw it</strong>: The material to use and its properties (colors, textures).</li><li><strong>Where it is</strong>: The object’s world position, rotation, and scale (the Transform).</li><li><strong>From where to view it</strong>: The camera’s position and perspective settings.</li></ul><p>The final output of this stage is a highly-organized package of data and commands, which Bevy then sends over to the GPU to begin the actual rendering process.</p><h3 id="stage-2-the-vertex-shader-gpu---the-layout-artists">Stage 2: The Vertex Shader (GPU - The Layout Artists)</h3><p>This is the <strong>first programmable stage</strong> on the GPU, where your first piece of WGSL code runs. The vertex shader’s fundamental job is to answer one question for every single vertex of a mesh: <strong>“Where on the screen does this vertex end up?”</strong></p><ul><li><strong>Input</strong>: It receives the data for a <strong>single vertex</strong> at a time (its position in local model space, its normal vector, its UV coordinates, etc.).</li><li><strong>The Job</strong>: Its one mandatory task is to perform mathematical operations (usually matrix multiplications) to transform the vertex’s 3D position into a final 4D “clip space” position. This clip space coordinate is what the GPU hardware needs to figure out the 2D location on your monitor.</li><li><strong>Output</strong>: It must output that final clip space position. It can also pass along any other data it received or calculated (like colors, normals, or UVs) to be used later by the fragment shader.</li></ul><p>Here’s a conceptual view of what your WGSL code will do:</p><pre><code class="language-wgsl">@vertex
fn vertex(input: VertexInput) -&gt; VertexOutput {
    var output: VertexOutput;

    // The primary job: Transform the 3D local position into a final 2D screen position.
    output.position = project_to_screen(view_matrix * model_matrix * input.position);

    // A secondary job: Pass necessary data to the next stage.
    // Here, we&#39;re just passing the vertex&#39;s normal along for lighting calculations later.
    output.normal = input.normal;
    return output;
}
</code></pre><p><strong>Key Insight</strong>: Because this shader runs on every vertex, it gives you the power to manipulate the shape and position of your geometry in real-time. This is not just about moving objects around (which is best done by changing the Transform in Bevy); it’s about deforming the mesh itself. This is how you create dynamic effects like:</p><ul><li>Waving flags</li><li>Rippling water surfaces</li><li>Procedurally animated grass swaying in the wind</li></ul><h3 id="stage-3-the-rasterizer-gpu---automatic-hardware">Stage 3: The Rasterizer (GPU - Automatic Hardware)</h3><p>This stage is a piece of dedicated, non-programmable hardware on the GPU. It’s an automatic, incredibly fast process that you don’t write code for. The rasterizer takes the processed vertices from the vertex shader (three at a time to form a triangle) and figures out which pixels on the screen that triangle covers.</p><p>For every single pixel it covers, it generates a <strong>“fragment.”</strong> A fragment is a “potential pixel” - it contains all the information needed to calculate a final color.</p><p>This is also where the magic of <strong>interpolation</strong> happens. The rasterizer looks at the data you passed out of the vertex shader for each of the triangle’s three vertices and smoothly blends it across the surface of the triangle for each fragment.</p><p>Think of it like this:</p><figure class="post__image"><img src="/media/files/1.1%20-%20figure%20-%20Rasterizer.png" alt="rasterizer" data-is-external-image="true"></figure><ul><li>A fragment near the top will receive a reddish color.</li><li>A fragment on the left edge will get a purplish color (red + blue).</li><li>A fragment right in the middle will get a muddy, grayish color, which is the mathematical average of red, green, and blue.</li></ul><p>The rasterizer does this for every single piece of data you passed along - colors, UV coordinates, normals, etc. The output is a massive stream of fragments, each one “pre-loaded” with its own unique, interpolated data, ready to be colored.</p><h3 id="stage-4-the-fragment-shader-gpu---the-rendering-artists">Stage 4: The Fragment Shader (GPU - The Rendering Artists)</h3><p>This is the <strong>second programmable stage</strong>, and it’s where most of the visual artistry happens. The fragment shader’s job is to answer one simple question for every single fragment generated by the rasterizer: <strong>“What color is this pixel?”</strong></p><ul><li><strong>Input</strong>: It receives the interpolated data for a <strong>single fragment</strong>. This includes its position on the screen and the smoothly blended values (like normals and UVs) that were passed from the vertex shader.</li><li><strong>The Job</strong>: To use this input data to perform calculations and return a single, final color.</li><li><strong>Output</strong>: It must output a <code>vec4&lt;f33&gt;</code> representing an RGBA color. This is the color that will be written to the screen (assuming it passes final tests like depth testing).</li></ul><p>Here’s a conceptual view of what your WGSL code will do:</p><pre><code class="language-wgsl">@fragment
fn fragment(input: FragmentInput) -&gt; @location(0) vec4&lt;f32&gt; {
    // The input data (e.g., input.normal) has already been smoothly interpolated for us.
    // We can use it to calculate lighting for this specific pixel.
    let lighting = calculate_light(input.normal, light_direction);

    // We could also sample a texture using the interpolated UVs.
    let surface_color = sample_texture(input.uv);

    // Combine them to get the final color.
    let final_color = surface_color * lighting;
    return vec4&lt;f32&gt;(final_color, 1.0); // Return the final RGBA value
}
</code></pre><p><strong>Key Insight</strong>: The fragment shader runs for potentially millions of pixels every frame. This is your chance to define the appearance of your object’s surface with incredible detail. This is where you:</p><ul><li>Apply lighting calculations to create highlights and shadows.</li><li>Sample textures to give a surface detail and color.</li><li>Create procedural patterns like stripes, checkerboards, or noise.</li><li>Implement special effects like glowing, outlines, or distortion.</li></ul><h2 id="the-coordinate-space-journey">The Coordinate Space Journey</h2><p>One of the most initially confusing, but ultimately powerful, concepts in graphics programming is the journey a vertex takes through different <strong>coordinate spaces</strong>. Each space is a different frame of reference, like describing a location from a different point of view. The vertex shader’s main job is to transform a vertex from one space to the next, like a series of conversions, until it lands in the right spot on the screen.</p><p>Think of it like giving directions to a friend:</p><ol><li>“The book is on the second shelf of the bookcase.” (<strong>Local Space</strong>: The position is relative to the bookcase).</li><li>“The bookcase is against the north wall of the living room.” (<strong>World Space</strong>: Now the bookcase’s position is relative to the entire house).</li><li>“Stand in the doorway and look towards the fireplace.” (<strong>View Space</strong>: Now everything is described from your friend’s point of view).</li><li>“The book you’re looking for should be in the upper-left part of your vision.” (<strong>Clip Space</strong>: This is what’s in their field of view).</li></ol><p>In 3D graphics, we perform these transformations using matrix mathematics.</p><p><strong>Note</strong>: Don’t worry if the matrix math looks intimidating right now. We have a dedicated chapter later that explains how matrices work. For now, just focus on the purpose of each transformation - what question it answers.</p><h3 id="1-local-space-or-model-space">1. Local Space (or Model Space)</h3><p><strong>The Question:</strong> “What does this object look like by itself?”</p><p>This is the object’s blueprint. When an artist creates a 3D model of a car, they don’t care where it will be in your game world. They model it at the center of its own universe, the origin <code>(0, 0, 0)</code>. The coordinates of every vertex are relative only to the car’s own center point.</p><pre><code class="language-plaintext">A car&#39;s front-right tire vertex in Local Space might be:
(0.8, 0.3, 1.5)
</code></pre><h3 id="2-world-space">2. World Space</h3><p><strong>The Question:</strong> “Where is this object in the game world?”</p><p>This is the shared, global coordinate system of your entire scene. It’s the common frame of reference where all your objects, lights, and the camera coexist. When you give an entity a Transform in Bevy, you are defining its position, rotation, and scale within this World Space.</p><pre><code class="language-rust">// This Transform moves the object from its local origin to a specific spot in the world.
Transform::from_xyz(10.0, 0.0, -20.0)
</code></pre><p>The <strong>Model Matrix</strong>, which Bevy derives from this <code>Transform</code>, is the mathematical tool that converts vertices from <strong>Local Space</strong> to <strong>World Space</strong>. Your vertex shader applies it to every vertex.</p><pre><code class="language-plaintext">Local Position × Model Matrix = World Position
</code></pre><h3 id="3-view-space-or-camera-space">3. View Space (or Camera Space)</h3><p><strong>The Question:</strong> “How does the world look from the camera’s perspective?”</p><p>Once everything is placed in the world, we need to view it. To make the math simpler for the next step, we transform the entire world so that the camera is at the origin <code>(0, 0, 0)</code> and looking down a specific axis (typically negative Z). Everything in the world is now positioned relative to the camera. An object in front of the camera will have a negative Z coordinate, an object to the camera’s left will have a negative X, and so on.</p><p>The <strong>View Matrix</strong> performs this transformation. It’s calculated from the camera’s own world-space transform.</p><pre><code class="language-plaintext">World Position × View Matrix = View Position
</code></pre><h3 id="4-clip-space">4. Clip Space</h3><p><strong>The Question:</strong> “Is this vertex inside the viewable area, and if so, where?”</p><p>This is the final and most abstract space that the vertex shader is responsible for creating. It’s a standardized, cube-like volume that represents everything the camera can see. The transformation into this space, performed by the <strong>Projection Matrix</strong>, does two magical things:</p><ol><li><strong>It applies perspective.</strong> It mathematically squishes the 3D scene so that objects farther away from the camera appear smaller than objects that are closer. This is what creates the illusion of depth.</li><li><strong>It normalizes the coordinates.</strong> Everything that will be visible on screen is mapped into a neat box where the X and Y coordinates range from -1 to 1. The Z coordinate is also remapped (usually to a <code>[0, 1]</code> range) to represent depth.</li></ol><p>The GPU now has a simple job: any vertex with X or Y coordinates outside of this <code>[-1, 1]</code> range is “clipped” and discarded, as it is off-screen. The Z coordinate will be used in a later stage for depth testing (figuring out if one object is in front of another).</p><pre><code class="language-plaintext">View Position × Projection Matrix = Clip Position
</code></pre><p>The mandatory output of your vertex shader is this final Clip Space position.</p><h3 id="5-screen-space">5. Screen Space</h3><p><strong>The Question:</strong> “Which specific pixel on my monitor does this correspond to?”</p><p>This final step is handled <strong>automatically by the GPU</strong> after the vertex shader is done. The hardware takes the <code>[-1, 1]</code> Clip Space coordinates and maps them to the actual pixel coordinates of your window (e.g., from <code>(0, 0)</code> in the top-left to <code>(1920, 1080)</code> in the bottom-right). This is not something you calculate in your shaders; it’s the final output of the fixed-function part of the pipeline before the fragment shader runs.</p><h2 id="putting-it-all-together-the-life-of-a-single-vertex">Putting It All Together: The Life of a Single Vertex</h2><p>Let’s trace the complete life of a single vertex, from its creation in a modeling tool to its final appearance as a colored pixel on your screen. We’ll follow a vertex at the very top of a sphere model.</p><h3 id="1-the-blueprint-cpu---local-space">1. The Blueprint (CPU - Local Space)</h3><p>It begins its life in a 3D modeling program. An artist defines a sphere, and our vertex is created at the very top. Relative to the sphere’s own center, its position is simply (0.0, 1.0, 0.0). This is its <strong>Local Space</strong> position. This data is loaded into Bevy as part of a Mesh asset.</p><h3 id="2-setting-the-scene-cpu---the-directors-brief">2. Setting the Scene (CPU - The Director’s Brief)</h3><p>Your Bevy application decides where this sphere belongs in the game world. You assign it a <code>Transform</code> to place it, for example, at world coordinates <code>(5.0, 2.0, -3.0)</code>. The CPU doesn’t move the vertex itself; instead, it calculates a <strong>Model Matrix</strong> from this transform and packages it up, ready to be sent to the GPU’s VFX studio.</p><h3 id="3-the-great-transformation-gpu---vertex-shader">3. The Great Transformation (GPU - Vertex Shader)</h3><p>Now the director’s brief is uploaded to the GPU, and our programmable <strong>Vertex Shader</strong> takes over. This is where the “Layout Artists” get to work. The shader receives our vertex’s original local position, <code>(0, 1, 0)</code>, along with the Model, View, and Projection matrices. It then performs the crucial sequence of multiplications to find the vertex’s final on-screen position:</p><ul><li><strong>To World Space</strong>: The shader multiplies the local position by the Model Matrix. This moves the vertex into the shared <strong>World Space</strong>. Our vertex at <code>(0, 1, 0)</code> is now effectively at <code>(5.0, 3.0, -3.0)</code> in the game world (position + model’s height).</li><li><strong>To View Space</strong>: Next, it multiplies the new world position by the View Matrix. This transforms the vertex into <strong>View Space</strong>, making its coordinates relative to the camera’s perspective. Its position might now be something like <code>(-2.0, 1.0, -5.0)</code>, meaning it’s slightly to the camera’s left, above its center, and some distance in front of it.</li><li><strong>To Clip Space</strong>: Finally, it multiplies the view position by the Projection Matrix. This applies perspective and transforms the vertex into the final, required <strong>Clip Space</strong>. The position might now be <code>(-0.4, 0.2, 0.8)</code>. This tells the GPU the vertex is on-screen (since X and Y are between <code>-1</code> and <code>1</code>) and provides its depth. This <code>vec4</code> is the mandatory output of the vertex shader.</li></ul><p>Simultaneously, the vertex shader also prepares any other data needed for coloring, like the vertex’s color or normal vector, and passes it along.</p><h3 id="4-the-triangle-factory-gpu---rasterizer">4. The Triangle Factory (GPU - Rasterizer)</h3><p>The vertex, now just a point in Clip Space, is grouped by the GPU with two other processed vertices to form a triangle. The hardware <strong>Rasterizer</strong> takes over, calculating exactly which screen pixels this triangle covers. For each covered pixel, it generates a “fragment” and <strong>interpolates</strong> all the data that the vertex shaders passed out (like colors or UVs), creating a smooth gradient of values across the triangle’s face.</p><h3 id="5-the-coloring-book-gpu---fragment-shader">5. The Coloring Book (GPU - Fragment Shader)</h3><p>A single fragment, born from the rasterizer, arrives at our programmable <strong>Fragment Shader</strong>. Now the “Rendering Artists” do their job. The fragment carries its own unique, interpolated data (e.g., a color that is a blend of the three corner vertices’ colors). The fragment shader’s sole job is to use this information to calculate a final RGBA color. It might sample a texture, calculate lighting, or perform any number of other operations.</p><h3 id="6-the-final-pixel-gpu---output-merger">6. The Final Pixel (GPU - Output Merger)</h3><p>The fragment shader outputs its calculated color. This color, along with the fragment’s depth, is sent to the final hardware stage. The GPU performs a <strong>depth test</strong> to see if this fragment is in front of whatever is already on the screen at that pixel. If it is, its color is written to the framebuffer, becoming one of the millions of pixels that form the final image you see. Our vertex has completed its journey.</p><h2 id="a-mental-model-for-your-shaders">A Mental Model for Your Shaders</h2><p>The rendering pipeline can seem complex, but by holding on to our “Director and VFX Studio” analogy, we can assign a clear, relatable job to each programmable stage.</p><h3 id="1-the-vertex-shader-the-vfx-layout-artist">1. The Vertex Shader: The VFX Layout Artist</h3><p>Your WGSL code in the vertex shader provides the instructions for the layout artists at the VFX studio.</p><table><thead><tr><th>Analogy</th><th>Role</th><th>Shader Code Focus</th></tr></thead><tbody><tr><td><strong>Staging the scene for the camera.</strong></td><td>Your job is to take the 3D models (defined in their own local space) and <strong>place them correctly in the world and frame them perfectly in the camera’s shot.</strong></td><td><strong>Transformation.</strong> You use matrix math to move each vertex of a model from its origin to its final position relative to the camera’s view. You can also dynamically move vertices here to create animations like waving flags or rippling water.</td></tr><tr><td><strong>Defining the final composition.</strong></td><td>You must output the final projected position of each vertex. This is the main deliverable for this stage.</td><td><code>output.position = projection * view * model * local_pos;</code></td></tr><tr><td><strong>Prepping for the colorists.</strong></td><td>You pass along any surface information that the next team will need, like texture coordinates (uv) or which way the surface is facing (normal).</td><td><code>output.world_normal = ..., output.uv = ...</code></td></tr></tbody></table><h3 id="2-the-rasterizer-the-digital-render-farm">2. The Rasterizer: The Digital Render Farm</h3><p>This is an automated, non-programmable hardware stage. You don’t write code for it, but you need to know what it does.</p><table><thead><tr><th>Analogy</th><th>Role</th><th>Shader Code Focus</th></tr></thead><tbody><tr><td><strong>Automated rendering setup.</strong></td><td>The GPU’s hardware takes the 3D triangles you’ve positioned in the previous step…</td><td><strong>None.</strong> This is a fixed, non-programmable step.</td></tr><tr><td><strong>…and projects them onto a 2D grid.</strong></td><td>The hardware determines exactly which pixels on the screen are covered by each triangle. For each covered pixel, it creates a “fragment” and <strong>interpolates</strong> (smoothly blends) the data from the triangle’s corners.</td><td>A fragment in the middle of a triangle gets a perfectly blended uv coordinate and normal vector, ready for the next stage.</td></tr></tbody></table><h3 id="3-the-fragment-shader-the-vfx-coloring--lighting-artist">3. The Fragment Shader: The VFX Coloring &amp; Lighting Artist</h3><p>Your WGSL code in the fragment shader provides the instructions for the massive team of coloring and lighting artists.</p><table><thead><tr><th>Analogy</th><th>Role</th><th>Shader Code Focus</th></tr></thead><tbody><tr><td><strong>Painting one pixel at a time.</strong></td><td>Your job is to look at a single, uncolored pixel (a fragment) and <strong>decide what its final color should be.</strong> This is where all the visual artistry happens.</td><td><strong>Color Calculation.</strong> You have complete control over the pixel’s final RGBA value.</td></tr><tr><td><strong>Using the prepped materials.</strong></td><td>You use the interpolated data from the previous stage to perform your work.</td><td><code>return vec4&lt;f32&gt;(final_color, alpha);</code></td></tr><tr><td><strong>Applying textures and lighting.</strong></td><td>You can sample <strong>textures</strong> using the interpolated uv coordinates and use the interpolated normal vector to calculate realistic <strong>lighting</strong> and shadows.</td><td><code>textureSample(...)</code>, <code>dot(normal, light_dir)</code></td></tr></tbody></table><hr><h2 id="complete-example-visualizing-the-pipeline">Complete Example: Visualizing the Pipeline</h2><p>Theory is essential, but seeing is believing. To make these abstract concepts concrete, we’ll build a simple, interactive shader in Bevy. This shader won’t create a realistic object; instead, it will act as a diagnostic tool, allowing us to “see” the data at different stages of the pipeline.</p><p><strong>A Note Before We Begin:</strong> You will see new WGSL syntax (@location, @group, etc.) and Bevy patterns (AsBindGroup, MaterialPlugin) in the code below. <strong>Do not worry about understanding every line right now.</strong> We will break down all of these concepts in detail in the upcoming articles.</p><p>The goal of this example is to <strong>observe the visual output</strong> of each mode and connect it back to the high-level pipeline concepts we just learned:</p><ul><li>How data is <strong>interpolated</strong> across a surface (the smooth normal colors).</li><li>How the fragment shader runs for <strong>every pixel</strong> (the sharp checkerboard).</li><li>How data from the <strong>vertex stage</strong> is used in the <strong>fragment stage</strong> (the height gradient).</li></ul><p>Focus on the “what you’re seeing” part, and treat the code as a preview of what you’ll soon master.</p><h3 id="our-goal">Our Goal</h3><p>We will create a custom material for a sphere that can cycle through three different visualization modes by pressing a key. Each mode will highlight a different core concept of the rendering pipeline that we’ve just discussed.</p><h3 id="what-this-project-demonstrates">What This Project Demonstrates</h3><ul><li><strong>Data Flow and Interpolation:</strong> How data (like normal vectors) passed from the vertex shader is smoothly interpolated by the rasterizer before reaching the fragment shader.</li><li><strong>Per-Fragment Processing:</strong> Proof that the fragment shader runs independently for every single pixel, allowing it to create complex patterns based on a fragment’s world position.</li><li><strong>Vertex Data in Fragment Shaders:</strong> How to use data prepared by the vertex shader (like the final world position) to drive calculations in the fragment shader.</li></ul><h3 id="the-shader-assetsshadersdebug_pipelinewgsl">The Shader (<code>assets/shaders/debug_pipeline.wgsl</code>)</h3><p>This single WGSL file contains both our vertex and fragment shaders. The key element is the material.mode uniform, a number we can change from our Rust code to switch the logic inside the fragment shader.</p><ul><li>The <strong>vertex shader</strong> is standard: it transforms the vertex position into clip space and also passes the vertex’s world position and world normal along to the fragment stage.</li><li>The <strong>fragment shader</strong> uses an <code>if/else if</code> chain based on material.mode to decide how to color the current pixel.</li></ul><pre><code class="language-wgsl">#import bevy_pbr::mesh_functions
#import bevy_pbr::view_transformations::position_world_to_clip
#import bevy_pbr::forward_io::VertexOutput

struct DebugMaterial {
    mode: u32,
}

@group(2) @binding(0)
var&lt;uniform&gt; material: DebugMaterial;

@vertex
fn vertex(
    @builtin(instance_index) instance_index: u32,
    @location(0) position: vec3&lt;f32&gt;,
    @location(1) normal: vec3&lt;f32&gt;,
) -&gt; VertexOutput {
    var out: VertexOutput;
    
    // Get the model transformation matrix
    let world_from_local = mesh_functions::get_world_from_local(instance_index);
    
    // Transform position to world space
    let world_position = mesh_functions::mesh_position_local_to_world(
        world_from_local,
        vec4&lt;f32&gt;(position, 1.0)
    );
    
    // Transform to clip space (final vertex shader output)
    out.position = position_world_to_clip(world_position.xyz);
    
    // Transform normal to world space
    out.world_normal = mesh_functions::mesh_normal_local_to_world(
        normal,
        instance_index
    );
    
    // Pass world position to fragment shader
    out.world_position = world_position;
    
    return out;
}

@fragment
fn fragment(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    // Mode 0: Show normals (demonstrates interpolation between vertices)
    if material.mode == 0u {
        // Normals range from -1 to 1, convert to 0-1 for RGB color
        // Red = X direction, Green = Y direction, Blue = Z direction
        let color = (in.world_normal + 1.0) * 0.5;
        return vec4&lt;f32&gt;(color, 1.0);
    }
    
    // Mode 1: Checkerboard pattern (demonstrates per-pixel fragment shader work)
    if material.mode == 1u {
        // Create a 3D checkerboard pattern
        let scale = 3.0;
        let x = i32(floor(in.world_position.x * scale));
        let y = i32(floor(in.world_position.y * scale));
        let z = i32(floor(in.world_position.z * scale));
        
        // Use bitwise AND to alternate between 0 and 1
        let checker = (x + y + z) &amp; 1;
        
        if checker == 0 {
            return vec4&lt;f32&gt;(0.9, 0.9, 0.9, 1.0); // Light gray
        } else {
            return vec4&lt;f32&gt;(0.2, 0.2, 0.8, 1.0); // Blue
        }
    }
    
    // Mode 2: Height-based gradient (demonstrates math in fragment shader)
    if material.mode == 2u {
        // Color based on Y position (height) in world space
        // Map from -2 to 2 range to 0-1 range for color
        let height = (in.world_position.y + 2.0) / 4.0;
        let color = vec3&lt;f32&gt;(height, 0.5, 1.0 - height);
        return vec4&lt;f32&gt;(color, 1.0);
    }
    
    // Default: Solid color
    return vec4&lt;f32&gt;(1.0, 0.0, 0.0, 1.0);
}
</code></pre><h3 id="the-rust-material-srcmaterialsdebug_pipeliners">The Rust Material (<code>src/materials/debug_pipeline.rs</code>)</h3><p>This is the Rust-side definition of our material. It’s a simple struct that mirrors the DebugMaterial struct in our shader, allowing Bevy’s rendering engine to send our chosen mode value to the GPU.</p><pre><code class="language-rust">use bevy::prelude::*;
use bevy::render::render_resource::{AsBindGroup, ShaderRef};

#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
pub struct DebugPipelineMaterial {
    #[uniform(0)]
    pub mode: u32,
}

impl Material for DebugPipelineMaterial {
    fn fragment_shader() -&gt; ShaderRef {
        &quot;shaders/debug_pipeline.wgsl&quot;.into()
    }

    fn vertex_shader() -&gt; ShaderRef {
        &quot;shaders/debug_pipeline.wgsl&quot;.into()
    }
}
</code></pre><p>Don’t forget to add it to <code>src/materials/mod.rs</code>:</p><pre><code class="language-rust">// ... other materials
pub mod debug_pipeline;
</code></pre><h3 id="the-demo-module-srcdemosdebug_pipeliners">The Demo Module (<code>src/demos/debug_pipeline.rs</code>)</h3><p>This Rust module sets up our Bevy scene. It spawns a sphere with our custom <code>DebugPipelineMaterial</code>, adds a camera and light, and sets up the UI text. Most importantly, it contains the <code>cycle_debug_mode</code> system, which listens for the spacebar press and updates the mode field on our material, triggering the change in the shader.</p><pre><code class="language-rust">use crate::materials::debug_pipeline::DebugPipelineMaterial;
use bevy::prelude::*;

pub fn run() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(MaterialPlugin::&lt;DebugPipelineMaterial&gt;::default())
        .add_systems(Startup, setup)
        .add_systems(Update, (rotate_camera, cycle_debug_mode))
        .run();
}

fn setup(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;DebugPipelineMaterial&gt;&gt;,
) {
    // Spawn a sphere with our debug material (better for showing interpolation)
    commands.spawn((
        Mesh3d(meshes.add(Sphere::new(1.0))),
        MeshMaterial3d(materials.add(DebugPipelineMaterial { mode: 0 })),
    ));

    // Light
    commands.spawn((
        PointLight {
            shadows_enabled: true,
            ..default()
        },
        Transform::from_xyz(4.0, 8.0, 4.0),
    ));

    // Camera
    commands.spawn((
        Camera3d::default(),
        Transform::from_xyz(-2.5, 4.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y),
    ));

    // UI to show current mode
    commands.spawn((
        Text::new(&quot;Press SPACE to cycle debug modes\nMode 0: Normals (shows interpolation)&quot;),
        Node {
            position_type: PositionType::Absolute,
            top: Val::Px(10.0),
            left: Val::Px(10.0),
            ..default()
        },
    ));
}

fn rotate_camera(time: Res&lt;Time&gt;, mut camera_query: Query&lt;&amp;mut Transform, With&lt;Camera3d&gt;&gt;) {
    for mut transform in camera_query.iter_mut() {
        let radius = 9.0;
        let angle = time.elapsed_secs() * 0.5;
        transform.translation.x = angle.cos() * radius;
        transform.translation.z = angle.sin() * radius;
        transform.look_at(Vec3::ZERO, Vec3::Y);
    }
}

fn cycle_debug_mode(
    keyboard: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;DebugPipelineMaterial&gt;&gt;,
    mut text_query: Query&lt;&amp;mut Text&gt;,
) {
    if keyboard.just_pressed(KeyCode::Space) {
        for (_, material) in materials.iter_mut() {
            material.mode = (material.mode + 1) % 3;

            for mut text in text_query.iter_mut() {
                **text = match material.mode {
                    0 =&gt; &quot;Press SPACE to cycle debug modes\nMode 0: Normals (shows interpolation)&quot;.to_string(),
                    1 =&gt; &quot;Press SPACE to cycle debug modes\nMode 1: Checkerboard (per-pixel processing)&quot;.to_string(),
                    2 =&gt; &quot;Press SPACE to cycle debug modes\nMode 2: Height Gradient (fragment math)&quot;.to_string(),
                    _ =&gt; &quot;Unknown mode&quot;.to_string(),
                };
            }
        }
    }
}
</code></pre><p>Don’t forget to add it to <code>src/demos/mod.rs</code>:</p><pre><code class="language-rust">// ... other demoss
pub mod debug_pipeline;
</code></pre><p>And register it in <code>src/main.rs</code>:</p><pre><code class="language-rust">Demo {
    number: &quot;1.1&quot;,
    title: &quot;Understanding the Graphics Pipeline&quot;,
    run: demos::debug_pipeline::run,
},
</code></pre><h3 id="running-the-demo">Running the Demo</h3><p>When you run the project, you will see a sphere. Pressing the spacebar will cycle through the three different debug visualizations, each revealing a different aspect of the pipeline’s inner workings.</p><h4 id="controls">Controls</h4><table><thead><tr><th>Control</th><th>Action</th></tr></thead><tbody><tr><td><strong>SPACE</strong></td><td>Cycle to the next visualization mode (0 -&gt; 1 -&gt; 2 -&gt; 0).</td></tr></tbody></table><h4 id="what-youre-seeing">What You’re Seeing</h4><p>![[screenshot - 1.png]] ![[screenshot - 2.png]] ![[screenshot - 3.png]]</p><table><thead><tr><th>Mode</th><th>Description</th><th>What It Proves</th></tr></thead><tbody><tr><td><strong>0 - Normals</strong></td><td>The sphere is colored based on the direction its surface is facing. Red points right (+X), Green points up (+Y), and Blue points forward (+Z). You see smooth gradients of color across the entire surface.</td><td>This demonstrates <strong>interpolation</strong>. The normals are defined only at the vertices, but the rasterizer smoothly blends them between those points, giving every single pixel its own unique normal vector to use for coloring.</td></tr><tr><td><strong>1 - Checkerboard</strong></td><td>The sphere is covered in a 3D checkerboard pattern that appears fixed in the world as the sphere rotates through it. The pattern is sharp and blocky.</td><td>This demonstrates <strong>per-fragment processing</strong>. The fragment shader calculates which color to be (light gray or blue) for every single pixel independently, based on that pixel’s position in world space.</td></tr><tr><td><strong>2 - Height Gradient</strong></td><td>The sphere is colored with a gradient based on its height in the world. The bottom is magenta, and the top is cyan.</td><td>This demonstrates using <strong>vertex shader data in the fragment shader</strong>. The vertex shader calculates the world_position for each vertex. The rasterizer interpolates it, and the fragment shader uses the Y-component of that position to calculate a color.</td></tr></tbody></table><h2 id="key-takeaways">Key Takeaways</h2><p>This chapter covered a lot of ground. Before moving on, take a moment to solidify these five core concepts. They are the foundation for everything that follows.</p><ol><li><strong>The Pipeline is a CPU-to-GPU Process.</strong><br>Rendering is a collaboration. Your Bevy code on the CPU acts as the <strong>Director</strong>, preparing the scene’s data (meshes, materials, transforms). It then hands this “shot list” to the GPU, a specialized <strong>VFX Studio</strong> that executes the rendering process through a hardware assembly line.</li><li><strong>Shaders are Your Instructions for the VFX Artists.</strong><br>You cannot change the hardware pipeline itself, but you can write small, highly focused programs called <strong>shaders</strong> that run at critical, programmable stages. The GPU’s massively parallel architecture executes your shader code for millions of vertices and pixels per second, which is what makes real-time 3D graphics possible.</li><li><strong>The Vertex Shader’s Job is to POSITION Geometry.</strong><br>This is your “Layout Artist” stage. The vertex shader runs once for every vertex in your mesh. Its primary responsibility is to take that vertex’s 3D position from the original model and transform it through a series of coordinate spaces until it has its final, correct position on the 2D screen.</li><li><strong>The Fragment Shader’s Job is to COLOR Pixels.</strong><br>This is your “Coloring &amp; Lighting Artist” stage. After the hardware rasterizer determines which pixels a triangle covers, the fragment shader runs once for every single one of those “fragments.” Its sole responsibility is to calculate and return the final RGBA color for that specific spot on the screen. This is where you apply textures, lighting, and visual effects.</li><li><strong>Data Flows and is Interpolated from Vertex to Fragment.</strong><br>The two shaders are connected. The vertex shader can pass data (like UV coordinates or normal vectors) to the next stage. The hardware <strong>Rasterizer</strong> automatically <strong>interpolates</strong> (smoothly blends) this data across the face of the triangle, making a unique version of it available to the fragment shader for every single pixel.</li></ol><h2 id="whats-next">What’s Next?</h2><p>You now have the essential mental model for the rendering pipeline - you understand where your shader code runs and the specific job of each stage. With this “map” in hand, we are finally ready to learn the language of the GPU’s artists themselves.</p><p>In the next article, we will dive into the fundamental building blocks of the WGSL language: its data types and variables. You’ll learn how to represent positions, colors, and transformations in your code using scalars, vectors, and matrices.</p><p><em>Next up:</em> <a href="https://hexbee.hashnode.dev/12-wgsl-fundamentals-data-types-and-variables"><strong><em>1.2 - WGSL Fundamentals - Data Types &amp; Variables</em></strong></a></p><hr><h2 id="quick-reference">Quick Reference</h2><p>A summary of the core concepts for quick lookup.</p><h3 id="the-pipeline-stages--their-jobs">The Pipeline Stages &amp; Their Jobs</h3><table><thead><tr><th>Stage</th><th>Analogy</th><th>Role (What it does)</th><th>Programmable?</th></tr></thead><tbody><tr><td><strong>1. Application (CPU)</strong></td><td>The Director</td><td>Prepares all scene data: meshes, materials, transforms, camera info.</td><td>Yes (Rust)</td></tr><tr><td><strong>2. Vertex Shader</strong></td><td>The Layout Artist</td><td>Runs <strong>per-vertex</strong> to calculate its final on-screen position (in Clip Space).</td><td><strong>Yes (WGSL)</strong></td></tr><tr><td><strong>3. Rasterizer</strong></td><td>The Render Farm</td><td><strong>Automatic hardware</strong> step that turns 3D triangles into a 2D grid of fragments.</td><td>No</td></tr><tr><td><strong>4. Fragment Shader</strong></td><td>The Coloring Artist</td><td>Runs <strong>per-fragment</strong> to calculate its final RGBA color.</td><td><strong>Yes (WGSL)</strong></td></tr><tr><td><strong>5. Output Merger</strong></td><td>The Final Print</td><td><strong>Automatic hardware</strong> step that performs depth tests and writes the final color.</td><td>No</td></tr></tbody></table><h3 id="the-coordinate-space-journey-1">The Coordinate Space Journey</h3><p>This is the required path a single vertex position takes through the Vertex Shader.</p><pre><code class="language-plaintext">Local Space → World Space → View Space → Clip Space
</code></pre><p>(The GPU then automatically handles the final conversion to Screen Space)</p><h3 id="core-concepts">Core Concepts</h3><ul><li><strong>Parallelism</strong>: The GPU’s core strength. It processes thousands of vertices and millions of fragments simultaneously. Your shader code is the instruction set for this parallel work.</li><li><strong>Interpolation</strong>: The process by which the <strong>Rasterizer</strong> automatically and smoothly blends data (like colors, UVs, or normals) that was output by the <strong>Vertex Shader</strong> at the corners of a triangle. This provides a unique value for that data to the <strong>Fragment Shader</strong> for every pixel the triangle covers.</li></ul></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on December 13, 2025</p><div class="post__share"></div></footer><nav class="pagination"><div class="pagination__title"><span>Read other posts</span></div><div class="pagination__buttons"><a href="https://xav.github.io/learning-wgsl-shaders-with-bevy-016-a-practical-journey/" class="btn previous" rel="prev" aria-label="[MISSING TRANSLATION]:  Learning WGSL Shaders with Bevy 0.16: A Practical Journey "><span class="btn__icon">←</span> <span class="btn__text">Learning WGSL Shaders with Bevy 0.16: A Practical Journey</span> </a><a href="https://xav.github.io/12-wgsl-fundamentals-data-types-and-variables-2/" class="btn next" rel="next" aria-label="[MISSING TRANSLATION]:  1.2 - WGSL Fundamentals - Data Types &amp; Variables "><span class="btn__text">1.2 - WGSL Fundamentals - Data Types &amp; Variables</span> <span class="btn__icon">→</span></a></div></nav></article></main><footer class="footer"><div class="footer__inner"><div class="footer__copyright"><p>© 2024 Powered by Publii CMS :: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank" rel="noopener">Theme</a> ported by the <a href="https://getpublii.com/customization-service/" target="_blank" rel="noopener">Publii Team</a></p></div></div></footer></div><script defer="defer" src="https://xav.github.io/assets/js/scripts.min.js?v=c2232aa7558e9517946129d2a1b8c770"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script defer="defer" src="https://xav.github.io/media/plugins/syntaxHighlighter/prism.js"></script></body></html>