<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Complete WGSL Built-in Function Reference - Hexbee&#x27;s Dev Journal</title><meta name="description" content="Think of the main tutorial series as a guided tour of the most important landmarks in shader programming. We focus on the essential, powerful tools you’ll use every day, like mix(), dot(), and normalize(). But what happens when you’re off the guided path and have a specific question?&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://xav.github.io/complete-wgsl-built-in-function-reference.html"><link rel="alternate" type="application/atom+xml" href="https://xav.github.io/feed.xml" title="Hexbee&#x27;s Dev Journal - RSS"><link rel="alternate" type="application/json" href="https://xav.github.io/feed.json" title="Hexbee&#x27;s Dev Journal - JSON"><meta property="og:title" content="Complete WGSL Built-in Function Reference"><meta property="og:image" content="https://xav.github.io/media/website/Logo-SideName.png"><meta property="og:image:width" content="5553"><meta property="og:image:height" content="2297"><meta property="og:site_name" content="Hexbee's Dev Journal"><meta property="og:description" content="Think of the main tutorial series as a guided tour of the most important landmarks in shader programming. We focus on the essential, powerful tools you’ll use every day, like mix(), dot(), and normalize(). But what happens when you’re off the guided path and have a specific question?&hellip;"><meta property="og:url" content="https://xav.github.io/complete-wgsl-built-in-function-reference.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://xav.github.io/assets/css/style.css?v=b09e72b2ca1a38c969d44da51bb22509"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://xav.github.io/complete-wgsl-built-in-function-reference.html"},"headline":"Complete WGSL Built-in Function Reference","datePublished":"2025-12-08T19:17+01:00","dateModified":"2025-12-08T19:17+01:00","image":{"@type":"ImageObject","url":"https://xav.github.io/media/website/Logo-SideName.png","height":2297,"width":5553},"description":"Think of the main tutorial series as a guided tour of the most important landmarks in shader programming. We focus on the essential, powerful tools you’ll use every day, like mix(), dot(), and normalize(). But what happens when you’re off the guided path and have a specific question?&hellip;","author":{"@type":"Person","name":"Xavier Basty Kjellberg","url":"https://xav.github.io/authors/xavier-basty-kjellberg/"},"publisher":{"@type":"Organization","name":"Xavier Basty Kjellberg","logo":{"@type":"ImageObject","url":"https://xav.github.io/media/website/Logo-SideName.png","height":2297,"width":5553}}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="page-template"><header class="top js-header"><a class="logo" href="https://xav.github.io/"><img src="https://xav.github.io/media/website/Logo-SideName.png" alt="Hexbee&#x27;s Dev Journal" width="5553" height="2297"></a></header><main class="page"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Complete WGSL Built-in Function Reference</h1></div></header></div><div class="entry-wrapper content__entry"><p>Think of the <a href="https://hexbee.ghost.io/learning-wgsl-shaders-with-bevy-0-16-a-practical-journey/">main tutorial series</a> as a guided tour of the most important landmarks in shader programming. We focus on the essential, powerful tools you’ll use every day, like <code>mix()</code>, <code>dot()</code>, and <code>normalize()</code>.</p><p>But what happens when you’re off the guided path and have a specific question? “What’s the best way to manipulate individual bits?” “Is there a faster way to calculate a square root?” “How do I read a single texel from a specific mipmap level?”</p><p>This appendix is your comprehensive encyclopedia for those moments. It’s a categorized, practical reference to the entire WGSL built-in function library, designed to give you the right answer quickly without forcing you to parse the dense official WGSL specification.</p><p>Each function is documented with a consistent format for easy scanning:</p><ul><li><strong>Signature:</strong> <code>function_name(parameter: type) -&gt; return_type</code></li><li><strong>Description:</strong> A concise explanation of what the function does.</li><li><strong>Use Case:</strong> A short code snippet demonstrating a practical application.</li></ul><h2 id="alphabetical-function-index">Alphabetical Function Index</h2><p>For quick lookups, here is a complete list of all built-in WGSL functions in alphabetical order. Click on any function name to jump directly to its detailed entry.</p><p><a href="#abs"><code>abs</code></a> <a href="#acos"><code>acos</code></a> <a href="#acosh"><code>acosh</code></a> <a href="#all"><code>all</code></a> <a href="#any"><code>any</code></a> <a href="#arraylength"><code>arrayLength</code></a> <a href="#asin"><code>asin</code></a> <a href="#asinh"><code>asinh</code></a> <a href="#atan"><code>atan</code></a> <a href="#atan2"><code>atan2</code></a> <a href="#atanh"><code>atanh</code></a> <a href="#atomicadd"><code>atomicAdd</code></a> <a href="#atomiccompareexchangeweak"><code>atomicCompareExchangeWeak</code></a> <a href="#atomicexchange"><code>atomicExchange</code></a> <a href="#atomicload"><code>atomicLoad</code></a> <a href="#atomicstore"><code>atomicStore</code></a></p><p><a href="#bitcast"><code>bitcast</code></a></p><p><a href="#ceil"><code>ceil</code></a> <a href="#clamp"><code>clamp</code></a> <a href="#cos"><code>cos</code></a> <a href="#cosh"><code>cosh</code></a> <a href="#countleadingzeros"><code>countLeadingZeros</code></a> <a href="#countonebits"><code>countOneBits</code></a> <a href="#counttrailingzeros"><code>countTrailingZeros</code></a> <a href="#cross"><code>cross</code></a></p><p><a href="#degrees"><code>degrees</code></a> <a href="#determinant"><code>determinant</code></a> <a href="#distance"><code>distance</code></a> <a href="#dot"><code>dot</code></a> <a href="#dpdx"><code>dpdx</code></a> <a href="#dpdxcoarse"><code>dpdxCoarse</code></a> <a href="#dpdxfine"><code>dpdxFine</code></a> <a href="#dpdy"><code>dpdy</code></a> <a href="#dpdycoarse"><code>dpdyCoarse</code></a> <a href="#dpdyfine"><code>dpdyFine</code></a></p><p><a href="#exp"><code>exp</code></a> <a href="#exp2"><code>exp2</code></a> <a href="#extractbits"><code>extractBits</code></a></p><p><a href="#faceforward"><code>faceForward</code></a> <a href="#firstleadingbit"><code>firstLeadingBit</code></a> <a href="#firsttrailingbit"><code>firstTrailingBit</code></a> <a href="#floor"><code>floor</code></a> <a href="#fma"><code>fma</code></a> <a href="#fract"><code>fract</code></a> <a href="#frexp"><code>frexp</code></a> <a href="#fwidth"><code>fwidth</code></a> <a href="#fwidthcoarse"><code>fwidthCoarse</code></a> <a href="#fwidthfine"><code>fwidthFine</code></a></p><p><a href="#insertbits"><code>insertBits</code></a> <a href="#inversesqrt"><code>inverseSqrt</code></a></p><p><a href="#ldexp"><code>ldexp</code></a> <a href="#length"><code>length</code></a> <a href="#log"><code>log</code></a> <a href="#log2"><code>log2</code></a></p><p><a href="#max"><code>max</code></a> <a href="#min"><code>min</code></a> <a href="#mix"><code>mix</code></a> <a href="#modf"><code>modf</code></a></p><p><a href="#normalize"><code>normalize</code></a></p><p><a href="#pack2x16float"><code>pack2x16float</code></a> <a href="#pack2x16snorm"><code>pack2x16snorm</code></a> <a href="#pack2x16unorm"><code>pack2x16unorm</code></a> <a href="#pack4x8snorm"><code>pack4x8snorm</code></a> <a href="#pack4x8unorm"><code>pack4x8unorm</code></a> <a href="#pow"><code>pow</code></a></p><p><a href="#quantizetof16"><code>quantizeToF16</code></a></p><p><a href="#radians"><code>radians</code></a> <a href="#reflect"><code>reflect</code></a> <a href="#refract"><code>refract</code></a> <a href="#reversebits"><code>reverseBits</code></a> <a href="#round"><code>round</code></a></p><p><a href="#saturate"><code>saturate</code></a> <a href="#select"><code>select</code></a> <a href="#sign"><code>sign</code></a> <a href="#sin"><code>sin</code></a> <a href="#sinh"><code>sinh</code></a> <a href="#smoothstep"><code>smoothstep</code></a> <a href="#sqrt"><code>sqrt</code></a> <a href="#step"><code>step</code></a> <a href="#storagebarrier"><code>storageBarrier</code></a></p><p><a href="#tan"><code>tan</code></a> <a href="#tanh"><code>tanh</code></a> <a href="#texturedimensions"><code>textureDimensions</code></a> <a href="#texturegather"><code>textureGather</code></a> <a href="#texturegathercompare"><code>textureGatherCompare</code></a> <a href="#textureload"><code>textureLoad</code></a> <a href="#texturenumlayers"><code>textureNumLayers</code></a> <a href="#texturenumlevels"><code>textureNumLevels</code></a> <a href="#texturenumsamples"><code>textureNumSamples</code></a> <a href="#texturesample"><code>textureSample</code></a> <a href="#texturesamplebaseclamptoedge"><code>textureSampleBaseClampToEdge</code></a> <a href="#texturesamplebias"><code>textureSampleBias</code></a> <a href="#texturesamplecompare"><code>textureSampleCompare</code></a> <a href="#texturesamplecomparelevel"><code>textureSampleCompareLevel</code></a> <a href="#texturesamplegrad"><code>textureSampleGrad</code></a> <a href="#texturesamplelevel"><code>textureSampleLevel</code></a> <a href="#texturestore"><code>textureStore</code></a> <a href="#transpose"><code>transpose</code></a> <a href="#trunc"><code>trunc</code></a></p><p><a href="#unpack2x16float"><code>unpack2x16float</code></a> <a href="#unpack2x16snorm"><code>unpack2x16snorm</code></a> <a href="#unpack2x16unorm"><code>unpack2x16unorm</code></a> <a href="#unpack4x8snorm"><code>unpack4x8snorm</code></a> <a href="#unpack4x8unorm"><code>unpack4x8unorm</code></a></p><p><a href="#workgroupbarrier"><code>workgroupBarrier</code></a> <a href="#workgroupuniformload"><code>workgroupUniformLoad</code></a></p><h2 id="index-by-category">Index by Category</h2><p>To discover functions based on their purpose, browse the categories below.</p><ul><li><a href="#scalar--common-mathematical-functions">Scalar &amp; Common Mathematical Functions</a><ul><li><a href="#abs"><code>abs</code></a></li><li><a href="#acos"><code>acos</code></a></li><li><a href="#acosh"><code>acosh</code></a></li><li><a href="#asin"><code>asin</code></a></li><li><a href="#asinh"><code>asinh</code></a></li><li><a href="#atan"><code>atan</code></a></li><li><a href="#atan2"><code>atan2</code></a></li><li><a href="#atanh"><code>atanh</code></a></li><li><a href="#ceil"><code>ceil</code></a></li><li><a href="#cos"><code>cos</code></a></li><li><a href="#cosh"><code>cosh</code></a></li><li><a href="#degrees"><code>degrees</code></a></li><li><a href="#exp"><code>exp</code></a></li><li><a href="#exp2"><code>exp2</code></a></li><li><a href="#floor"><code>floor</code></a></li><li><a href="#fma"><code>fma</code></a></li><li><a href="#fract"><code>fract</code></a></li><li><a href="#frexp"><code>frexp</code></a></li><li><a href="#inversesqrt"><code>inverseSqrt</code></a></li><li><a href="#ldexp"><code>ldexp</code></a></li><li><a href="#log"><code>log</code></a></li><li><a href="#log2"><code>log2</code></a></li><li><a href="#modf"><code>modf</code></a></li><li><a href="#pow"><code>pow</code></a></li><li><a href="#quantizetof16"><code>quantizeToF16</code></a></li><li><a href="#radians"><code>radians</code></a></li><li><a href="#round"><code>round</code></a></li><li><a href="#sign"><code>sign</code></a></li><li><a href="#sin"><code>sin</code></a></li><li><a href="#sinh"><code>sinh</code></a></li><li><a href="#sqrt"><code>sqrt</code></a></li><li><a href="#tan"><code>tan</code></a></li><li><a href="#tanh"><code>tanh</code></a></li><li><a href="#trunc"><code>trunc</code></a></li></ul></li><li><a href="#vector-functions">Vector Functions</a><ul><li><a href="#cross"><code>cross</code></a></li><li><a href="#distance"><code>distance</code></a></li><li><a href="#dot"><code>dot</code></a></li><li><a href="#faceforward"><code>faceForward</code></a></li><li><a href="#length"><code>length</code></a></li><li><a href="#normalize"><code>normalize</code></a></li><li><a href="#reflect"><code>reflect</code></a></li><li><a href="#refract"><code>refract</code></a></li></ul></li><li><a href="#matrix-functions">Matrix Functions</a><ul><li><a href="#determinant"><code>determinant</code></a></li><li><a href="#transpose"><code>transpose</code></a></li></ul></li><li><a href="#interpolation--clamping-functions">Interpolation &amp; Clamping Functions</a><ul><li><a href="#clamp"><code>clamp</code></a></li><li><a href="#max"><code>max</code></a></li><li><a href="#min"><code>min</code></a></li><li><a href="#mix"><code>mix</code></a></li><li><a href="#saturate"><code>saturate</code></a></li><li><a href="#smoothstep"><code>smoothstep</code></a></li><li><a href="#step"><code>step</code></a></li></ul></li><li><a href="#logical--selection-functions">Logical &amp; Selection Functions</a><ul><li><a href="#all"><code>all</code></a></li><li><a href="#any"><code>any</code></a></li><li><a href="#select"><code>select</code></a></li></ul></li><li><a href="#integer--bitwise-functions">Integer &amp; Bitwise Functions</a><ul><li><a href="#countleadingzeros"><code>countLeadingZeros</code></a></li><li><a href="#countonebits"><code>countOneBits</code></a></li><li><a href="#counttrailingzeros"><code>countTrailingZeros</code></a></li><li><a href="#extractbits"><code>extractBits</code></a></li><li><a href="#firstleadingbit"><code>firstLeadingBit</code></a></li><li><a href="#firsttrailingbit"><code>firstTrailingBit</code></a></li><li><a href="#insertbits"><code>insertBits</code></a></li><li><a href="#reversebits"><code>reverseBits</code></a></li></ul></li><li><a href="#buffer-and-array-functions">Buffer and Array Functions</a><ul><li><a href="#arraylength"><code>arrayLength</code></a></li></ul></li><li><a href="#type-conversion--reinterpretation">Type Conversion &amp; Reinterpretation</a><ul><li><a href="#bitcast"><code>bitcast</code></a></li></ul></li><li><a href="#packing--unpacking-functions">Packing &amp; Unpacking Functions</a><ul><li><a href="#pack2x16float"><code>pack2x16float</code></a></li><li><a href="#pack2x16snorm"><code>pack2x16snorm</code></a></li><li><a href="#pack2x16unorm"><code>pack2x16unorm</code></a></li><li><a href="#pack4x8snorm"><code>pack4x8snorm</code></a></li><li><a href="#pack4x8unorm"><code>pack4x8unorm</code></a></li><li><a href="#unpack2x16float"><code>unpack2x16float</code></a></li><li><a href="#unpack2x16snorm"><code>unpack2x16snorm</code></a></li><li><a href="#unpack2x16unorm"><code>unpack2x16unorm</code></a></li><li><a href="#unpack4x8snorm"><code>unpack4x8snorm</code></a></li><li><a href="#unpack4x8unorm"><code>unpack4x8unorm</code></a></li></ul></li><li><a href="#texture-functions">Texture Functions</a><ul><li><a href="#texturedimensions"><code>textureDimensions</code></a></li><li><a href="#texturegather"><code>textureGather</code></a></li><li><a href="#texturegathercompare"><code>textureGatherCompare</code></a></li><li><a href="#textureload"><code>textureLoad</code></a></li><li><a href="#texturenumlayers"><code>textureNumLayers</code></a></li><li><a href="#texturenumlevels"><code>textureNumLevels</code></a></li><li><a href="#texturenumsamples"><code>textureNumSamples</code></a></li><li><a href="#texturesample"><code>textureSample</code></a></li><li><a href="#texturesamplebaseclamptoedge"><code>textureSampleBaseClampToEdge</code></a></li><li><a href="#texturesamplebias"><code>textureSampleBias</code></a></li><li><a href="#texturesamplecompare"><code>textureSampleCompare</code></a></li><li><a href="#texturesamplecomparelevel"><code>textureSampleCompareLevel</code></a></li><li><a href="#texturesamplegrad"><code>textureSampleGrad</code></a></li><li><a href="#texturesamplelevel"><code>textureSampleLevel</code></a></li><li><a href="#texturestore"><code>textureStore</code></a></li></ul></li><li><a href="#derivative-functions">Derivative Functions</a><ul><li><a href="#dpdx"><code>dpdx</code></a></li><li><a href="#dpdxcoarse"><code>dpdxCoarse</code></a></li><li><a href="#dpdxfine"><code>dpdxFine</code></a></li><li><a href="#dpdy"><code>dpdy</code></a></li><li><a href="#dpdycoarse"><code>dpdyCoarse</code></a></li><li><a href="#dpdyfine"><code>dpdyFine</code></a></li><li><a href="#fwidth"><code>fwidth</code></a></li><li><a href="#fwidthcoarse"><code>fwidthCoarse</code></a></li><li><a href="#fwidthfine"><code>fwidthFine</code></a></li></ul></li><li><a href="#atomic-read-modify-write-functions">Atomic Read-Modify-Write Functions</a><ul><li><a href="#atomicadd"><code>atomicAdd</code></a></li><li><a href="#atomicsub"><code>atomicSub</code></a></li><li><a href="#atomicmax"><code>atomicMax</code></a></li><li><a href="#atomicmin"><code>atomicMin</code></a></li><li><a href="#atomicand"><code>atomicAnd</code></a></li><li><a href="#atomicor"><code>atomicOr</code></a></li><li><a href="#atomicxor"><code>atomicXor</code></a></li></ul></li><li><a href="#atomic-access-and-exchange-functions">Atomic Access and Exchange Functions</a><ul><li><a href="#atomicload"><code>atomicLoad</code></a></li><li><a href="#atomicstore"><code>atomicStore</code></a></li><li><a href="#atomicexchange"><code>atomicExchange</code></a></li><li><a href="#atomiccompareexchangeweak"><code>atomicCompareExchangeWeak</code></a></li></ul></li><li><a href="#synchronization-functions">Synchronization Functions</a><ul><li><a href="#storagebarrier"><code>storageBarrier</code></a></li><li><a href="#workgroupbarrier"><code>workgroupBarrier</code></a></li><li><a href="#workgroupuniformload"><code>workgroupUniformLoad</code></a></li></ul></li></ul><h2 id="scalar--common-mathematical-functions">Scalar &amp; Common Mathematical Functions</h2><p>This is the largest and most fundamental category of built-in functions in WGSL. These are the mathematical workhorses that form the building blocks of almost every shader effect.</p><p>While primarily designed to operate on single scalar values (like <code>f32</code> or <code>i32</code>), these functions have the powerful property of automatically working component-wise when given a vector input. This means you can apply the same operation to all elements of a vector in a single, concise call.</p><p>The toolkit provided by this category is vast. It gives you the power to create smooth, repeating motion for animation through trigonometric operations. You can control and shape numerical values by manipulating their sign or fractional parts, which is the key to generating procedural, tiled patterns. Furthermore, you can implement non-linear curves and falloffs for realistic lighting and effects using functions for powers, roots, and exponents. This is the essential mathematical library you will reach for in nearly every shader you write.</p><h3 id="abs"><code>abs</code></h3><h4 id="signature">Signature</h4><p><code>abs(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>i32</code>, <code>u32</code>, or <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description">Description</h4><p>Calculates the <a href="https://reference.wolfram.com/language/ref/Abs.html">absolute value</a> of <code>e</code>, making negative values positive. When <code>e</code> is a vector, the function is applied to each component individually.</p><ul><li><strong>For floating-point types (<code>f32</code>):</strong> This effectively removes the negative sign. <code>abs(-5.0)</code> is <code>5.0</code>.</li><li><strong>For unsigned integer types (<code>u32</code>):</strong> The function has no effect and simply returns <code>e</code>.</li><li><strong>For signed integer types (<code>i32</code>):</strong> There is a specific edge case. The largest negative number (<code>-2,147,483,648</code>) does not have a positive equivalent within the <code>i32</code> range. In this specific case, <code>abs()</code> will return the original negative number. This is a rare overflow condition to be aware of.</li></ul><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#abs-float-builtin"><code>abs</code></a></em></p><h4 id="use-case">Use Case</h4><p>A common use is to create a “bounce” or “mirror” effect from an oscillating function like <code>sin()</code>.</p><pre><code class="language-wgsl">// Create a &quot;bounce&quot; animation instead of a standard wave.
let time: f32 = ...;
let wave = sin(time);   // Oscillates between -1.0 and 1.0
let bounce = abs(wave); // Now oscillates between 0.0 and 1.0

// This is useful for effects that should grow and shrink but never go negative.
</code></pre><h3 id="acos"><code>acos</code></h3><h4 id="signature-1">Signature</h4><p><code>acos(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-1">Description</h4><p>Calculates the <a href="https://reference.wolfram.com/language/ref/ArcCos.html">arc cosine</a> of <code>e</code>. This is the inverse of the <a href="#cos"><code>cos</code></a> function; it takes a value and returns the angle in radians whose cosine is that value.</p><p>The input <code>e</code> <strong>must be in the range <code>[-1.0, 1.0]</code></strong>. Providing a value outside this range will result in implementation-defined behavior, which is often <code>NaN</code> (Not a Number). To avoid this, it is highly recommended to <a href="#clamp"><code>clamp()</code></a> the input value before passing it to <code>acos()</code>.</p><p>The result is returned in radians, within the range <code>[0, π]</code>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#acos-builtin"><code>acos</code></a></em></p><h4 id="use-case-1">Use Case</h4><p>The primary use case for <code>acos</code> is to find the angle between two normalized (unit-length) vectors.</p><pre><code class="language-wgsl">let vector_a = normalize(vec3&lt;f32&gt;(1.0, 0.0, 0.0));
let vector_b = normalize(vec3&lt;f32&gt;(0.5, 0.866, 0.0)); // Rotated 60 degrees

// The dot product of two unit vectors gives the cosine of the angle between them.
let dot_product = dot(vector_a, vector_b); // Result is ~0.5

// Due to floating-point inaccuracies, the dot product might be slightly
// outside [-1, 1]. Clamping it is a robust best practice.
let clamped_dot = clamp(dot_product, -1.0, 1.0);

// `acos` gives us the actual angle in radians.
let angle_radians = acos(clamped_dot); // Result is ~1.047, which is PI / 3 (60 degrees)
</code></pre><h3 id="acosh"><code>acosh</code></h3><h4 id="signature-2">Signature</h4><p><code>acosh(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-2">Description</h4><p>Calculates the <a href="https://reference.wolfram.com/language/ref/ArcCosh.html">arc hyperbolic cosine</a> of <code>e</code>, which is the inverse of the <a href="#cosh"><code>cosh</code></a> function.</p><p>The input <code>e</code> <strong>must be greater than or equal to 1.0</strong>. Providing a value less than 1.0 will result in implementation-defined behavior, which is often <code>NaN</code> (Not a Number).</p><p>The result is returned in the range <code>[0, +infinity)</code>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#acosh-builtin"><code>acosh</code></a></em></p><h4 id="use-case-2">Use Case</h4><p>This is a specialized mathematical function and is less common in general visual effects than its trigonometric counterpart, <a href="#acos"><code>acos</code></a>. It is used in scenarios involving hyperbolic geometry or solving equations that use the <code>cosh</code> function, such as calculations related to <a href="https://en.wikipedia.org/wiki/Catenary">catenary curves</a> (the shape of a hanging chain).</p><pre><code class="language-wgsl">// `acosh` is the inverse of `cosh`.
let original_param = 2.0;
let cosh_result = cosh(original_param); // cosh(2.0) is approx 3.76

// To reverse the operation, we use acosh.
// The input is &gt;= 1.0, so this is a valid operation.
let recovered_param = acosh(cosh_result); // Result is ~2.0
</code></pre><h3 id="asin"><code>asin</code></h3><h4 id="signature-3">Signature</h4><p><code>asin(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-3">Description</h4><p>Calculates the <a href="https://reference.wolfram.com/language/ref/ArcSin.html">arc sine</a> of <code>e</code>, which is the inverse of the <a href="#sin"><code>sin</code></a> function. It takes a value <code>e</code> and returns the angle in radians whose sine is <code>e</code>.</p><p>The input <code>e</code> <strong>must be in the range <code>[-1.0, 1.0]</code></strong>. Providing a value outside this range will result in implementation-defined behavior (often <code>NaN</code>). To ensure correctness, it is best practice to <a href="#clamp"><code>clamp()</code></a> the input before passing it to <code>asin()</code>.</p><p>The result is returned in radians, within the range <code>[-π/2, π/2]</code>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#asin-builtin"><code>asin</code></a></em></p><h4 id="use-case-3">Use Case</h4><p>While less common than <a href="#acos"><code>acos</code></a> for 3D vector math, <code>asin</code> is useful when you have a ratio that represents the sine of an angle and need to recover the angle itself.</p><pre><code class="language-wgsl">// Imagine you have the y-coordinate of a point on a unit circle and need its angle.
let y_coord = 0.707; // sin(45 degrees) or sin(PI / 4)

// Clamp the input for safety, even though we know it&#39;s valid here.
let clamped_y = clamp(y_coord, -1.0, 1.0);

// `asin` gives us the angle in radians.
let angle_radians = asin(clamped_y); // Result is ~0.785, which is PI / 4 (45 degrees)
</code></pre><h3 id="asinh"><code>asinh</code></h3><h4 id="signature-4">Signature</h4><p><code>asinh(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-4">Description</h4><p>Calculates the <a href="https://reference.wolfram.com/language/ref/ArcSinh.html">arc hyperbolic sine</a> of <code>e</code>, which is the inverse of the <a href="#sinh"><code>sinh</code></a> function. Unlike its trigonometric counterpart <a href="#asin"><code>asin</code></a>, <code>asinh</code> is defined for all real numbers, so no input clamping is necessary.</p><p>The result is returned in the range <code>(-infinity, +infinity)</code>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#asinh-builtin"><code>asinh</code></a></em></p><h4 id="use-case-4">Use Case</h4><p>This is a specialized mathematical function used in scenarios involving hyperbolic geometry or for reversing a <a href="#sinh"><code>sinh</code></a> calculation. It is not commonly used in general visual effects programming.</p><pre><code class="language-wgsl">// `asinh` is the inverse of `sinh`.
let original_param = 1.5;
let sinh_result = sinh(original_param); // sinh(1.5) is approx 2.129

// The `asinh` function can recover the original parameter.
let recovered_param = asinh(sinh_result); // Result is ~1.5
</code></pre><h3 id="atan"><code>atan</code></h3><h4 id="signature-5">Signature</h4><p><code>atan(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector, typically representing a slope (<code>y/x</code>).</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-5">Description</h4><p>Calculates the <a href="https://reference.wolfram.com/language/ref/ArcTan.html">arc tangent</a> of <code>e</code>, which is the inverse of the <a href="#tan"><code>tan</code></a> function. It takes a value <code>e</code> (representing a slope) and returns the angle in radians that produces it.</p><p>The result is returned in radians, within the range <code>[-π/2, π/2]</code> (from -90° to +90°).</p><p>Because the input represents a single ratio, <code>atan</code> cannot distinguish between angles in opposite quadrants. For example, the slope for a vector of <code>(1, 1)</code> is <code>1.0</code>, and the slope for <code>(-1, -1)</code> is also <code>1.0</code>. <code>atan(1.0)</code> will return the same angle for both. For most 2D angle calculations where you have the separate <code>x</code> and <code>y</code> components, the <a href="#atan2"><code>atan2</code></a> function is strongly preferred as it correctly handles all four quadrants.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#atan-builtin"><code>atan</code></a></em></p><h4 id="use-case-5">Use Case</h4><p>Used when you only have a slope value and need to find the corresponding angle within a limited 180-degree range.</p><pre><code class="language-wgsl">// A slope of 1.0 corresponds to a 45-degree angle.
let slope = 1.0;
let angle_radians = atan(slope); // Result is ~0.785, which is PI / 4 (45 degrees)

// A negative slope.
let negative_slope = -1.0;
let neg_angle_rads = atan(negative_slope); // Result is ~-0.785 (-45 degrees)
</code></pre><h3 id="atan2"><code>atan2</code></h3><h4 id="signature-6">Signature</h4><p><code>atan2(y: T, x: T) -&gt; T</code></p><ul><li><code>y</code>: The y-component or numerator.</li><li><code>x</code>: The x-component or denominator.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-6">Description</h4><p>Calculates the <a href="https://reference.wolfram.com/language/ref/ArcTan.html">arc tangent</a> of the quotient <code>y / x</code>, returning an angle in radians.</p><p>Unlike <a href="#atan"><code>atan</code></a>, which only takes a single ratio, <code>atan2</code> is a much more powerful function that uses the signs of both <code>y</code> and <code>x</code> to correctly determine the angle in all four quadrants of a 2D coordinate system. It avoids the division-by-zero errors that would occur with <code>atan(y/x)</code> when <code>x</code> is zero.</p><p>The result is returned in radians, within the full circular range <code>[-π, π]</code> (from -180° to +180°). The function is ill-defined at the origin, where both <code>x</code> and <code>y</code> are zero.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#atan2-builtin"><code>atan2</code></a></em></p><h4 id="use-case-6">Use Case</h4><p><code>atan2</code> is the primary and correct tool for converting 2D Cartesian coordinates (<code>x</code>, <code>y</code>) into a polar angle. This is fundamental for creating circular or radial patterns.</p><pre><code class="language-wgsl">// Center the UV coordinates so (0,0) is at the middle of the screen.
let centered_uv = uv - 0.5;

// `atan2` calculates the angle of the current pixel relative to the center.
// The result is a full 360-degree angle.
let angle = atan2(centered_uv.y, centered_uv.x);

// To visualize, we can map the angle from [-PI, PI] to a [0, 1] range
// and use it as a color hue, creating a color wheel.
let hue = angle / (2.0 * PI) + 0.5;
let color = hsv_to_rgb(hue, 1.0, 1.0); // (using a helper function)

// Example of quadrant awareness:
let angle_top_right    = atan2( 1.0,  1.0); //  PI / 4   ( 45 degrees)
let angle_bottom_left  = atan2(-1.0, -1.0); // -3*PI / 4  (-135 degrees)
// `atan()` would give the same result for both, as the slope is 1.0 in both cases.
</code></pre><h3 id="atanh"><code>atanh</code></h3><h4 id="signature-7">Signature</h4><p><code>atanh(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-7">Description</h4><p>Calculates the <a href="https://reference.wolfram.com/language/ref/ArcTanh.html">arc hyperbolic tangent</a> of <code>e</code>, which is the inverse of the <a href="#tanh"><code>tanh</code></a> function.</p><p>The input <code>e</code> <strong>must be in the range <code>(-1.0, 1.0)</code></strong>. Providing a value where <code>abs(e) &gt;= 1.0</code> will result in implementation-defined behavior (often <code>NaN</code> or infinity). To ensure correctness, it is best practice to <a href="#clamp">clamp()</a> the input to be strictly inside this range.</p><p>The result is returned in the range <code>(-infinity, +infinity)</code>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#atanh-builtin"><code>atanh</code></a></em></p><h4 id="use-case-7">Use Case</h4><p>This is a specialized mathematical function not commonly used in general visual effects. It is primarily used in scenarios involving hyperbolic geometry or for reversing a tanh calculation.</p><pre><code class="language-wgsl">// `atanh` is the inverse of `tanh`.
let original_param = 0.5;
let tanh_result = tanh(original_param); // tanh(0.5) is approx 0.462

// To reverse the operation, we use atanh.
// The input is between -1.0 and 1.0, so this is a valid operation.
let recovered_param = atanh(tanh_result); // Result is ~0.5
</code></pre><h3 id="ceil"><code>ceil</code></h3><h4 id="signature-8">Signature</h4><p><code>ceil(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-8">Description</h4><p>Calculates the “<a href="https://reference.wolfram.com/language/ref/Ceiling.html">ceiling</a>“ of <code>e</code>, which is the smallest whole number that is greater than or equal to <code>e</code>. In simpler terms, it always <strong>rounds up</strong> to the next integer.</p><ul><li><code>ceil(3.2)</code> returns <code>4.0</code></li><li><code>ceil(3.0)</code> returns <code>3.0</code></li><li><code>ceil(-3.2)</code> returns <code>-3.0</code> (since <code>-3</code> is greater than <code>-3.2</code>)</li></ul><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#ceil-builtin"><code>ceil</code></a></em></p><h4 id="use-case-8">Use Case</h4><p><code>ceil</code> is useful for any operation where you need to snap a value up to the next discrete step or grid line.</p><pre><code class="language-wgsl">// Imagine you need to calculate how many inventory slots an item takes up.
// An item might take up a fractional number of slots (e.g., 2.3).
let item_size = 2.3;

// You can&#39;t have a fraction of a slot, so you must round up
// to ensure enough space is allocated.
let slots_needed = ceil(item_size); // Result is 3.0

// This guarantees that even a size of 2.001 will correctly allocate 3 slots.
</code></pre><h3 id="cos"><code>cos</code></h3><h4 id="signature-9">Signature</h4><p><code>cos(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input angle or vector of angles, in radians.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-9">Description</h4><p>Calculates the <a href="https://reference.wolfram.com/language/ref/Cos.html">cosine</a> of <code>e</code>, where <code>e</code> is an angle specified in radians. The result is a smooth, continuous wave that oscillates between <code>-1.0</code> and <code>1.0</code>.</p><p><code>cos</code> is very similar to the <a href="#sin"><code>sin</code></a> function, but is “phase-shifted” by 90 degrees (π/2 radians). This means that <code>cos(0.0)</code> returns <code>1.0</code>, while <code>sin(0.0)</code> returns <code>0.0</code>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#cos-builtin"><code>cos</code></a></em></p><h4 id="use-case-9">Use Case</h4><p><code>cos</code> is fundamental to creating oscillations, waves, and any form of circular motion. It is most famously paired with <a href="#sin"><code>sin</code></a> to describe a point on a circle.</p><pre><code class="language-wgsl">let time = ...; // Animate over time
let angle_in_radians = time * 2.0;
let radius = 5.0;

// `cos` defines the x-coordinate of a point on a circle.
let x = cos(angle_in_radians) * radius;

// `sin` defines the y-coordinate.
let y = sin(angle_in_radians) * radius;

// The resulting point (x, y) will orbit the origin in a perfect circle.
let circular_position = vec2&lt;f32&gt;(x, y);
</code></pre><h3 id="cosh"><code>cosh</code></h3><h4 id="signature-10">Signature</h4><p><code>cosh(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input hyperbolic angle in radians.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-10">Description</h4><p>Calculates the <a href="https://reference.wolfram.com/language/ref/Cosh.html">hyperbolic cosine</a> of <code>e</code>. This function describes the shape of a <a href="https://en.wikipedia.org/wiki/Catenary">catenary curves</a> (the shape of a hanging chain or rope). Mathematically, it is defined as <code>(exp(e) + exp(-e)) / 2</code>.</p><p>The function accepts any real number as input. The output is always greater than or equal to <code>1.0</code>, with <code>cosh(0.0)</code> returning <code>1.0</code>. The function is symmetrical around the y-axis and grows exponentially as <code>e</code> moves away from zero.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#cosh-builtin"><code>cosh</code></a></em></p><h4 id="use-case-10">Use Case</h4><p>cosh is a specialized mathematical function primarily used to model physical phenomena like hanging cables or in advanced geometric calculations. It is rarely used in typical visual effects.</p><pre><code class="language-wgsl">// The cosh function forms a catenary curve.
// At the lowest point (the center of the &quot;chain&quot;), the value is 1.0.
let lowest_point = cosh(0.0); // Returns 1.0

// The value increases exponentially as the input moves away from zero.
let point_on_curve = cosh(2.0); // Result is approx 3.76

// The function is symmetrical.
let other_point = cosh(-2.0); // Also approx 3.76
</code></pre><h3 id="degrees"><code>degrees</code></h3><h4 id="signature-11">Signature</h4><p><code>degrees(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input angle or vector of angles, in radians.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-11">Description</h4><p>Converts a value from radians to degrees. It is the inverse of the <a href="#radians"><code>radians</code></a> function.</p><p>The conversion is performed by approximating the formula <code>e * 180 / π</code>. Since all trigonometric functions in WGSL (<a href="#sin"><code>sin</code></a>, <a href="#cos"><code>cos</code></a>, etc.) operate in radians, this function is typically used only for converting values for debugging or for interfacing with systems that expect degrees.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#degrees-builtin"><code>degrees</code></a></em></p><h4 id="use-case-11">Use Case</h4><p>Useful for converting an angle to a more human-readable format for display or debugging purposes.</p><pre><code class="language-wgsl">// WGSL provides the constant PI (~3.14159 radians).
let angle_rad = PI;

// Convert PI radians to degrees.
let angle_deg = degrees(angle_rad); // Result is 180.0

// The function also works component-wise on vectors.
let angles_rad_vec = vec2&lt;f32&gt;(PI, PI / 2.0);
let angles_deg_vec = degrees(angles_rad_vec); // Result is vec2&lt;f32&gt;(180.0, 90.0)
</code></pre><h3 id="exp"><code>exp</code></h3><h4 id="signature-12">Signature</h4><p><code>exp(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code> or <code>f16</code> or a vector of <code>f32</code> or <code>f16</code> (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-12">Description</h4><p>Calculates the <a href="https://reference.wolfram.com/language/ref/Exp.html">natural exponentiation</a> of <code>e</code>. This is equivalent to raising <em>e</em> (Euler’s number, the mathematical constant ≈ 2.71828) to the power of the input <code>e</code>.</p><p>This function models exponential growth and is the inverse of the <a href="#log"><code>log()</code></a> (natural logarithm) function. As the input <code>e</code> increases linearly, the output grows at an ever-increasing rate.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#exp-builtin"><code>exp</code></a></em></p><h4 id="use-case-12">Use Case</h4><p><code>exp</code> is useful for modeling physical phenomena that follow an exponential curve, such as atmospheric density (fog) or certain types of light attenuation.</p><pre><code class="language-wgsl">// Create an exponential falloff based on distance.
let dist = length(some_position);

// A negative input to `exp` creates exponential decay.
// As `dist` increases, `fog_density` rapidly approaches 0.
let fog_density = exp(-dist * 0.5);

// This creates a much more natural-looking fog falloff than a
// linear one, where the fog thins out slowly at first and then
// disappears very quickly.
</code></pre><h3 id="exp2"><code>exp2</code></h3><h4 id="signature-13">Signature</h4><p><code>exp2(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector, which acts as the exponent.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-13">Description</h4><p>Calculates 2 raised to the power of <code>e</code>. This is equivalent to <a href="#pow"><code>pow(2.0, e)</code></a>.</p><p>This function models base-2 exponential growth and is the inverse of the <a href="#log2"><code>log2()</code></a> function. It is often more convenient or slightly more performant than the general <a href="#pow"><code>pow()</code></a> function when working with powers of two, which is common in computer graphics.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#exp2-builtin"><code>exp2</code></a></em></p><h4 id="use-case-13">Use Case</h4><p><code>exp2</code> is very useful when working with systems that are based on powers of two, such as octaves in procedural noise or mipmap levels.</p><pre><code class="language-wgsl">// A common pattern in procedural noise generation (like Perlin or Simplex noise)
// is to layer multiple &quot;octaves&quot; of noise, where each successive octave
// has double the frequency of the last.

var final_noise = 0.0;
for (var i = 0; i &lt; 4; i = i + 1) { // 4 octaves of noise
    let i_f32 = f32(i);

    // exp2(i_f32) calculates the frequency for this octave:
    // i=0 -&gt; 2^0 = 1.0
    // i=1 -&gt; 2^1 = 2.0
    // i=2 -&gt; 2^2 = 4.0
    // i=3 -&gt; 2^3 = 8.0
    let frequency = exp2(i_f32);

    // ... calculate noise with this frequency ...
}
</code></pre><h3 id="floor"><code>floor</code></h3><h4 id="signature-14">Signature</h4><p><code>floor(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-14">Description</h4><p>Calculates the “<a href="https://reference.wolfram.com/language/ref/Floor.html">floor</a>“ of <code>e</code>, which is the greatest whole number that is less than or equal to <code>e</code>. In simpler terms, it always <strong>rounds down</strong> to the nearest integer.</p><ul><li><code>floor(3.7)</code> returns <code>3.0</code></li><li><code>floor(3.0)</code> returns <code>3.0</code></li><li><code>floor(-3.7)</code> returns <code>-4.0</code> (since <code>-4</code> is less than <code>-3.7</code>)</li></ul><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#floor-builtin"><code>floor</code></a></em></p><h4 id="use-case-14">Use Case</h4><p><code>floor</code> is a cornerstone of procedural pattern generation. It is used to find the integer coordinate or ID of a grid cell, which is essential for creating tiled or repeating patterns.</p><pre><code class="language-wgsl">// Use UV coordinates that range from 0.0 to 1.0 across a surface.
let uv = in.uv;

// Scale the UVs to create a 5x5 grid.
let scaled_uv = uv * 5.0;

// `floor` gives us the integer coordinate of the grid cell we are in.
// `cell_id` will be a vec2 like (0,0), (1,0), (2,4), etc.
let cell_id = floor(scaled_uv);

// We can now use this stable integer ID to give each grid cell a unique
// property, like a pseudo-random color.
let random_value = pseudo_random(cell_id); // (using a helper hash function)
let cell_color = vec3&lt;f32&gt;(random_value);
</code></pre><h3 id="fma"><code>fma</code></h3><h4 id="signature-15">Signature</h4><p><code>fma(e1: T, e2: T, e3: T) -&gt; T</code></p><ul><li><code>e1</code>, <code>e2</code>, <code>e3</code>: The input values or vectors.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-15">Description</h4><p>Calculates and returns <code>(e1 * e2) + e3</code>. The name <code>fma</code> is short for “Fused Multiply-Add.”</p><p>Ideally, this is a “fused” operation, meaning the multiplication <code>e1 * e2</code> is performed with a higher internal precision, and only the final result of the addition is rounded to the target type <code>T</code>. This can produce more accurate results and avoid rounding errors compared to a separate multiply followed by an add.</p><p>However, the WGSL specification allows implementations to treat this as a standard, non-fused operation (a multiply followed by an add). Therefore, you should not rely on the higher precision of a true fused operation unless you are certain of the capabilities of your target hardware and drivers.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#fma-builtin"><code>fma</code></a></em></p><h4 id="use-case-15">Use Case</h4><p><code>fma</code> is a fundamental operation in linear algebra and can be used to efficiently implement many common formulas. For example, the linear interpolation function <a href="#mix"><code>mix(a, b, t)</code></a> can be expressed using <code>fma</code>.</p><pre><code class="language-wgsl">// The `mix` function performs linear interpolation:
// mix(a, b, t) is equivalent to a * (1.0 - t) + b * t

// This can be algebraically rearranged into the `fma` pattern:
// t * (b - a) + a
fn manual_mix(a: vec3&lt;f32&gt;, b: vec3&lt;f32&gt;, t: f32) -&gt; vec3&lt;f32&gt; {
    // This is a direct application of the fma pattern.
    return fma(b - a, vec3&lt;f32&gt;(t), a);
}

let red = vec3(1.0, 0.0, 0.0);
let blue = vec3(0.0, 0.0, 1.0);

// These two lines produce the same result (a purple color).
let result_mix = mix(red, blue, 0.5);
let result_fma = manual_mix(red, blue, 0.5);
</code></pre><h3 id="fract"><code>fract</code></h3><h4 id="signature-16">Signature</h4><p><code>fract(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-16">Description</h4><p>Calculates the fractional part of <code>e</code>, which is equivalent to <code>e - floor(e)</code>. The result is a value representing the part of the number after the decimal point.</p><p>The output is always in the range <code>[0.0, 1.0]</code>. For positive numbers, this is straightforward: <code>fract(3.7)</code> is <code>0.7</code>. For negative numbers, it is <code>1.0</code> minus the fractional part: <code>fract(-3.7)</code> is <code>0.3</code>. Due to floating-point precision, a very small negative number might result in <code>1.0</code>.</p><p>Visually, <code>fract(x)</code> creates a repeating <strong>“sawtooth wave”</strong> that climbs linearly from <code>0.0</code> towards <code>1.0</code> and then instantly drops back to <code>0.0</code> to repeat. This behavior makes it one of the most fundamental functions for procedural pattern generation.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#fract-builtin"><code>fract</code></a></em></p><h4 id="use-case-16">Use Case</h4><p><code>fract</code> is essential for creating repeating or tiled patterns. It is almost always used in combination with <a href="#floor"><code>floor</code></a> to establish a repeating local coordinate system.</p><pre><code class="language-wgsl">// Use UV coordinates that range from 0.0 to 1.0 across a surface.
let uv = in.uv;

// Scale the UVs to create a 10x10 grid.
let scaled_uv = uv * 10.0;

// `floor` gives us the integer ID of the grid cell.
let cell_id = floor(scaled_uv);

// `fract` gives us the coordinate *inside* the current cell.
// `local_uv` will always be in the range [0,1] for x and y,
// resetting for each new cell, creating a repeating coordinate system.
let local_uv = fract(scaled_uv);

// We can now draw something in the center of every cell.
// `length(local_uv - 0.5)` calculates the distance from the cell&#39;s center.
let circle_mask = 1.0 - step(0.4, length(local_uv - 0.5));
// The result is a grid of white circles on a black background.
</code></pre><h3 id="frexp"><code>frexp</code></h3><p>Decomposes a floating-point number into its two fundamental components: a significand (fractional part) and an integer exponent of 2.</p><h4 id="overload-scalar-input">Overload: Scalar Input</h4><p>Applies the decomposition to a single floating-point number.</p><h5 id="signature-17">Signature</h5><p><code>frexp(e: T) -&gt; FrexpResult</code></p><ul><li><code>e</code>: The input scalar value. <code>T</code> can be <code>f32</code> or <code>f16</code>.</li><li><code>FrexpResult</code>: A special, built-in struct that cannot be declared by name. It must be inferred with <code>let</code>.</li></ul><h5 id="description-17">Description</h5><p>The <code>frexp</code> function splits the input <code>e</code> into a significand and an exponent such that <code>e = significand * 2^exponent</code>. The result is returned in a struct with two members:</p><ul><li><code>.fract</code>: A floating-point value of the same type as <code>e</code>. This is the significand, and its absolute value will be in the range <code>[0.5, 1.0)</code>.</li><li><code>.exp</code>: A signed 32-bit integer (<code>i32</code>) representing the exponent.</li></ul><p>You cannot explicitly declare a variable of the return type. Instead, you must use <code>let</code> to infer the type and then access its members.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#frexp-builtin"><code>frexp</code></a></em></p><h4 id="overload-vector-input">Overload: Vector Input</h4><p>Applies the decomposition component-wise to a vector of floating-point numbers.</p><h5 id="signature-18">Signature</h5><p><code>frexp(e: vecN&lt;T&gt;) -&gt; FrexpResultVec</code></p><ul><li><code>e</code>: The input vector. <code>T</code> can be <code>f32</code> or <code>f16</code>. <code>N</code> can be <code>2</code>, <code>3</code>, or <code>4</code>.</li><li><code>FrexpResultVec</code>: A special, built-in struct containing vectors.</li></ul><h5 id="description-18">Description</h5><p>Performs the <code>frexp</code> operation on each component of the input vector <code>e</code>. The result is returned in a struct with two members:</p><ul><li><code>.fract</code>: A vector of the same type as <code>e</code> (e.g., <code>vecN&lt;f32&gt;</code>).</li><li><code>.exp</code>: A vector of signed 32-bit integers (e.g., <code>vecN&lt;i32&gt;</code>).</li></ul><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#frexp-builtin"><code>frexp</code></a></em></p><h4 id="use-case-17">Use Case</h4><p><code>frexp</code> is a low-level function used for manipulating the binary representation of floating-point numbers. It is not common in general visual effects but is useful for certain numerical algorithms.</p><pre><code class="language-wgsl">let my_float = 12.0;

// Decompose the float. The type of `result` is inferred.
let result = frexp(my_float);

// `result.fract` will be 0.75
// `result.exp` will be 4
// Because: 0.75 * 2^4 = 0.75 * 16 = 12.0
let significand = result.fract;
let exponent = result.exp;
</code></pre><pre><code class="language-wgsl">let my_vec = vec2&lt;f32&gt;(12.0, -0.25);

// Decompose the vector.
let result_vec = frexp(my_vec);

// `result_vec.fract` will be vec2&lt;f32&gt;(0.75, -0.5)
// `result_vec.exp` will be vec2&lt;i32&gt;(4, -1)
// Because:
//   -0.5 * 2^-1 = -0.5 * 0.5 = -0.25
let significands = result_vec.fract;
let exponents = result_vec.exp;
</code></pre><h3 id="inversesqrt"><code>inverseSqrt</code></h3><h4 id="signature-19">Signature</h4><p><code>inverseSqrt(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-19">Description</h4><p>Calculates the inverse square root of <code>e</code>, which is equivalent to <code>1.0 / sqrt(e)</code>.</p><p>The input <code>e</code> <strong>must be greater than <code>0</code></strong>. Providing a non-positive value (<code>&lt;= 0</code>) will result in implementation-defined behavior.</p><p>This function is often significantly faster than performing a separate sqrt and <code>division</code>, as many GPUs have a dedicated, hardware-accelerated instruction for this specific operation (<code>rsqrt</code>). It is a key function for high-performance graphics code, especially in vector normalization.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#inverseSqrt-builtin"><code>inverseSqrt</code></a></em></p><h4 id="use-case-18">Use Case</h4><p>The most common use of <code>inverseSqrt</code> is to perform a fast vector normalization. The <a href="#normalize"><code>normalize(v)</code></a> operation is mathematically <code>v / length(v)</code>, which can be rewritten as <code>v * (1.0 / sqrt(dot(v, v)))</code>. This is a perfect fit for <code>inverseSqrt</code>.</p><pre><code class="language-wgsl">fn fast_normalize(v: vec3&lt;f32&gt;) -&gt; vec3&lt;f32&gt; {
    // The squared length of the vector, which is v.x*v.x + v.y*v.y + v.z*v.z
    let length_sq = dot(v, v);

    // Calculate the inverse square root of the squared length.
    let inv_sqrt = inverseSqrt(length_sq);

    // Multiply the original vector by the result.
    return v * inv_sqrt;
}

// This manual implementation is often how the built-in `normalize`
// function is implemented under the hood for maximum performance.
</code></pre><h3 id="ldexp"><code>ldexp</code></h3><h4 id="signature-20">Signature</h4><p><code>ldexp(e1: T, e2: I) -&gt; T</code></p><ul><li><code>e1</code>: The significand (fractional part) or base value.</li><li><code>e2</code>: The integer exponent for the power of 2.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li><li><code>I</code>: Can be <code>i32</code> or a vector of <code>i32</code> (e.g., <code>vec3&lt;i32&gt;</code>).</li></ul><p>The second parameter <code>e2</code> must be a vector if and only if the first parameter <code>e1</code> is a vector, and they must have the same number of components.</p><h4 id="description-20">Description</h4><p>Constructs a floating-point number by calculating <code>e1</code> multiplied by 2 raised to the power of <code>e2</code> (i.e., <code>e1 * 2^e2</code>). The name <code>ldexp</code> is a mnemonic for “load exponent.”</p><p>This function is the inverse of <a href="frexp"><code>frexp</code></a>; it takes a significand and an exponent and reconstructs the original number. For any finite number <code>x</code>, the following is true: <code>x == ldexp(frexp(x).fract, frexp(x).exp)</code>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#ldexp-builtin"><code>ldexp</code></a></em></p><h5 id="exponent-constraints">Exponent Constraints</h5><p>The maximum value for the exponent <code>e2</code> is tied to the internal representation of the floating-point type <code>T</code>, which is defined by an “exponent bias”.</p><ul><li>For <strong><code>f32</code></strong>, the bias is <strong>127</strong>.</li><li>For <strong><code>f16</code></strong>, the bias is <strong>15</strong>.</li><li>For <strong><code>AbstractFloat</code></strong>, the bias is <strong>1023</strong>. <code>AbstractFloat</code> is the high-precision type used for floating-point literals (e.g., <code>1.0</code>, <code>3.14159</code>) during shader compilation, before they are assigned to a concrete type like <code>f32</code>. This high bias reflects the greater precision used for compile-time constant evaluation.</li></ul><p>The operation has the following constraints:</p><ul><li>If <code>e2 + bias</code> is less than or equal to <code>0</code>, the result may be zero (underflow).</li><li>If <code>e2</code> is greater than <code>bias + 1</code>, the behavior depends on when the value is known:<ul><li>If <code>e2</code> is a compile-time constant, it is a shader-creation error.</li><li>Otherwise, the result is an indeterminate value at runtime (e.g., infinity or the maximum float value).</li></ul></li></ul><h4 id="use-case-19">Use Case</h4><p><code>ldexp</code> is primarily used to reconstruct a floating-point number after its components have been manipulated using <a href="frexp"><code>frexp</code></a>. This allows for efficient multiplication or division by powers of two by directly modifying the exponent.</p><pre><code class="language-wgsl">let original_value = 6.0;

// Decompose the value into its parts.
let parts = frexp(original_value); // -&gt; .fract is 0.75, .exp is 3

// To multiply the original value by 4 (which is 2^2),
// we can simply add 2 to the exponent instead of performing a full multiplication.
let new_exponent = parts.exp + 2; // 3 + 2 = 5

// Reconstruct the number using the original significand and the new exponent.
// ldexp(0.75, 5) calculates 0.75 * 2^5 = 0.75 * 32 = 24.0
let final_value = ldexp(parts.fract, new_exponent); // Result is 24.0, which is 6.0 * 4
</code></pre><h3 id="log"><code>log</code></h3><h4 id="signature-21">Signature</h4><p><code>log(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-21">Description</h4><p>Calculates the natural logarithm of the parameter <code>e</code>. The “natural logarithm” is the logarithm to the base <em>e</em> (Euler’s number, the mathematical constant ≈ 2.71828). This function is the inverse of the <a href="#exp"><code>exp()</code></a> function.</p><p>The input <code>e</code> <strong>must be greater than <code>0</code></strong>. Providing a non-positive value (<code>&lt;= 0</code>) will result in implementation-defined behavior.</p><p>Logarithms are useful for compressing a wide range of values into a much smaller one. As the input e grows exponentially, the output of <code>log(e)</code> grows only linearly.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#log-builtin"><code>log</code></a></em></p><h4 id="use-case-20">Use Case</h4><p><code>log</code> is often used to handle values that span several orders of magnitude, like light intensity in HDR (High Dynamic Range) rendering, by converting them to a more manageable scale for processing or display.</p><pre><code class="language-wgsl">// Imagine `hdr_brightness` can range from 1.0 (normal) to 10000.0 (very bright).
let hdr_brightness = 10000.0;

// `log(1.0)` is 0.0
// `log(10000.0)` is approx 9.21
// The `log` function has compressed the huge [1.0, 10000.0] range
// into a much smaller [0.0, 9.21] range.
let compressed_brightness = log(hdr_brightness);

// This smaller range is now much easier to map to a standard [0.0, 1.0]
// displayable brightness for tone mapping.
let display_brightness = compressed_brightness / 10.0; // A simple tone mapping
</code></pre><h3 id="log2"><code>log2</code></h3><h4 id="signature-22">Signature</h4><p>log2(e: T) -&gt; T</p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-22">Description</h4><p>Calculates the base-2 logarithm of <code>e</code>. This function finds the power to which the number 2 must be raised to produce the value <code>e</code>. It is the inverse of the <a href="#exp2"><code>exp2()</code></a> function.</p><p>The input <code>e</code> <strong>must be greater than <code>0</code></strong>. Providing a non-positive value (<code>&lt;= 0</code>) will result in implementation-defined behavior.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#log2-builtin"><code>log2</code></a></em></p><h4 id="use-case-21">Use Case</h4><p><code>log2</code> is particularly useful in computer graphics and programming for problems that involve powers of two, such as calculating mipmap levels or determining the number of bits required for a value.</p><pre><code class="language-wgsl">// log2 answers the question: &quot;2 to the power of what equals this number?&quot;

let val_a = 16.0;
// 2 to the power of 4 is 16, so log2(16.0) is 4.0.
let power_a = log2(val_a); // Result is 4.0

let val_b = 0.25;
// 2 to the power of -2 is 1/(2^2) = 1/4 = 0.25, so log2(0.25) is -2.0.
let power_b = log2(val_b); // Result is -2.0
</code></pre><h3 id="modf"><code>modf</code></h3><p>Decomposes a floating-point number into its whole and fractional parts.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#modf-builtin"><code>modf</code></a></em></p><h4 id="overload-scalar-input-1">Overload: Scalar Input</h4><h5 id="signature-23">Signature</h5><p>Applies the decomposition to a single floating-point number.</p><p><code>modf(e: T) -&gt; ModfResult</code></p><ul><li><code>e</code>: The input scalar value.</li><li><code>T</code>: Can be AbstractFloat, f32, or f16.</li><li><code>ModfResult</code>: A special, built-in struct that cannot be declared by name. It must be inferred with <code>let</code>.</li></ul><h5 id="description-23">Description</h5><p>The <code>modf</code> function splits the input <code>e</code> into its integer and fractional components. The result is returned in a struct with two members, both of which have the same type as the input `e:</p><ul><li><code>.fract</code>: The fractional part of <code>e</code>.</li><li><code>.whole</code>: The whole number (integer) part of <code>e</code>.</li></ul><p>Both the fractional and whole parts will have the same sign as the original input <code>e</code>. Note that the whole number part is returned as a floating-point type, not an integer type.</p><h4 id="overload-vector-input-1">Overload: Vector Input</h4><p>Applies the decomposition component-wise to a vector of floating-point numbers.</p><h5 id="signature-24">Signature</h5><p><code>modf(e: vecN&lt;T&gt;) -&gt; ModfResultVec</code></p><ul><li><code>e</code>: The input vector.</li><li><code>T</code>: Can be <code>f32</code>, or <code>f16</code>. <code>N</code> can be <code>2</code>, <code>3</code>, or <code>4</code>.</li><li><code>ModfResultVec</code>: A special, built-in struct containing vectors that cannot be declared by name. It must be inferred with <code>let</code>.</li></ul><h5 id="description-24">Description</h5><p>Performs the <code>modf</code> operation on each component of the input vector <code>e</code>. The result is returned in a struct with two members:</p><ul><li><code>.fract</code>: A vector of the same type as e (e.g., <code>vecN&lt;f32&gt;</code>).</li><li><code>.whole</code>: A vector of the same type as e (e.g., <code>vecN&lt;f32&gt;</code>).</li></ul><h4 id="use-case-22">Use Case</h4><p><code>modf</code> is useful when you need to operate on both the integer and fractional parts of a number separately. This is distinct from using <a href="floor"><code>floor</code></a> and <a href="fract"><code>fract</code></a>, especially for negative numbers.</p><pre><code class="language-wgsl">let my_float = 3.7;
let result_pos = modf(my_float);
// result_pos.fract is 0.7
// result_pos.whole is 3.0

let my_neg_float = -3.7;
let result_neg = modf(my_neg_float);
// result_neg.fract is -0.7
// result_neg.whole is -3.0

// Compare this to the standard `fract` function:
// fract(-3.7) would return 0.3

let my_vec = vec2&lt;f32&gt;(3.7, -2.5);
let result_vec = modf(my_vec);

// result_vec.fract is vec2&lt;f32&gt;(0.7, -0.5)
// result_vec.whole is vec2&lt;f32&gt;(3.0, -2.0)
</code></pre><h3 id="pow"><code>pow</code></h3><h4 id="signature-25">Signature</h4><p><code>pow(e1: T, e2: T) -&gt; T</code></p><ul><li><code>e1</code>: The base value or vector.</li><li><code>e2</code>: The exponent value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-25">Description</h4><p>Calculates <code>e1</code> raised to the power of <code>e2</code>.</p><p>This is a fundamental function for creating non-linear curves and falloffs. The result can be sensitive to the input values:</p><ul><li>If the base <code>e1</code> is negative, the exponent <code>e2</code> must be a whole number for the result to be mathematically meaningful in the domain of real numbers. A fractional exponent with a negative base will result in implementation-defined behavior (often <code>NaN</code>).</li><li><code>pow(0.0, 0.0)</code> is implementation-defined.</li><li>Raising <code>0.0</code> to a negative exponent will result in infinity.</li></ul><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#pow-builtin"><code>pow</code></a></em></p><h4 id="use-case-23">Use Case</h4><p><code>pow</code> is essential for controlling the sharpness of specular highlights in lighting models and for gamma correction.</p><pre><code class="language-wgsl">// Use Case 1: Specular Highlight
// `dot_product` is the alignment between view and reflection, typically in [0, 1].
let dot_product = max(0.0, dot(view_dir, reflect_dir));
let shininess = 32.0;

// Raising the value to a high power makes the highlight much sharper.
// Values close to 1.0 stay high, while values less than 1.0 fall off very quickly.
let specular_highlight = pow(dot_product, shininess);

// Use Case 2: Gamma Correction
let linear_color = vec3&lt;f32&gt;(0.2, 0.5, 0.9);
let gamma = 2.2;

// Convert from linear color space to sRGB color space for display.
let srgb_color = pow(linear_color, vec3&lt;f32&gt;(1.0 / gamma));
</code></pre><h3 id="quantizetof16"><code>quantizeToF16</code></h3><h4 id="signature-26">Signature</h4><p><code>quantizeToF16(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code> or a vector of <code>f32</code> (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-26">Description</h4><p>Rounds a 32-bit float (<code>f32</code>) down to the nearest value that can be precisely represented by a 16-bit float (<code>f16</code>), and then returns that value as an <code>f32</code>.</p><p>This is a “quantization” function, which means it reduces the precision of a value. The operation is conceptually equivalent to the process of packing an <code>f32</code> into the bits of an <code>f16</code> and then immediately unpacking it back to an <code>f32</code>. This round-trip is lossy, and <code>quantizeToF16</code> gives you the result of that precision loss.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#quantizeToF16-builtin"><code>quantizeToF16</code></a></em></p><h4 id="use-case-24">Use Case</h4><p>This function is used to simulate the precision loss of <code>f16</code> floats while still performing calculations in <code>f32</code>. This is important for maintaining visual consistency and avoiding artifacts in rendering pipelines that might use a mix of <code>f16</code> and <code>f32</code> precision for storing data (e.g., in textures or buffers), especially on mobile or low-power hardware.</p><pre><code class="language-wgsl">// A high-precision 32-bit float.
// 0.100006103515625 is the closest f32 representation of 0.1
let high_precision_val: f32 = 0.100006103515625;

// Simulate storing this value in an f16 buffer and reading it back.
// The result will be the closest f16 value, promoted back to f32.
// 0.0999755859375 is the closest f16 representation of 0.1
let quantized_val: f32 = quantizeToF16(high_precision_val);

// By quantizing, you ensure that any subsequent calculations using this value
// will behave as if the value had been stored with lower precision,
// preventing subtle artifacts that can arise from mixing precisions.
</code></pre><h3 id="radians"><code>radians</code></h3><h4 id="signature-27">Signature</h4><p><code>radians(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input angle or vector of angles, in degrees.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-27">Description</h4><p>Converts a value from degrees to radians. It is the inverse of the <a href="degrees"><code>degrees</code></a> function.</p><p>The conversion is performed by approximating the formula <code>e * π / 180</code>. This is a crucial utility function because all of WGSL’s built-in trigonometric functions (<a href="#sin"><code>sin</code></a>, <a href="#cos"><code>cos</code></a>, <a href="tan"><code>tan</code></a>, etc.) expect their angle inputs to be in radians.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#radians-builtin"><code>radians</code></a></em></p><h4 id="use-case-25">Use Case</h4><p>Used to convert angles from a more human-readable format (degrees) into the required format for trigonometric calculations. This is common when taking user input or parameters defined in degrees.</p><pre><code class="language-wgsl">// A rotation angle specified in degrees, perhaps from a uniform.
let angle_deg = 45.0;

// Convert the angle to radians before using it with sin() or cos().
let angle_rad = radians(angle_deg); // Result is ~0.785, which is PI / 4

// Now `angle_rad` can be correctly used in trigonometric functions.
let val = sin(angle_rad); // Correctly calculates sin(45 degrees)

// The function also works component-wise on vectors.
let angles_deg_vec = vec2&lt;f32&gt;(90.0, 180.0);
let angles_rad_vec = radians(angles_deg_vec); // Result is vec2&lt;f32&gt;(PI / 2.0, PI)
</code></pre><h3 id="round"><code>round</code></h3><h4 id="signature-28">Signature</h4><p><code>round(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-28">Description</h4><p>Rounds the input <code>e</code> to the nearest whole number, returning the result as a floating-point value.</p><p>This function uses the “round half to even” strategy, which is the default rounding mode in the IEEE 754 standard. This means:</p><ul><li>Values are rounded to the closest integer. For example, <code>round(2.3)</code> is <code>2.0</code> and <code>round(2.8)</code> is <code>3.0</code>.</li><li>Values that are exactly halfway between two integers (like <code>2.5</code>) are rounded to the <strong>nearest even integer</strong>.<ul><li><code>round(2.5)</code> returns <code>2.0</code></li><li><code>round(3.5)</code> returns <code>4.0</code></li><li><code>round(-2.5)</code> returns <code>-2.0</code></li></ul></li></ul><p>This behavior is different from the common “always round .5 up” rule and is designed to reduce statistical bias in long calculations.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#round-builtin"><code>round</code></a></em></p><h4 id="use-case-26">Use Case</h4><p><code>round</code> is useful for snapping values to the nearest integer grid, for example, to create a pixelated or mosaic effect.</p><pre><code class="language-wgsl">// Use UV coordinates that range from 0.0 to 1.0.
let uv = in.uv;

// Scale the UVs to define the size of our &quot;pixels&quot;.
let pixel_grid_size = 10.0;
let scaled_uv = uv * pixel_grid_size;

// Round the scaled UVs to the nearest integer coordinate.
let rounded_uv = round(scaled_uv);

// Scale back down to the original 0-1 range. This creates large blocks
// where every fragment inside a grid cell gets the same final UV coordinate.
let pixelated_uv = rounded_uv / pixel_grid_size;

// Sampling a texture with these new UVs will produce a mosaic effect.
let final_color = textureSample(my_texture, my_sampler, pixelated_uv);
</code></pre><h3 id="sign"><code>sign</code></h3><h4 id="signature-29">Signature</h4><p><code>sign(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, <code>i32</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-29">Description</h4><p>Extracts the sign of <code>e</code> and returns it as a value of the same type. The result is:</p><ul><li><code>1</code> if <code>e</code> is positive.</li><li><code>0</code> if <code>e</code> is zero.</li><li><code>-1</code> if <code>e</code> is negative.</li></ul><p>This function is applied component-wise when the input is a vector.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#sign-builtin"><code>sign</code></a></em></p><h4 id="use-case-27">Use Case</h4><p><code>sign</code> is useful for determining a direction without its magnitude. For example, it can be used to apply a force (like friction) that always opposes the direction of velocity.</p><pre><code class="language-wgsl">let velocity = vec2&lt;f32&gt;(3.5, -2.1);

// Get the direction of velocity. `sign` will return vec2&lt;f32&gt;(1.0, -1.0).
let direction = sign(velocity);

let friction_magnitude = 0.5;

// The friction force should oppose the velocity.
let friction_force = -direction * friction_magnitude;
// `friction_force` is now vec2&lt;f32&gt;(-0.5, 0.5), correctly opposing the movement.
</code></pre><h3 id="sin"><code>sin</code></h3><h4 id="signature-30">Signature</h4><p><code>sin(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input angle or vector of angles, in radians.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-30">Description</h4><p>Calculates the <a href="https://reference.wolfram.com/language/ref/Sin.html">sine</a> of <code>e</code>, where <code>e</code> is an angle specified in radians. The result is a smooth, continuous wave that oscillates between <code>-1.0</code> and <code>1.0</code>.</p><p><code>sin</code> is one of the most fundamental functions in graphics programming for creating any kind of periodic motion. <code>sin(0.0)</code> returns <code>0.0</code>, and the wave repeats every 2π radians.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#sin-builtin"><code>sin</code></a></em></p><h4 id="use-case-28">Use Case</h4><p><code>sin</code> is the primary tool for creating waves, oscillations, and cyclical animations.</p><pre><code class="language-wgsl">// Use a time uniform to drive an animation.
let time = material.time;

// Use Case 1: Simple wave for vertex displacement
// This creates a physical wave along the x-axis of a mesh.
let frequency = 5.0;
let amplitude = 0.1;
let wave_offset = sin(position.x * frequency + time) * amplitude;
let new_y_position = position.y + wave_offset;

// Use Case 2: Pulsating color
// `sin` returns a value in [-1, 1]. We can map this to the [0, 1] range
// to control brightness or a color channel.
let pulse = sin(time) * 0.5 + 0.5; // Maps [-1, 1] -&gt; [0, 1]
let pulsating_color = vec3&lt;f32&gt;(pulse, 0.0, 0.0); // Fades from black to red
</code></pre><h3 id="sinh"><code>sinh</code></h3><h4 id="signature-31">Signature</h4><p><code>sinh(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input hyperbolic angle in radians.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-31">Description</h4><p>Calculates the hyperbolic sine of <code>e</code>. This function is related to the exponential function and is mathematically defined as <code>(exp(e) - exp(-e)) / 2</code>.</p><p>Unlike the trigonometric <a href="#sin"><code>sin</code></a> function which oscillates, the <code>sinh</code> function grows exponentially. It passes through the origin (<code>sinh(0.0)</code> is <code>0.0</code>) and is an odd function, meaning <code>sinh(-e)</code> is equal to <code>-sinh(e)</code>. It is the inverse of the <a href="#asinh"><code>asinh</code></a> function.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#sinh-builtin"><code>sinh</code></a></em></p><h4 id="use-case-29">Use Case</h4><p><code>sinh</code> is a specialized mathematical function primarily used in advanced geometry or physics calculations. It is not commonly used in general visual effects programming.</p><pre><code class="language-wgsl">// The sinh function grows exponentially away from zero.
let val_zero = sinh(0.0); // Result is 0.0

let val_pos = sinh(2.0); // Result is approx 3.62
let val_neg = sinh(-2.0); // Result is approx -3.62

// It is the inverse of asinh.
let recovered_value = asinh(val_pos); // Result is approx 2.0
</code></pre><h3 id="sqrt"><code>sqrt</code></h3><h4 id="signature-32">Signature</h4><p><code>sqrt(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-32">Description</h4><p>Calculates the square root of <code>e</code>. This is the inverse of squaring a number (<code>x * x</code>).</p><p>The input e <strong>must be non-negative</strong> (<code>&gt;= 0</code>). Providing a negative input will result in implementation-defined behavior, which is often <code>NaN</code> (Not a Number).</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#sqrt-builtin"><code>sqrt</code></a></em></p><h4 id="use-case-30">Use Case</h4><p><code>sqrt</code> is fundamental for calculations based on the Pythagorean theorem, such as finding the length of a vector or the distance between two points. While WGSL provides the <a href="distance"><code>length()</code>(#length)] and [<code>distance()</code></a> functions for this, <code>sqrt</code> is the core mathematical operation they are built on.</p><pre><code class="language-wgsl">// Manually calculate the distance between two 2D points to demonstrate sqrt.
let point_a = vec2&lt;f32&gt;(2.0, 3.0);
let point_b = vec2&lt;f32&gt;(5.0, 7.0);

let delta = point_b - point_a; // delta is vec2&lt;f32&gt;(3.0, 4.0)

// The squared distance is dx*dx + dy*dy
let distance_sq = dot(delta, delta); // 3*3 + 4*4 = 9 + 16 = 25.0

// The actual distance is the square root of the squared distance.
let distance = sqrt(distance_sq); // sqrt(25.0) is 5.0

// This is mathematically equivalent to the built-in `distance()` function.
</code></pre><h3 id="tan"><code>tan</code></h3><h4 id="signature-33">Signature</h4><p><code>tan(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input angle or vector of angles, in radians.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-33">Description</h4><p>Calculates the <a href="https://reference.wolfram.com/language/ref/Tan.html">tangent</a> of <code>e</code>, where <code>e</code> is an angle specified in radians. Mathematically, <code>tan(e)</code> is equivalent to <a href="#sin"><code>sin(e)</code></a> / <a href="#cos"><code>cos(e)</code></a>.</p><p>The function’s output represents the slope of a line at a given angle. Unlike <a href="#sin"><code>sin</code></a> and <a href="#cos"><code>cos</code></a>, the output range of <code>tan</code> is unbounded (<code>-infinity</code> to <code>+infinity</code>). The function has vertical asymptotes (approaches infinity) at odd multiples of π/2 (90°, 270°, etc.), where <a href="#cos"><code>cos(e)</code></a> is zero. This makes it generally unsuitable for creating smooth, bounded animations.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#tan-builtin"><code>tan</code></a></em></p><h4 id="use-case-31">Use Case</h4><p>The primary role of <code>tan</code> in computer graphics is in geometric calculations, most notably in the creation of the perspective projection matrix, where it relates the camera’s field of view (FOV) to the dimensions of the viewing frustum.</p><pre><code class="language-wgsl">// A simplified example of the math inside a perspective projection matrix.
let fov_degrees = 90.0;
let fov_radians = radians(fov_degrees);

// The tangent of half the FOV is used to calculate a scaling factor
// that determines how much of the world is visible.
let scale_factor = 1.0 / tan(fov_radians * 0.5);

// This scale_factor would then be used to construct the matrix that
// transforms 3D world coordinates into 2D screen coordinates.
</code></pre><h3 id="tanh"><code>tanh</code></h3><h4 id="signature-34">Signature</h4><p><code>tanh(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input hyperbolic angle in radians.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-34">Description</h4><p>Calculates the hyperbolic tangent of e. Mathematically, it is equivalent to <a href="#sinh"><code>sinh(e)</code></a> / <a href="#cosh"><code>cosh(e)</code></a>.</p><p>The <code>tanh</code> function is a “squashing” function, meaning it takes any real number as input and maps it to a value within the range <code>(-1.0, 1.0)</code>. It produces an “S”-shaped curve (a sigmoid) that is nearly linear around <code>0</code> and flattens out as the input moves towards positive or negative infinity. It is the inverse of the <a href="#atanh"><code>atanh</code></a> function.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#tanh-builtin"><code>tanh</code></a></em></p><h4 id="use-case-32">Use Case</h4><p><code>tanh</code> is useful for creating smooth falloff curves or mapping an unbounded value to a predictable range.</p><pre><code class="language-wgsl">// Imagine you have a distance value that can be very large.
let dist_from_center: f32 = ...; // Could be 0.0, 5.0, 100.0, etc.

// A linear falloff might not look good. We can use `tanh` to create a
// smooth curve that rapidly transitions and then levels off.
let scale = 0.5;
let tanh_falloff = tanh(dist_from_center * scale);

// The `tanh_falloff` value will start at 0.0, rise quickly, and then
// smoothly approach 1.0 without ever exceeding it, no matter how large
// `dist_from_center` gets. This creates a pleasing, controlled transition.
let effect_strength = 1.0 - tanh_falloff;
</code></pre><h3 id="trunc"><code>trunc</code></h3><h4 id="signature-35">Signature</h4><p><code>trunc(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-35">Description</h4><p>Calculates the integer part of <code>e</code> by discarding its fractional component. This is commonly described as <strong>rounding towards zero</strong>. The result is returned as a floating-point value.</p><ul><li><code>trunc(3.7)</code> returns <code>3.0</code></li><li><code>trunc(-3.7)</code> returns <code>-3.0</code></li></ul><p>Note that for negative numbers, this behavior is different from the <a href="#floor"><code>floor()</code></a> function, which would round <code>-3.7</code> down to <code>-4.0</code>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#trunc-builtin"><code>trunc</code></a></em></p><h2 id="vector-functions">Vector Functions</h2><p>While the common mathematical functions can be applied component-wise to vectors, this family of functions performs holistic <strong>geometric operations</strong>. They treat vectors not just as a collection of numbers, but as representations of positions, directions, and surfaces in 2D or 3D space.</p><p>These are the indispensable power tools for solving the fundamental questions of computer graphics. They allow you to calculate the distance between points, extract a pure direction from a vector, measure the alignment and angle between directions, find vectors that are perpendicular to a surface, and even simulate the physics of light as it bounces off or bends through materials.</p><p>Mastering these functions is the key to implementing almost any lighting model, geometric effect, or physics-based interaction in a shader. They are the language of 3D space.</p><h3 id="cross"><code>cross</code></h3><h4 id="signature-36">Signature</h4><p><code>cross(e1: vec3&lt;T&gt;, e2: vec3&lt;T&gt;) -&gt; vec3&lt;T&gt;</code></p><ul><li><code>e1</code>, <code>e2</code>: The two input vectors.</li><li><code>T</code>: Can be <code>f32</code>, or <code>f16</code>.</li></ul><h4 id="description-36">Description</h4><p>Calculates the cross product of two 3-component vectors, <code>e1</code> and <code>e2</code>.</p><p>The result is a new <code>vec3</code> vector that is perpendicular (orthogonal) to both of the input vectors. The direction of the resulting vector is determined by the “right-hand rule”: if you curl the fingers of your right hand in the direction from <code>e1</code> to <code>e2</code>, your thumb will point in the direction of the result.</p><p>This function is defined <strong>only for <code>vec3</code></strong>. It cannot be used with vectors of other dimensions.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#cross-builtin"><code>cross</code></a></em></p><h3 id="distance"><code>distance</code></h3><h4 id="signature-37">Signature</h4><p><code>distance(e1: T, e2: T) -&gt; S</code></p><ul><li><code>e1</code>, <code>e2</code>: The two input points.</li><li><code>T</code>: The type of the input points. Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li><li><code>S</code>: The scalar component type of <code>T</code> (<code>f32</code> if <code>T</code> is <code>vecN&lt;f32&gt;</code>, <code>f16</code> if <code>T</code> is <code>vecN&lt;f16&gt;</code>, etc.).</li></ul><h4 id="description-37">Description</h4><p>Calculates the Euclidean distance (the straight-line distance) between two points, <code>e1</code> and <code>e2</code>. This is mathematically equivalent to <a href="#length"><code>length(e1 - e2)</code></a>.</p><p>The function always returns a single scalar floating-point value, even when the inputs are vectors.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#distance-builtin">distance</a></em></p><h4 id="use-case-33">Use Case</h4><p><code>distance</code> is one of the most common functions in shader programming, used for any calculation involving proximity, such as range checks, radial gradients, or circular masks.</p><pre><code class="language-wgsl">// Use Case 1: AI Attack Range
let player_pos = vec3&lt;f32&gt;(10.0, 0.0, 5.0);
let enemy_pos = vec3&lt;f32&gt;(12.0, 0.0, 6.0);
let attack_range = 3.0;

if distance(player_pos, enemy_pos) &lt; attack_range {
    // The player is in range, so the enemy can attack.
}

// Use Case 2: Circular Mask
// `uv` is a 2D coordinate from 0.0 to 1.0.
let center = vec2&lt;f32&gt;(0.5);
let radius = 0.4;
let dist_from_center = distance(uv, center);

// Create a hard-edged circle.
let circle = step(dist_from_center, radius);
</code></pre><h3 id="dot"><code>dot</code></h3><h4 id="signature-38">Signature</h4><p><code>dot(e1: vecN&lt;T&gt;, e2: vecN&lt;T&gt;) -&gt; T</code></p><ul><li><code>e1</code>, <code>e2</code>: The two input vectors of the same type and dimension.</li><li><code>T</code>: The component type of the vectors. Can be <code>f32</code>, <code>f16</code>, <code>i32</code>, or <code>u32</code>.</li><li>The return value is a single scalar of type <code>T</code>.</li></ul><h4 id="description-38">Description</h4><p>Calculates the dot product of <code>e1</code> and <code>e2</code>. This is done by multiplying the corresponding components of the two vectors and then summing the results. For example, for two <code>vec3</code> vectors <code>a</code> and <code>b</code>, the dot product is <code>(a.x * b.x) + (a.y * b.y) + (a.z * b.z)</code>.</p><p>The geometric meaning of the dot product is what makes it one of the most powerful tools in shader programming. For two <strong>unit-length (normalized) floating-point vectors</strong>, the result is the <strong>cosine of the angle</strong> between them. This tells you how much the two vectors are aligned:</p><ul><li><strong><code>1.0</code></strong>: The vectors point in the exact same direction.</li><li><strong><code>0.0</code></strong>: The vectors are perfectly perpendicular (90 degrees apart).</li><li><strong><code>-1.0</code></strong>: The vectors point in exact opposite directions.</li></ul><p>It can be thought of as a projection: <code>dot(A, B)</code> measures how much of vector <code>A</code> points along the direction of vector <code>B</code>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#dot-builtin"><code>dot</code></a></em></p><h3 id="faceforward"><code>faceForward</code></h3><h4 id="signature-39">Signature</h4><p><code>faceForward(e1: T, e2: T, e3: T) -&gt; T</code></p><ul><li><code>e1</code>: The vector to orient.</li><li><code>e2</code>: The incident vector.</li><li><code>e3</code>: The reference vector.</li><li><code>T</code>: Can be <code>vecN&lt;f32&gt;</code>, or <code>vecN&lt;f16&gt;</code>, where <code>N</code> is <code>2</code>, <code>3</code>, or <code>4</code>.</li></ul><h4 id="description-39">Description</h4><p>Orients a vector to point in the same general direction as another. Specifically, it returns <code>e1</code> if <a href="#dot"><code>dot(e2, e3)</code></a> is negative, and <code>-e1</code> otherwise.</p><p>This function’s purpose is to ensure a normal vector is always pointing “towards” a direction of interest (like a camera), which is essential for effects like two-sided lighting. The parameters are typically used as follows:</p><ul><li><code>e1</code>: The normal vector you want to orient, <code>N</code>.</li><li><code>e2</code>: A reference normal, <code>N_ref</code>, used to determine the surface’s orientation. Usually, this is the same vector as <code>N</code>.</li><li><code>e3</code>: The incident vector, <code>I</code>, which is a direction pointing towards the surface (e.g., the negated view direction).</li></ul><p>The logic is: if the surface (<code>N_ref</code>) is facing the incident direction (<code>I</code>), return the normal (<code>N</code>) as is. Otherwise, return the flipped normal (<code>-N</code>).</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#faceForward-builtin">f<code>aceForward</code></a></em></p><h4 id="use-case-34">Use Case</h4><p>The canonical use case is creating two-sided materials where both the front and back faces of a polygon are lit correctly.</p><pre><code class="language-wgsl">// The geometric normal from the mesh.
let geometric_normal = normalize(in.normal);

// The direction from the surface point TO the camera.
let view_dir = normalize(camera.world_position - in.world_position);

// The incident vector must point TOWARDS the surface, so we negate the view direction.
let incident_dir = -view_dir;

// `faceForward` ensures the normal used for lighting always points toward the camera,
// even if we are viewing the back-face of a polygon.
// We use `geometric_normal` for all three arguments in this common pattern.
let final_normal = faceForward(geometric_normal, incident_dir, geometric_normal);

// Now, `final_normal` can be used for lighting, and it will be correct
// regardless of which side of the polygon is visible.
let light_dir = ...;
let brightness = max(0.0, dot(final_normal, light_dir));
</code></pre><h3 id="length"><code>length</code></h3><h4 id="signature-40">Signature</h4><p><code>length(e: T) -&gt; S</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: The type of the input. Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li><li><code>S</code>: The scalar component type of <code>T</code> (<code>f32</code> if <code>T</code> is <code>vecN&lt;f32&gt;</code>, etc.).</li></ul><h4 id="description-40">Description</h4><p>Calculates the length (also known as the magnitude or norm) of the input <code>e</code>. The behavior depends on whether the input is a scalar or a vector:</p><ul><li><strong>For a scalar <code>e</code>:</strong> The result is the absolute value of <code>e</code>.</li><li><strong>For a vector <code>e</code>:</strong> The result is the Euclidean length, calculated as <code>sqrt(dot(e, e))</code>. For a <code>vec3</code>, this is sqr<code>t(e.x*e.x + e.y*e.y + e.z*e.z)</code>.</li></ul><p><strong>Precision Note:</strong> The specification allows the scalar case to be implemented as <code>sqrt(e * e)</code>. While mathematically equivalent to <code>abs(e)</code>, this implementation detail can matter in extreme cases. If <code>e</code> is a very large number, the intermediate <code>e * e</code> calculation could <strong>overflow</strong> to infinity before the square root is taken, resulting in an incorrect value. For standard graphics work, this is rarely a concern, but it’s a known limitation of this possible implementation.</p><p>The function always returns a single, non-negative scalar floating-point value.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#length-builtin"><code>length</code></a></em></p><h4 id="use-case-35">Use Case</h4><p><code>length</code> is fundamental for any operation that depends on the magnitude of a vector, such as measuring the distance of a point from the origin or calculating the speed from a velocity vector.</p><pre><code class="language-wgsl">// Use Case 1: Distance from Origin
let point_in_space = vec3&lt;f32&gt;(3.0, 4.0, 0.0);

// `length` calculates the straight-line distance from (0,0,0) to the point.
let dist_from_origin = length(point_in_space); // Result is 5.0

// Use Case 2: Calculating Speed
let velocity_vector = vec3&lt;f32&gt;(-10.0, 20.0, 0.0);

// The length of the velocity vector is the object&#39;s speed.
let speed = length(velocity_vector); // Result is approx 22.36

// The built-in `distance(a, b)` function is a convenient shorthand
// for `length(a - b)`.
</code></pre><h3 id="normalize"><code>normalize</code></h3><h4 id="signature-41">Signature</h4><p><code>normalize(e: vecN&lt;T&gt;) -&gt; vecN&lt;T&gt;</code></p><ul><li><code>e</code>: The input vector.</li><li><code>T</code>: Can be <code>f32</code>, or <code>f16</code>.</li><li><code>N</code>: The dimension of the vector, can be <code>2</code>, <code>3</code>, or <code>4</code>.</li></ul><h4 id="description-41">Description</h4><p>Calculates and returns a <strong>unit vector</strong> that points in the same direction as the input vector <code>e</code>. A unit vector is a vector with a length of exactly <code>1.0</code>.</p><p>The operation is mathematically equivalent to <code>e / length(e)</code>. This function is essential for any calculation that relies on pure direction rather than magnitude.</p><p>If the input vector <code>e</code> is the zero vector (i.e., its length is <code>0.0</code>), the result is a zero vector of the same type. This avoids a division-by-zero error and provides a safe, predictable outcome.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#normalize-builtin"><code>normalize</code></a></em></p><h4 id="use-case-36">Use Case</h4><p>Normalization is one of the most frequent operations in shader programming, especially for lighting calculations where directions must be represented by unit vectors.</p><pre><code class="language-wgsl">// Use Case 1: Calculating a Direction Vector
let start_pos = vec3&lt;f32&gt;(1.0, 1.0, 1.0);
let end_pos = vec3&lt;f32&gt;(4.0, 5.0, 1.0);

// The vector from start to end has a magnitude (length).
let vector = end_pos - start_pos; // vec3&lt;f32&gt;(3.0, 4.0, 0.0), length is 5.0

// To get only the pure direction, we normalize it.
let direction = normalize(vector); // vec3&lt;f32&gt;(0.6, 0.8, 0.0), length is 1.0

// Use Case 2: Preparing Vectors for Lighting
// Surface normals passed from the vertex shader get interpolated, which changes
// their length. They MUST be re-normalized in the fragment shader.
let surface_normal = normalize(in.interpolated_normal);

let light_dir = normalize(light.position - in.world_position);

// Now the dot product will correctly give the cosine of the angle.
let brightness = dot(surface_normal, light_dir);
</code></pre><h3 id="reflect"><code>reflect</code></h3><h4 id="signature-42">Signature</h4><p><code>reflect(e1: T, e2: T) -&gt; T</code></p><ul><li><code>e1</code>: The incident vector, <code>I</code>.</li><li><code>e2</code>: The surface normal vector, <code>N</code>.</li><li><code>T</code>: Can be <code>vecN&lt;f32&gt;</code>, or <code>vecN&lt;f16&gt;</code>, where <code>N</code> is <code>2</code>, <code>3</code>, or <code>4</code>.</li></ul><h4 id="description-42">Description</h4><p>Calculates the direction of a perfect, mirror-like reflection. It takes an incident vector <code>e1</code> (representing the incoming ray) and a surface normal <code>e2</code>, and returns the reflected direction vector.</p><p>For this function to work correctly, two conditions are critical:</p><ol><li>The surface normal <code>e2</code> <strong>must be a unit vector</strong> (normalized).</li><li>The incident vector <code>e1</code> <strong>must point towards the surface</strong>.</li></ol><p>This second point is the most common source of errors. In shader programming, the view direction vector typically points from the surface to the camera. The reflect function expects the opposite. Therefore, you <strong>must negate your view direction vector</strong> before passing it to this function.</p><pre><code class="language-plaintext">      I \  |N / R
         \ | /
          \|/
   ════════════════════ (Surface)
</code></pre><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#reflect-builtin"><code>reflect</code></a></em></p><h4 id="use-case-37">Use Case</h4><p>The primary use of <code>reflect</code> is to implement environment mapping, where the reflection vector is used to sample a <a href="https://en.wikipedia.org/wiki/Cube_mapping">cubemap</a> (skybox) to simulate reflections on a surface.</p><pre><code class="language-wgsl">// The surface normal, which must be normalized.
let surface_normal = normalize(in.normal);

// The direction pointing FROM the surface point TO the camera.
let view_dir = normalize(camera.position - in.world_position);

// The incident vector for `reflect` must point TOWARDS the surface,
// so we negate the view direction.
let incident_dir = -view_dir;

// Calculate the reflection direction.
let reflect_dir = reflect(incident_dir, surface_normal);

// `reflect_dir` can now be used to sample a skybox texture.
let reflection_color = textureSample(skybox_texture, skybox_sampler, reflect_dir);
</code></pre><h3 id="refract"><code>refract</code></h3><h4 id="signature-43">Signature</h4><p><code>refract(e1: vecN&lt;T&gt;, e2: vecN&lt;T&gt;, e3: T) -&gt; vecN&lt;T&gt;</code></p><ul><li><code>e1</code>: The incident vector, <code>I</code>.</li><li><code>e2</code>: The surface normal vector, <code>N</code>.</li><li><code>e3</code>: The ratio of indices of refraction, <code>eta</code>.</li><li><code>T</code>: Can be <code>f32</code>, or <code>f16</code>. <code>N</code> can be <code>2</code>, <code>3</code>, or <code>4</code>.</li></ul><h4 id="description-43">Description</h4><p>Calculates the direction of a refracted ray of light as it passes through a surface from one medium to another (e.g., from air into water).</p><p>For this function to work correctly, several conditions are critical:</p><ol><li>The incident vector <code>e1</code> <strong>must point towards the surface</strong>. As with reflect, this usually requires negating your view direction vector.</li><li>The surface normal <code>e2</code> <strong>must be a unit vector</strong> (normalized).</li><li>The ratio <code>e3</code> (<code>eta</code>) must be calculated as (Index of Refraction of the starting medium) / (Index of Refraction of the destination medium).<ul><li>Air to Glass (<code>IOR ≈ 1.5</code>): <code>eta = 1.0 / 1.5</code></li><li>Glass to Air: <code>eta = 1.5 / 1.0</code></li></ul></li></ol><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#refract-builtin"><code>refract</code></a></em></p><h5 id="total-internal-reflection-tir">Total Internal Reflection (TIR)</h5><p>Under certain conditions (when light travels from a denser to a less dense medium at a shallow angle), refraction is impossible, and all light reflects. This is known as Total Internal Reflection. The <code>refract</code> function signals this by returning a <strong>zero vector</strong> (<code>vecN(0.0)</code>). Your shader code should check for this case and typically perform a <code>reflect</code> operation instead.</p><h4 id="use-case-38">Use Case</h4><p>The primary use of <code>refract</code> is to render transparent materials like glass and water, where it provides the distorted view of the scene behind the object.</p><pre><code class="language-wgsl">// The surface normal, which must be normalized.
let surface_normal = normalize(in.normal);

// The direction pointing FROM the surface point TO the camera.
let view_dir = normalize(camera.position - in.world_position);

// The incident vector for `refract` must point TOWARDS the surface.
let incident_dir = -view_dir;

// The ratio of IORs for a ray traveling from air (1.0) into glass (1.5).
let eta = 1.0 / 1.5;

// Calculate the refraction direction.
let refract_dir = refract(incident_dir, surface_normal, eta);

// Check for Total Internal Reflection.
if (all(refract_dir == vec3&lt;f32&gt;(0.0))) {
    // Perform reflection instead.
    let reflect_dir = reflect(incident_dir, surface_normal);
    // ... sample environment with reflect_dir ...
} else {
    // Use the refraction vector to sample the background/environment map.
    let refraction_color = textureSample(background_texture, sampler, refract_dir);
}
</code></pre><h2 id="matrix-functions">Matrix Functions</h2><p>In computer graphics, matrices are the fundamental tool for performing transformations in 2D and 3D space, such as translation, rotation, and scaling. While most of the time you will be using matrices to transform vectors, this small family of functions allows you to analyze and manipulate the matrices themselves.</p><p>These functions provide insight into the properties of a transformation. They allow you to calculate a matrix’s determinant to understand if it flips or collapses space, or to compute its transpose, which is a critical step in correctly transforming normal vectors for lighting calculations. While not used as frequently as vector or mathematical functions, they are essential for solving specific, advanced problems in geometric and lighting computations.</p><h3 id="determinant"><code>determinant</code></h3><h4 id="signature-44">Signature</h4><p><code>determinant(e: matCxC&lt;T&gt;) -&gt; T</code></p><ul><li><code>e</code>: The input square matrix.</li><li><code>C</code>: The dimension of the matrix, can be <code>2</code>, <code>3</code>, or <code>4</code>.</li><li><code>T</code>: Can be <code>f32</code>, or <code>f16</code>.</li><li>The return value is a single scalar of type <code>T</code>.</li></ul><h4 id="description-44">Description</h4><p>Calculates the determinant of a square matrix <code>e</code>. The determinant is a single scalar value that reveals important properties about the linear transformation the matrix represents.</p><ul><li>If the determinant is <strong>zero</strong>, the matrix is “singular.” This means the transformation collapses space into a lower dimension (e.g., a 3D volume becomes a 2D plane), and the matrix cannot be inverted.</li><li>The <strong>sign</strong> of the determinant indicates if the transformation flips orientation. A negative determinant means the object has been mirrored or turned “inside-out” (e.g., by a negative scale on an odd number of axes).</li><li>The <strong>absolute value</strong> of the determinant represents the factor by which the transformation scales volume (for <code>mat3x3</code>, <code>mat4x4</code>) or area (for <code>mat2x2</code>).</li></ul><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#determinant-builtin"><code>determinant</code></a></em></p><h4 id="use-case-39">Use Case</h4><p>The determinant is useful for checking if a matrix is invertible or for detecting mirrored transformations, which is important for correct lighting and culling.</p><pre><code class="language-wgsl">let model_matrix: mat3x3&lt;f32&gt; = ...; // The upper 3x3 of a model matrix

let det = determinant(model_matrix);

// Check if the model has been mirrored (e.g., scale.x = -1.0).
if (det &lt; 0.0) {
    // This object&#39;s coordinate system has been flipped.
    // This is important information for lighting calculations, as it may
    // require flipping the bitangent vector to ensure normal maps
    // are applied correctly.
    // It also flips the winding order of triangles, which affects culling.
}

// It can also be used to guard an `inverse()` call, though this is rare
// as `inverse()` will produce a valid (if not useful) matrix even for
// singular inputs on most hardware.
if (det != 0.0) {
    // The matrix is invertible.
}
</code></pre><h3 id="transpose"><code>transpose</code></h3><h4 id="signature-45">Signature</h4><p><code>transpose(e: matRxC&lt;T&gt;) -&gt; matCxR&lt;T&gt;</code></p><ul><li><code>e</code>: The input matrix.</li><li><code>R</code>, <code>C</code>: The number of rows and columns (<code>2</code>, <code>3</code>, or <code>4</code>).</li><li><code>T</code>: Can be <code>f32</code>, or <code>f16</code>.</li><li>The return type is a matrix with the row and column counts swapped.</li></ul><h4 id="description-45">Description</h4><p>Calculates the transpose of the input matrix <code>e</code>. This operation flips the matrix over its main diagonal, effectively turning the original matrix’s rows into the new matrix’s columns, and vice versa.</p><p>For example, a <code>mat2x3</code> (2 rows, 3 columns) becomes a <code>mat3x2</code> (3 rows, 2 columns):</p><pre><code class="language-plaintext">[ a, b, c ]      becomes      [ a, d ]
[ d, e, f ]                   [ b, e ]
                              [ c, f ]
</code></pre><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#transpose-builtin"><code>transpose</code></a></em></p><h4 id="use-case-40">Use Case</h4><p>The most important use case for transpose in shader programming is in the calculation of the <strong>normal matrix</strong>.</p><p>When a mesh has a non-uniform scale (e.g., scaled by <code>(2.0, 1.0, 1.0)</code>), simply transforming its normal vectors by the model matrix will incorrectly skew them. The correct way to transform normals is to use the transpose of the inverse of the model matrix.</p><pre><code class="language-wgsl">let model_matrix: mat4x4&lt;f32&gt; = ...;

// For normals, we only care about the rotation and scale part (the upper 3x3).
let upper3x3 = mat3x3&lt;f32&gt;(
    model_matrix.x.xyz,
    model_matrix.y.xyz,
    model_matrix.z.xyz
);

// The normal matrix is the transpose of the inverse of the model&#39;s upper 3x3.
let normal_matrix = transpose(inverse(upper3x3));

let mesh_normal: vec3&lt;f32&gt; = ...;

// Now, transforming the normal with this matrix yields the correct result.
let world_normal = normalize(normal_matrix * mesh_normal);

// Note: For matrices that only contain rotation and uniform scale (orthogonal matrices),
// the transpose is equal to the inverse. In these cases, using `transpose()` is
// a significant performance optimization over the much slower `inverse()` function.
</code></pre><h2 id="interpolation--clamping-functions">Interpolation &amp; Clamping Functions</h2><p>This family of functions provides the essential tools for controlling numerical values and creating transitions between them. They are fundamental to almost every visual effect, from basic lighting to complex procedural patterns. The functions in this group can be divided into two main categories:</p><ol><li><strong>Clamping Functions:</strong> These functions (<code>clamp</code>, <code>min</code>, <code>max</code>, <code>saturate</code>) are used for constraining values. They ensure that the results of your calculations remain within a valid and predictable range. This is crucial for preventing visual artifacts, such as colors becoming negative or overly bright, or for providing safe inputs to other mathematical functions that have a limited domain (like <code>acos</code>).</li><li><strong>Interpolation Functions:</strong> These are the artistic tools for creating blends, fades, and gradients. They define how a value transitions from one state to another. This includes the linear blend of <code>mix</code>, the hard, binary switch of <code>step</code>, and the versatile, eased-in “S-curve” of <code>smoothstep</code>, which is a cornerstone for creating polished, natural-looking effects.</li></ol><p>Many of these functions are also “branchless,” offering a more performant way to achieve conditional logic than a traditional <code>if</code> statement. Mastering this group is essential for creating high-quality, robust, and visually pleasing shaders.</p><h3 id="clamp"><code>clamp</code></h3><h4 id="signature-46">Signature</h4><p><code>clamp(e: T, low: T, high: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector to be clamped.</li><li><code>low</code>: The lower bound of the range.</li><li><code>high</code>: The upper bound of the range.</li><li><code>T</code>: Can be f32, f16, i32, u32, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-46">Description</h4><p>Restricts a value <code>e</code> to be within the inclusive range <code>[low, high]</code>.</p><ul><li>If <code>e</code> is less than <code>low</code>, the result is <code>low</code>.</li><li>If <code>e</code> is greater than <code>high</code>, the result is <code>high</code>.</li><li>Otherwise, the result is <code>e</code>.</li></ul><p>The function is applied component-wise when the inputs are vectors. The specification notes that for floating-point types, this may be implemented as <code>min(max(e, low), high)</code> or as the median of the three values, which provides a numerically stable way to clamp a value.</p><p>It is an error if <code>low</code> is greater than <code>high</code>. This will be caught at shader compilation time if the values are compile-time constants.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#clamp"><code>clamp</code></a></em></p><h4 id="use-case-41">Use Case</h4><p><code>clamp</code> is an essential utility for ensuring values remain within a valid or expected range. It is frequently used as a “safety” function.</p><pre><code class="language-wgsl">// Use Case 1: Keeping color values in the valid [0, 1] range.
var bright_color = vec3&lt;f32&gt;(1.2, -0.1, 0.8);
// Writing this color to the screen could cause visual artifacts.
let safe_color = clamp(bright_color, vec3&lt;f32&gt;(0.0), vec3&lt;f32&gt;(1.0));
// `safe_color` is now vec3&lt;f32&gt;(1.0, 0.0, 0.8)

// Use Case 2: Ensuring valid input for other functions.
// The `acos` function requires an input between -1.0 and 1.0.
// A dot product can sometimes have tiny floating-point errors that push it
// slightly outside this range (e.g., 1.000001 or -1.000001).
let dot_product = dot(vec_a, vec_b);
let clamped_dot = clamp(dot_product, -1.0, 1.0);

// Now it&#39;s safe to pass this value to `acos`.
let angle = acos(clamped_dot);
</code></pre><h3 id="max"><code>max</code></h3><h4 id="signature-47">Signature</h4><p><code>max(e1: T, e2: T) -&gt; T</code></p><ul><li><code>e1</code>, <code>e2</code>: The two input values or vectors to be compared.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, <code>i32</code>, <code>u32</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-47">Description</h4><p>Compares <code>e1</code> and <code>e2</code> and returns the larger of the two.</p><p>The function is applied component-wise when the inputs are vectors. This means for <code>max(vec_a, vec_b)</code>, the resulting vector’s x-component will be <code>max(vec_a.x, vec_b.x)</code>, its y-component will be <code>max(vec_a.y, vec_b.y)</code>, and so on.</p><p><strong>Floating-Point Edge Cases:</strong></p><ul><li>If one operand is <code>NaN</code> (Not a Number), the other operand is returned.</li><li>If both operands are <code>NaN</code>, a <code>NaN</code> is returned.</li><li>If both operands are “denormalized” (very small numbers near zero that have lost precision), the result may be either of the two input values.</li></ul><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#max-float-builtin"><code>max</code></a></em></p><h4 id="use-case-42">Use Case</h4><p><code>max</code> is a fundamental building block for many shader effects. Its most common use is to establish a “floor” or minimum value for a calculation, preventing it from going below a certain threshold.</p><pre><code class="language-wgsl">// Use Case 1: Diffuse Lighting &quot;NdotL&quot;
// The dot product of a normal and a light direction can be negative,
// which would incorrectly subtract light.
let dot_product = dot(surface_normal, light_dir);

// `max` is used to clamp the result at zero, ensuring that surfaces
// facing away from the light contribute zero brightness, not negative.
let diffuse_brightness = max(0.0, dot_product);

// Use Case 2: Component-wise comparison
let a = vec3&lt;f32&gt;(1.0, 5.0, 3.0);
let b = vec3&lt;f32&gt;(4.0, 2.0, 6.0);

// `max` will be applied to each pair of components.
// max(1.0, 4.0) -&gt; 4.0
// max(5.0, 2.0) -&gt; 5.0
// max(3.0, 6.0) -&gt; 6.0
let result = max(a, b); // Result is vec3&lt;f32&gt;(4.0, 5.0, 6.0)
</code></pre><h3 id="min"><code>min</code></h3><h4 id="signature-48">Signature</h4><p><code>min(e1: T, e2: T) -&gt; T</code></p><ul><li><code>e1</code>, <code>e2</code>: The two input values or vectors to be compared.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, <code>i32</code>, <code>u32</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-48">Description</h4><p>Compares <code>e1</code> and <code>e2</code> and returns the smaller of the two.</p><p>The function is applied component-wise when the inputs are vectors. This means for <code>min(vec_a, vec_b)</code>, the resulting vector’s x-component will be <code>min(vec_a.x, vec_b.x)</code>, its y-component will be <code>min(vec_a.y, vec_b.y)</code>, and so on.</p><p><strong>Floating-Point Edge Cases:</strong></p><ul><li>If one operand is <code>NaN</code> (Not a Number), the other operand is returned.</li><li>If both operands are <code>NaN</code>, a <code>NaN</code> is returned.</li><li>If both operands are “denormalized” (very small numbers near zero that have lost precision), the result may be either of the two input values.</li></ul><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#min-float-builtin"><code>min</code></a></em></p><h4 id="use-case-43">Use Case</h4><p><code>min</code> is a fundamental building block, often used to establish a “ceiling” or maximum value for a calculation, preventing it from exceeding a certain threshold. It is also used in creating Signed Distance Functions (SDFs).</p><pre><code class="language-wgsl">// Use Case 1: Limiting an Effect
// An effect strength that should not exceed 1.0.
var effect_strength = calculate_effect(); // Might be &gt; 1.0

// `min` is used to cap the value at 1.0.
let limited_strength = min(1.0, effect_strength);

// Use Case 2: Smoothly combining Signed Distance Functions (SDFs)
// `dist_a` and `dist_b` are the signed distances to two different shapes.
let dist_a = distance_to_circle(uv);
let dist_b = distance_to_square(uv);

// The minimum of the two distances gives the union of the two shapes.
let union_dist = min(dist_a, dist_b);
</code></pre><h3 id="mix"><code>mix</code></h3><p>Performs a linear interpolation (or “blend”) between two values. This is one of the most fundamental operations in computer graphics, often referred to as “lerp”.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#mix-builtin"><code>mix</code></a></em></p><h4 id="overload-uniform-blending">Overload: Uniform Blending</h4><p>This overload blends two values or vectors using a corresponding blend factor or vector of blend factors.</p><h5 id="signature-49">Signature</h5><p><code>mix(e1: T, e2: T, e3: T) -&gt; T</code></p><ul><li><code>e1</code>: The starting value or vector (when <code>e3</code> is <code>0</code>).</li><li><code>e2</code>: The ending value or vector (when <code>e3</code> is <code>1</code>).</li><li><code>e3</code>: The blend factor or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h5 id="description-49">Description</h5><p>Calculates the linear blend of <code>e1</code> and <code>e2</code> using the blend factor <code>e3</code>. The calculation is <code>e1 * (1.0 - e3) + e2 * e3</code>. The blend factor <code>e3</code> is typically in the range <code>[0.0, 1.0]</code>.</p><ul><li>If <code>e3</code> is <code>0.0</code>, the result is <code>e1</code>.</li><li>If <code>e3</code> is <code>1.0</code>, the result is <code>e2</code>.</li><li>If <code>e3</code> is <code>0.5</code>, the result is a perfect 50/50 mix.</li></ul><p>When the inputs are vectors, the operation can be performed component-wise if <code>e3</code> is also a vector. For example, you can blend the red, green, and blue channels of a color by different amounts simultaneously.</p><h4 id="overload-scalar-blending-factor">Overload: Scalar Blending Factor</h4><p>This overload is a convenient alternative that blends two vectors using a single, uniform scalar blend factor.</p><h5 id="signature-50">Signature</h5><p><code>mix(e1: T, e2: T, e3: S) -&gt; T</code></p><ul><li><code>e1</code>, <code>e2</code>: The start and end vectors to blend between.</li><li><code>e3</code>: The single, scalar blend factor.</li><li><code>T</code>: The vector type, <code>vecN&lt;S&gt;</code>.</li><li><code>S</code>: The scalar component type, <code>f32</code>, or <code>f16</code>.</li></ul><h5 id="description-50">Description</h5><p>Performs a component-wise linear blend of the vectors <code>e1</code> and <code>e2</code>, using the single scalar <code>e3</code> as the blending factor for every component. This is the most common way to perform a uniform blend between two vectors (like colors or positions).</p><h4 id="use-case-44">Use Case</h4><pre><code class="language-wgsl">let red = vec3&lt;f32&gt;(1.0, 0.0, 0.0);
let blue = vec3&lt;f32&gt;(0.0, 0.0, 1.0);

// Use Case 1: Simple blend with a scalar factor
let purple = mix(red, blue, 0.5); // Result is vec3&lt;f32&gt;(0.5, 0.0, 0.5)

// Use Case 2: Component-wise blend with a vector factor
// Blend red by 10%, green by 50%, and blue by 90%.
let blend_factors = vec3&lt;f32&gt;(0.1, 0.5, 0.9);
let custom_blend = mix(red, blue, blend_factors);
// result is red*(1-factors) + blue*factors
// (1,0,0)*(0.9,0.5,0.1) + (0,0,1)*(0.1,0.5,0.9)
// (0.9,0,0) + (0,0,0.9) -&gt; (0.9, 0.0, 0.9)
</code></pre><pre><code class="language-wgsl">let start_pos = vec3&lt;f32&gt;(0.0, 0.0, 0.0);
let end_pos = vec3&lt;f32&gt;(10.0, 20.0, 0.0);
let animation_progress = 0.25; // 25% of the way through the animation

// Interpolate the position using a single scalar factor.
let current_pos = mix(start_pos, end_pos, animation_progress);
// Result is vec3&lt;f32&gt;(2.5, 5.0, 0.0)
</code></pre><h3 id="saturate"><code>saturate</code></h3><h4 id="signature-51">Signature</h4><p><code>saturate(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-51">Description</h4><p>A convenient shorthand function that is exactly equivalent to <a href="#clamp"><code>clamp(e, 0.0, 1.0)</code></a>. It restricts the input value e to be within the inclusive range <code>[0.0, 1.0]</code>.</p><p>This is a very common operation in graphics, particularly for colors or blending factors, which often need to be constrained to this specific range. Using saturate can make shader code more concise and readable than writing out the full clamp.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#saturate-float-builtin"><code>saturate</code></a></em></p><h4 id="use-case-45">Use Case</h4><p>saturate is the ideal function for ensuring that any value intended to be a standard color component or a percentage (like a lighting term or alpha value) is in the valid <code>[0.0, 1.0]</code> range.</p><pre><code class="language-wgsl">// A lighting calculation that might produce values outside the [0, 1] range
// due to high-intensity lights or unusual material properties.
let dot_product = dot(surface_normal, light_dir);
let brightness = dot_product * light_intensity; // Could be 1.5, -0.2, etc.

// `saturate` cleanly clamps the result to a valid brightness range.
let final_brightness = saturate(brightness);

// The following two lines are identical in function:
let clamped_brightness = clamp(brightness, 0.0, 1.0);
let saturated_brightness = saturate(brightness);
</code></pre><h3 id="smoothstep"><code>smoothstep</code></h3><p>Performs a smooth, <a href="https://en.wikipedia.org/wiki/Hermite_interpolation">Hermite interpolation</a> between 0.0 and 1.0. It is a cornerstone of shader effects for creating natural-looking transitions, fades, and soft edges. The resulting curve has an “ease-in” and “ease-out” profile.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#smoothstep-builtin"><code>smoothstep</code></a></em></p><h4 id="overload-scalar-inputs">Overload: Scalar Inputs</h4><p>This is the most common overload, used to smoothly transition a single value.</p><h5 id="signature-52">Signature</h5><p><code>smoothstep(low: S, high: S, x: S) -&gt; S</code></p><ul><li><code>low</code>: The lower bound of the transition range.</li><li><code>high</code>: The upper bound of the transition range.</li><li><code>x</code>: The input value to be mapped.</li><li><code>S</code>: Can be <code>f32</code> or <code>f16</code>.</li></ul><h5 id="description-52">Description</h5><p>Calculates a smooth transition from 0.0 to 1.0 as the input <code>x</code> moves from <code>low</code> to <code>high</code>.</p><ul><li>If <code>x</code> is less than or equal to <code>low</code>, the result is <code>0.0</code>.</li><li>If <code>x</code> is greater than or equal to <code>high</code>, the result is <code>1.0</code>.</li><li>If <code>x</code> is between <code>low</code> and <code>high</code>, the result is a smoothly interpolated value between <code>0.0</code> and <code>1.0</code>, calculated using the formula <code>t * t * (3.0 - 2.0 * t)</code>, where <code>t</code> is the normalized position of <code>x</code> within the range.</li></ul><h4 id="overload-vector-inputs">Overload: Vector Inputs</h4><p>This overload applies the smoothstep function component-wise.</p><h5 id="signature-53">Signature</h5><p><code>smoothstep(low: T, high: T, x: T) -&gt; T</code></p><ul><li><code>low</code>, <code>high</code>, <code>x</code>: The input vectors.</li><li><code>T</code>: Can be <code>vecN&lt;f32&gt;</code> or <code>vecN&lt;f16&gt;</code>.</li></ul><p>A convenient alternative signature also exists:</p><p><code>smoothstep(low: S, high: S, x: T) -&gt; T</code></p><p>Where <code>low</code> and <code>high</code> are scalars, and <code>x</code> is a vector. This applies the same scalar range to each component of <code>x</code>.</p><h5 id="description-53">Description</h5><p>Performs the smoothstep operation on each component of the input vector <code>x</code> independently. If <code>low</code> and <code>high</code> are vectors, the corresponding components are used for each channel’s range. If <code>low</code> and <code>high</code> are scalars, they are used as a uniform range for all components of <code>x</code>.</p><h4 id="use-case-46">Use Case</h4><p>The canonical use case is creating a soft, anti-aliased edge for a shape, or a smooth fade.</p><pre><code class="language-wgsl">// Create a circle with a soft edge.
let center = vec2&lt;f32&gt;(0.5);
let dist = distance(uv, center);

let radius = 0.3;
let softness = 0.1;

// The transition will start at the inner edge (radius - softness)
// and end at the outer edge (radius + softness).
let inner_edge = radius - softness;
let outer_edge = radius + softness;

// `smoothstep` creates a smooth gradient in the softness region.
// We subtract from 1.0 to make the inside of the circle white (1.0).
let soft_circle = 1.0 - smoothstep(inner_edge, outer_edge, dist);
</code></pre><p>Useful for fading color channels at different rates or applying a smooth threshold to a vector.</p><pre><code class="language-wgsl">let my_color = vec3&lt;f32&gt;(0.2, 0.6, 0.9);

// Use a single scalar range for all color channels.
// Each channel of `my_color` will be smoothly mapped from 0 to 1
// as it crosses the [0.3, 0.8] range.
let faded_color_uniform = smoothstep(0.3, 0.8, my_color);

// Use a different range for each color channel.
let low_thresholds = vec3&lt;f32&gt;(0.1, 0.5, 0.8);
let high_thresholds = vec3&lt;f32&gt;(0.3, 0.7, 0.9);
let faded_color_per_channel = smoothstep(low_thresholds, high_thresholds, my_color);
// Red channel fades between 0.1 and 0.3.
// Green channel fades between 0.5 and 0.7.
// Blue channel fades between 0.8 and 0.9.
</code></pre><h3 id="step"><code>step</code></h3><p>Performs a binary threshold operation, returning <code>0.0</code> or <code>1.0</code> based on a comparison. It is a fundamental function for creating hard-edged shapes and conditional masks without using branches (<code>if</code> statements).</p><h4 id="overload-scalar-and-vector-inputs">Overload: Scalar and Vector Inputs</h4><p>This overload compares two values or vectors of the same type.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#step-builtin"><code>step</code></a></em></p><h5 id="signature-54">Signature</h5><p><code>step(edge: T, x: T) -&gt; T</code></p><ul><li><code>edge</code>: The threshold value or vector.</li><li><code>x</code>: The input value or vector to be tested.</li><li><code>T</code>: Can be <code>f32</code>, <code>f16</code>, or a vector of these types (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h5 id="description-54">Description</h5><p>Compares the input <code>x</code> to the <code>edge</code>.</p><ul><li>If <code>x</code> is greater than or equal to <code>edge</code>, the result is <code>1.0</code>.</li><li>If <code>x</code> is less than <code>edge</code>, the result is <code>0.0</code>.</li></ul><p>When the inputs are vectors, the comparison is performed component-wise, and the result is a vector of <code>0.0</code>s and <code>1.0</code>s.</p><h4 id="overload-scalar-edge">Overload: Scalar Edge</h4><p>This is a convenient alternative overload that compares each component of a vector to a single scalar threshold.</p><h5 id="signature-55">Signature</h5><p><code>step(edge: S, x: T) -&gt; T</code></p><ul><li><code>edge</code>: The single, scalar threshold.</li><li><code>x</code>: The input vector to be tested.</li><li><code>S</code>: The scalar type, <code>f32</code> or <code>f16</code>.</li><li><code>T</code>: The vector type, <code>vecN&lt;S&gt;</code>.</li></ul><h5 id="description-55">Description</h5><p>Compares each component of the input vector x against the single scalar edge. The result is a vector of 0.0s and 1.0s.</p><h4 id="use-case-47">Use Case</h4><pre><code class="language-wgsl">// Use Case 1: Creating a hard-edged circle
let center = vec2&lt;f32&gt;(0.5);
let radius = 0.4;
let dist = distance(uv, center);

// This creates a mask. `step` returns 0.0 inside the circle and 1.0 outside.
let mask = step(radius, dist);

// We subtract from 1.0 to invert it, making the circle white.
let circle = 1.0 - mask;

// Use Case 2: Component-wise threshold
let color = vec3&lt;f32&gt;(0.2, 0.6, 0.8);
let threshold = vec3&lt;f32&gt;(0.5, 0.5, 0.5);
let result = step(threshold, color);
// `result` is vec3&lt;f32&gt;(0.0, 1.0, 1.0), because only the green and blue
// components were greater than or equal to 0.5.
</code></pre><pre><code class="language-wgsl">let color = vec3&lt;f32&gt;(0.2, 0.6, 0.8);
let brightness_threshold = 0.5;

// Compare each component of `color` to the single `brightness_threshold`.
let result = step(brightness_threshold, color);
// `result` is vec3&lt;f32&gt;(0.0, 1.0, 1.0).
</code></pre><h2 id="logical--selection-functions">Logical &amp; Selection Functions</h2><p>This family of functions provides the core tools for performing logical operations and conditional selection, often serving as high-performance, “branchless” alternatives to <code>if</code> statements.</p><p>GPUs achieve their speed by having many threads execute the same instruction in lock-step. An <code>if</code> statement can break this parallelism if some threads in a group take a different path than others (a situation called “thread divergence”). The functions in this category are designed to perform decision-making tasks without introducing this branching, which can lead to more efficient and predictable code.</p><p>They serve two main purposes:</p><ul><li><strong>Vector Reduction:</strong> Functions that take a vector of booleans (often the result of a component-wise comparison) and collapse it into a single <code>true</code> or <code>false</code> result.</li><li><strong>Conditional Selection:</strong> Functions that choose between two values based on a boolean condition, acting as WGSL’s equivalent of a ternary operator.</li></ul><p>Mastering these functions is key to writing concise, readable, and highly efficient shader logic.</p><h3 id="all"><code>all</code></h3><h4 id="signature-56">Signature</h4><ul><li><p><code>all(e: vecN&lt;bool&gt;) -&gt; bool</code></p></li><li><p><code>all(e: bool) -&gt; bool</code></p></li><li><p><code>e</code>: The input boolean or vector of booleans.</p></li><li><p><code>N</code>: For the vector overload, must be <code>2</code>, <code>3</code>, or <code>4</code>.</p></li></ul><h4 id="description-56">Description</h4><p>Performs a logical AND operation on the input. The behavior depends on the input type:</p><ul><li><strong>For a <code>vecN&lt;bool&gt;</code>:</strong> Returns <code>true</code> if and only if every component of the vector <code>e</code> is <code>true</code>. This is a “vector reduction,” collapsing a boolean vector into a single result.</li><li><strong>For a single <code>bool</code>:</strong> Acts as an <strong>identity function</strong>, simply returning the input boolean <code>e</code> without modification. This overload exists mainly for language completeness.</li></ul><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#all-builtin"><code>all</code></a></em></p><h4 id="use-case-48">Use Case</h4><p>The primary use case is for the vector overload, which allows you to make a single decision based on a component-wise comparison of two vectors.</p><pre><code class="language-wgsl">let reference_point = vec3&lt;f32&gt;(1.0, 2.0, 3.0);
let point_a = vec3&lt;f32&gt;(1.5, 2.5, 3.5); // All components are greater
let point_b = vec3&lt;f32&gt;(0.5, 2.5, 3.5); // One component is not greater

// The component-wise comparison results in a boolean vector.
let a_is_greater = point_a &gt; reference_point; // -&gt; vec3&lt;bool&gt;(true, true, true)
let b_is_greater = point_b &gt; reference_point; // -&gt; vec3&lt;bool&gt;(false, true, true)

// `all` reduces the boolean vector to a single bool.
let result_a = all(a_is_greater); // -&gt; true
let result_b = all(b_is_greater); // -&gt; false
</code></pre><h3 id="any"><code>any</code></h3><h4 id="signature-57">Signature</h4><ul><li><p><code>any(e: vecN&lt;bool&gt;) -&gt; bool</code></p></li><li><p><code>any(e: bool) -&gt; bool</code></p></li><li><p><code>e</code>: The input boolean or vector of booleans.</p></li><li><p><code>N</code>: For the vector overload, must be <code>2</code>, <code>3</code>, or <code>4</code>.</p></li></ul><h4 id="description-57">Description</h4><p>Performs a logical OR operation on the input. The behavior depends on the input type:</p><ul><li><strong>For a <code>vecN&lt;bool&gt;</code>:</strong> Returns <code>true</code> if one or more components of the vector <code>e</code> are <code>true</code>. It only returns <code>false</code> if all components are <code>false</code>. This is a “vector reduction,” collapsing a boolean vector into a single result.</li><li><strong>For a single bool:</strong> Acts as an <strong>identity function</strong>, simply returning the input boolean <code>e</code> without modification. This overload exists mainly for language completeness.</li></ul><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#any-builtin"><code>any</code></a></em></p><h4 id="use-case-49">Use Case</h4><p>The primary use case is for the vector overload, which allows you to check if at least one component of a vector satisfies a condition.</p><pre><code class="language-wgsl">let thresholds = vec3&lt;f32&gt;(0.5, 0.8, 0.3);
let values = vec3&lt;f32&gt;(0.6, 0.7, 0.9);

// The component-wise comparison results in a boolean vector.
// 0.6 &gt; 0.5 -&gt; true
// 0.7 &gt; 0.8 -&gt; false
// 0.9 &gt; 0.3 -&gt; true
let is_over_threshold = values &gt; thresholds; // -&gt; vec3&lt;bool&gt;(true, false, true)

// `any` reduces the boolean vector to a single bool.
// Since at least one component was true, the result is true.
let result = any(is_over_threshold); // -&gt; true

if (result) {
    // This code will execute because the red and blue channels passed the check.
}
</code></pre><h3 id="select"><code>select</code></h3><p>The <code>select</code> function is WGSL’s branchless equivalent of a ternary operator (like <code>condition ? value_if_true : value_if_false</code> in other languages). It chooses between two values based on a boolean condition without using an <code>if</code> statement, which can be more performant on the GPU.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#select-builtin"><code>select</code></a></em></p><h4 id="overload-scalar-condition">Overload: Scalar Condition</h4><p>This is the most common overload. It selects one of two complete values (scalars or vectors) based on a single boolean condition.</p><h5 id="signature-58">Signature</h5><p><code>select(f: T, t: T, cond: bool) -&gt; T</code></p><ul><li><code>f</code>: The value to be returned if <code>cond</code> is <code>false</code>.</li><li><code>t</code>: The value to be returned if <code>cond</code> is <code>true</code>.</li><li><code>cond</code>: The single boolean condition.</li><li><code>T</code>: Can be any scalar (<code>i32</code>, <code>f32</code>, etc.) or vector (<code>vec3&lt;f32&gt;</code>, etc.) type. <code>f</code> and <code>t</code> must be of the same type.</li></ul><h5 id="description-58">Description</h5><p>Returns the value <code>t</code> if the boolean <code>cond</code> is true, and returns the value <code>f</code> otherwise.</p><p>Crucially, this is a <strong>branchless</strong> operation. The GPU evaluates both the <code>t</code> and <code>f</code> expressions, and then simply selects the correct result. This avoids the performance cost of “thread divergence” that can happen with an <code>if</code> statement. However, it also means you should <strong>never</strong> use expensive, mutually-exclusive functions for both the <code>t</code> and <code>f</code> arguments, as both will always be executed.</p><h4 id="overload-vector-condition">Overload: Vector Condition</h4><p>This overload performs a component-wise selection, building a new vector by choosing components from two source vectors based on a boolean vector.</p><h5 id="signature-59">Signature</h5><p><code>select(f: vecN&lt;T&gt;, t: vecN&lt;T&gt;, cond: vecN&lt;bool&gt;) -&gt; vecN&lt;T&gt;</code></p><ul><li><code>f</code>, <code>t</code>: The source vectors.</li><li><code>cond</code>: The vector of boolean conditions.</li><li><code>T</code>: The scalar component type of the vectors.</li><li><code>N</code>: The dimension of the vectors.</li></ul><h5 id="description-59">Description</h5><p>Constructs a result vector where each component <code>i</code> is chosen from <code>t[i]</code> if <code>cond[i]</code> is <code>true</code>, or from <code>f[i]</code> if <code>cond[i]</code> is <code>false</code>. All three input vectors must have the same number of components.</p><h4 id="use-case-50">Use Case</h4><pre><code class="language-wgsl">let brightness = 0.8;
let is_bright = brightness &gt; 0.5; // is_bright is true

let black = vec3&lt;f32&gt;(0.0);
let white = vec3&lt;f32&gt;(1.0);

// Because is_bright is true, the function will select the `t` value (white).
let final_color = select(black, white, is_bright); // Result is vec3&lt;f32&gt;(1.0)
</code></pre><pre><code class="language-wgsl">let a = vec3&lt;f32&gt;(1.0, 10.0, 100.0);
let b = vec3&lt;f32&gt;(5.0, 5.0, 5.0);

// The component-wise comparison results in a boolean vector.
// 1.0 &gt; 5.0 -&gt; false
// 10.0 &gt; 5.0 -&gt; true
// 100.0 &gt; 5.0 -&gt; true
let condition_vec = a &gt; b; // Result is vec3&lt;bool&gt;(false, true, true)

// Build a new vector based on the condition vector:
// Result.x is from a.x because condition_vec.x is false.
// Result.y is from b.y because condition_vec.y is true.
// Result.z is from b.z because condition_vec.z is true.
let result = select(a, b, condition_vec); // Result is vec3&lt;f32&gt;(1.0, 5.0, 5.0)
</code></pre><h2 id="integer--bitwise-functions">Integer &amp; Bitwise Functions</h2><p>This family of functions operates on the binary representation of integers. Instead of treating them as numerical values for arithmetic, these functions treat <code>i32</code> and <code>u32</code> types as a sequence of 32 individual bits (0s and 1s).</p><p>They provide the tools to perform low-level bit manipulation, such as:</p><ul><li>Counting the number of set (<code>1</code>) or unset (<code>0</code>) bits.</li><li>Finding the position of the first or last set bit.</li><li>Reversing the order of all bits within an integer.</li><li>Directly reading (<code>extracting</code>) or writing (<code>inserting</code>) specific segments of bits.</li></ul><p>While less common in high-level visual effects than mathematical or texture functions, these operations are indispensable for performance-critical algorithms, custom data packing and unpacking, creating bitmasks and flags, and implementing hash functions or pseudo-random number generators. They offer precise control over data at its most fundamental level.</p><h3 id="countleadingzeros"><code>countLeadingZeros</code></h3><h4 id="signature-60">Signature</h4><p><code>countLeadingZeros(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input integer or vector of integers.</li><li><code>T</code>: Can be <code>i32</code>, <code>u32</code>, or a vector of these types (e.g., <code>vec3&lt;u32&gt;</code>).</li></ul><h4 id="description-60">Description</h4><p>Counts the number of consecutive <code>0</code> bits, starting from the most significant bit (the “leftmost” bit in a standard binary representation) of a 32-bit integer. This function is often abbreviated as “clz”.</p><ul><li><code>countLeadingZeros(0u)</code> returns <code>32</code>.</li><li><code>countLeadingZeros(1u)</code> returns <code>31</code>.</li><li><code>countLeadingZeros(2147483648u)</code> (which is <code>1</code> followed by 31 zeros in binary) returns <code>0</code>.</li></ul><p>The function is applied component-wise when the input is a vector.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#countLeadingZeros-builtin"><code>countLeadingZeros</code></a></em></p><h4 id="use-case-51">Use Case</h4><p>This is a low-level bit manipulation function often used for performance-critical tasks like calculating an integer logarithm base 2 or finding the position of the most significant bit (MSB).</p><pre><code class="language-wgsl">// Find the integer base-2 logarithm of a number, which is equivalent
// to finding the position of its most significant bit.
let value = 1000u; // Binary: ...01111101000, MSB is at position 9 (0-indexed)

// The number of leading zeros tells us how far the MSB is from the &quot;left&quot;.
let leading_zeros = countLeadingZeros(value); // For 1000u, this is 22.

// For a non-zero u32, the position of the MSB is 31 minus the number of leading zeros.
let msb_position = 31u - leading_zeros; // 31 - 22 = 9

// The result, 9, is the integer log2 of 1000 (since 2^9 = 512, which is the
// largest power of 2 less than or equal to 1000).
</code></pre><h3 id="countonebits"><code>countOneBits</code></h3><h4 id="signature-61">Signature</h4><p><code>countOneBits(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input integer or vector of integers.</li><li><code>T</code>: Can be <code>i32</code>, <code>u32</code>, or a vector of these types (e.g., <code>vec3&lt;u32&gt;</code>).</li></ul><h4 id="description-61">Description</h4><p>Counts the number of bits that are set to <code>1</code> in the binary representation of an integer. This operation is also known as “population count” or “popcount”.</p><ul><li><code>countOneBits(0u)</code> returns <code>0</code>.</li><li><code>countOneBits(7u)</code> (binary <code>...0111</code>) returns <code>3</code>.</li><li><code>countOneBits(4294967295u)</code> (all <code>1</code>s for a <code>u32</code>) returns <code>32</code>.</li><li>For negative numbers, the count is based on the two’s complement representation. <code>countOneBits(-1i)</code> is <code>32</code>.</li></ul><p>The function is applied component-wise when the input is a vector.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#countOneBits-builtin"><code>countOneBits</code></a></em></p><h4 id="use-case-52">Use Case</h4><p>This is a low-level bit manipulation function used in a variety of algorithms, including cryptography, data compression, and implementing certain types of hash functions or pseudo-random number generators.</p><pre><code class="language-wgsl">// A simple example of using popcount to measure the &quot;bit density&quot; of a number.
let val_a = 7u; // ...00000111
let val_b = 8u; // ...00001000

let popcount_a = countOneBits(val_a); // Result is 3
let popcount_b = countOneBits(val_b); // Result is 1

// It can be a building block for a pseudo-random generator (hash function).
// This is a toy example, not a high-quality hash.
fn simple_hash(n: u32) -&gt; u32 {
    let a = n ^ (n &lt;&lt; 13u);
    let b = a ^ (a &gt;&gt; 7u);
    return countOneBits(b);
}
</code></pre><h3 id="counttrailingzeros"><code>countTrailingZeros</code></h3><h4 id="signature-62">Signature</h4><p><code>countTrailingZeros(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input integer or vector of integers.</li><li><code>T</code>: Can be <code>i32</code>, <code>u32</code>, or a vector of these types (e.g., <code>vec3&lt;u32&gt;</code>).</li></ul><h4 id="description-62">Description</h4><p>Counts the number of consecutive <code>0</code> bits, starting from the least significant bit (the “rightmost” bit in a standard binary representation) of a 32-bit integer. This function is often abbreviated as “ctz”.</p><ul><li><code>countTrailingZeros(0u)</code> returns <code>32</code>.</li><li><code>countTrailingZeros(8u)</code> (binary <code>...1000</code>) returns <code>3</code>.</li><li><code>countTrailingZeros(7u)</code> (binary <code>...0111</code>) returns <code>0</code>.</li></ul><p>The function is applied component-wise when the input is a vector.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#countTrailingZeros-builtin"><code>countTrailingZeros</code></a></em></p><h4 id="use-case-53">Use Case</h4><p>This is a low-level bit manipulation function. Its primary use is to find the position of the least significant set bit (LSB). It can also be used to quickly determine the largest power of 2 that a number is divisible by.</p><pre><code class="language-wgsl">// A number whose binary representation is ...0101100.
let value = 44u;

// The number of trailing zeros is equal to the 0-indexed position
// of the least significant &#39;1&#39; bit.
// For ...0101100, there are two trailing zeros, so the LSB is at position 2.
let lsb_position = countTrailingZeros(value); // Result is 2.

// This is useful for algorithms that need to isolate and process the
// lowest set bit in a bitmask.
// 2 to the power of `lsb_position` gives us a mask for that bit.
let lsb_mask = 1u &lt;&lt; lsb_position; // 1u &lt;&lt; 2u is 4u (binary ...100)
</code></pre><h3 id="extractbits"><code>extractBits</code></h3><p>Extracts a sequence of bits from a specific location within an integer. The behavior of the function differs significantly depending on whether the integer is signed or unsigned.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#extractBits-unsigned-builtin"><code>extractBits</code></a></em></p><h4 id="overload-signed-integers-i32">Overload: Signed Integers (i32)</h4><p>This overload reads bits from a signed integer and performs <strong>sign extension</strong> on the result.</p><h5 id="signature-63">Signature</h5><p><code>extractBits(e: T, offset: u32, count: u32) -&gt; T</code></p><ul><li><code>e</code>: The source integer or vector of integers.</li><li><code>offset</code>: The 0-indexed starting bit position to begin extracting from.</li><li><code>count</code>: The number of bits to extract.</li><li><code>T</code>: Can be <code>i32</code> or <code>vecN&lt;i32&gt;</code>.</li></ul><h5 id="description-63">Description</h5><p>Extracts a <code>count</code>-bit sequence from <code>e</code> starting at <code>bit</code> offset. The key feature is <strong>sign extension</strong>: the most significant bit of the extracted sequence is copied to all the higher bits of the 32-bit result. This preserves the numerical value of the extracted bits as if they were a smaller signed integer type.</p><p>The <code>offset</code> and <code>count</code> are clamped to safe values to prevent out-of-bounds reads. It is a compile-time error if <code>offset + count</code> is greater than 32 and both parameters are compile-time constants.</p><h4 id="overload-unsigned-integers-u32">Overload: Unsigned Integers (u32)</h4><p>This overload reads bits from an unsigned integer and performs <strong>zero extension</strong> on the result.</p><h5 id="signature-64">Signature</h5><p><code>extractBits(e: T, offset: u32, count: u32) -&gt; T</code></p><ul><li><code>e</code>: The source integer or vector of integers.</li><li><code>offset</code>: The 0-indexed starting bit position.</li><li><code>count</code>: The number of bits to extract.</li><li><code>T</code>: Can be <code>u32</code> or <code>vecN&lt;u32&gt;</code>.</li></ul><h5 id="description-64">Description</h5><p>Extracts a <code>count</code>-bit sequence from <code>e</code> starting at bit <code>offset</code>. The key difference from the signed version is <strong>zero extension</strong>: all higher bits of the 32-bit result that were not part of the extraction are filled with <code>0</code>s.</p><p>The <code>offset</code> and <code>count</code> are clamped to safe values. It is a compile-time error if <code>offset + count</code> is greater than 32 and both parameters are compile-time constants.</p><h4 id="use-case-54">Use Case</h4><p>Used for unpacking multiple smaller signed values that have been packed into a single i32. Sign extension is critical for correctly restoring negative values.</p><pre><code class="language-wgsl">// Imagine two 4-bit signed numbers are packed into the first 8 bits of an i32.
// High bits: 1011 (which is -5 in a 4-bit signed integer)
// Low bits:  0101 (which is +5 in a 4-bit signed integer)
// The combined bit pattern is ...000010110101
let packed_data = 181i; // 10110101 in binary

// Extract the high 4 bits (the negative number)
// Offset is 4, count is 4.
// Extracted bits are &#39;1011&#39;. The most significant bit of this sequence is &#39;1&#39;.
// Sign extension will fill the upper 28 bits of the result with &#39;1&#39;s.
// Result: ...11111011, which is the correct 32-bit representation of -5.
let high_value = extractBits(packed_data, 4u, 4u); // Result is -5

// Extract the low 4 bits (the positive number)
// Offset is 0, count is 4.
// Extracted bits are &#39;0101&#39;. The most significant bit of this sequence is &#39;0&#39;.
// The upper 28 bits of the result are filled with &#39;0&#39;s.
// Result: ...00000101, which is the correct 32-bit representation of 5.
let low_value = extractBits(packed_data, 0u, 4u); // Result is 5
</code></pre><p>Used for unpacking multiple smaller unsigned values, such as color channels or other non-negative data packed into a single u32.</p><pre><code class="language-wgsl">// Imagine an RGBA color where R and G are 4 bits each, packed into a u32.
// High bits (G): 1011 (which is the unsigned value 11)
// Low bits  (R): 0101 (which is the unsigned value 5)
// The combined bit pattern is ...000010110101
let packed_color = 181u;

// Extract the high 4 bits (the Green channel)
// Offset is 4, count is 4.
// Extracted bits are &#39;1011&#39;.
// Zero extension fills the upper bits with &#39;0&#39;s.
// Result: ...00001011, which is the correct 32-bit representation of 11.
let green_channel = extractBits(packed_color, 4u, 4u); // Result is 11

// Extract the low 4 bits (the Red channel)
// Offset is 0, count is 4.
// Extracted bits are &#39;0101&#39;.
// Zero extension fills the upper bits with &#39;0&#39;s.
// Result: ...00000101, which is the correct 32-bit representation of 5.
let red_channel = extractBits(packed_color, 0u, 4u); // Result is 5
</code></pre><h3 id="firstleadingbit"><code>firstLeadingBit</code></h3><p>Finds the position of the most significant <code>1</code> bit in an integer’s binary representation. This is also known as “find first set” from the left.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#firstLeadingBit-unsigned-builtin"><code>firstLeadingBit</code></a></em></p><h4 id="overload-unsigned-integers-u32-1">Overload: Unsigned Integers (u32)</h4><p>This is the most common and intuitive version of the function.</p><h5 id="signature-65">Signature</h5><p><code>firstLeadingBit(e: T) -&gt; T</code></p><ul><li><code>e</code>: The source unsigned integer or vector.</li><li><code>T</code>: Can be <code>u32</code> or <code>vecN&lt;u32&gt;</code>.</li></ul><h5 id="description-65">Description</h5><p>Finds the index of the most significant (leftmost) <code>1</code> bit in the binary representation of <code>e</code>.</p><ul><li>If <code>e</code> is <strong>not zero</strong>, the result is the 0-indexed position of the highest set bit.</li><li>If <code>e</code> is <strong>zero</strong>, the result is <code>-1</code>.</li></ul><h5 id="use-case-55">Use Case</h5><p>This function is a highly efficient way to calculate the integer base-2 logarithm of a number, which is equivalent to finding the position of its most significant bit.</p><pre><code class="language-wgsl">// A number whose binary representation is ...00101000.
// The most significant &#39;1&#39; bit is at position 5 (reading from the right, 0-indexed).
let value_a = 40u;
let msb_pos_a = firstLeadingBit(value_a); // Result is 5

// Another example. Binary is ...01000000
let value_b = 64u;
let msb_pos_b = firstLeadingBit(value_b); // Result is 6

// Case where the input is zero.
let value_c = 0u;
let msb_pos_c = firstLeadingBit(value_c); // Result is -1
</code></pre><h4 id="overload-signed-integers-i32-1">Overload: Signed Integers (i32)</h4><p>This overload operates on the two’s complement representation of a signed integer, which can lead to different results than the unsigned version, especially for negative numbers.</p><h5 id="signature-66">Signature</h5><p><code>firstLeadingBit(e: T) -&gt; T</code></p><ul><li><code>e</code>: The source signed integer or vector.</li><li><code>T</code>: Can be <code>i32</code> or <code>vecN&lt;i32&gt;</code>.</li></ul><h5 id="description-66">Description</h5><p>Finds the index of the most significant <code>1</code> bit in the two’s complement binary representation of <code>e</code>.</p><ul><li>For <strong>positive numbers</strong>, the behavior is the same as the <code>u32</code> version. <code>firstLeadingBit(40i) is 5</code>.</li><li>For <strong>negative numbers</strong>, the result is the position of the leftmost <code>0</code> bit, because in two’s complement, negative numbers are effectively the bitwise inverse of their positive counterparts (plus one), resulting in many leading <code>1</code>s.</li><li>If <code>e</code> is <strong>-1</strong> (all bits are <code>1</code>), the result is <code>-1</code>.</li><li>If <code>e</code> is <strong>zero</strong>, the result is <code>-1</code>.</li></ul><h5 id="use-case-56">Use Case</h5><p>This is a specialized function. It is rarely used directly for visual effects. Its primary use is in low-level numerical algorithms where operating on the two’s complement representation of numbers is necessary. For most “find my highest bit” tasks, the <code>u32</code> version is what you want.</p><pre><code class="language-wgsl">// Positive number, same as u32 version.
let val_pos = 40i;
let msb_pos_pos = firstLeadingBit(val_pos); // Result is 5

// For negative numbers, the two&#39;s complement representation is used.
// -1 in i32 is 32 ones (...11111111). There are no &#39;0&#39; bits to be the &quot;leading bit&quot;.
// The spec defines this as a special case.
let val_neg_one = -1i;
let msb_pos_neg_one = firstLeadingBit(val_neg_one); // Result is -1
</code></pre><h3 id="firsttrailingbit"><code>firstTrailingBit</code></h3><h4 id="signature-67">Signature</h4><p><code>firstTrailingBit(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input integer or vector of integers.</li><li><code>T</code>: Can be <code>i32</code>, <code>u32</code>, or a vector of these types (e.g., <code>vec3&lt;u32&gt;</code>).</li></ul><h4 id="description-67">Description</h4><p>Finds the position of the least significant <code>1</code> bit in an integer’s binary representation. This is also known as “find first set” from the right.</p><ul><li>If <code>e</code> is <strong>not zero</strong>, the result is the 0-indexed position of the rightmost <code>1</code> bit.</li><li>If <code>e</code> is <strong>zero</strong>, the result is <code>-1</code>.</li></ul><p>Unlike <code>firstLeadingBit</code>, the behavior of this function is consistent for both positive and negative signed integers because the least significant bits are not affected by the two’s complement sign representation in the same way.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#firstTrailingBit-builtin"><code>firstTrailingBit</code></a></em></p><h4 id="use-case-57">Use Case</h4><p>This function is a highly efficient way to find the position of the lowest set bit in a bitmask. This is equivalent to countTrailingZeros, but provides a different name for the same operation, which can sometimes improve code clarity depending on the algorithm’s intent.</p><pre><code class="language-wgsl">// A number whose binary representation is ...0101100.
// The least significant &#39;1&#39; bit is at position 2 (reading from the right, 0-indexed).
let value = 44u;
let lsb_position = firstTrailingBit(value); // Result is 2.

// This result is identical to `countTrailingZeros(44u)`.

// Case where the input is zero.
let value_zero = 0u;
let lsb_pos_zero = firstTrailingBit(value_zero); // Result is -1
</code></pre><h3 id="insertbits"><code>insertBits</code></h3><h4 id="signature-68">Signature</h4><p><code>insertBits(e: T, newbits: T, offset: u32, count: u32) -&gt; T</code></p><ul><li><code>e</code>: The base integer or vector to insert bits into.</li><li><code>newbits</code>: The integer or vector containing the bits to insert.</li><li><code>offset</code>: The 0-indexed starting bit position in <code>e</code> where insertion begins.</li><li><code>count</code>: The number of bits to insert.</li><li><code>T</code>: Can be <code>i32</code>, <code>u32</code>, or a vector of these types (e.g., <code>vec3&lt;u32&gt;</code>).</li></ul><h4 id="description-68">Description</h4><p>Constructs a new integer by replacing a sequence of bits in <code>e</code> with bits from <code>newbits</code>.</p><p>Specifically, it takes the count least significant bits from <code>newbits</code> and copies them into the bit range <code>[offset, offset + count - 1]</code> of the base value <code>e</code>. All other bits from <code>e</code> are preserved.</p><p>The <code>offset</code> and <code>count</code> parameters are clamped to safe values to prevent out-of-bounds writes. It is a compile-time error if <code>offset + count</code> is greater than 32 and both parameters are compile-time constants.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#insertBits-builtin"><code>insertBits</code></a></em></p><h4 id="use-case-58">Use Case</h4><p>This is a low-level bit manipulation function used for packing multiple smaller values into a single larger integer. It is the inverse operation of <a href="#extractbits"><code>extractBits</code></a>.</p><pre><code class="language-wgsl">// Let&#39;s pack a 4-bit Red and a 4-bit Green channel into a single u32.
var packed_color = 0u; // Start with an empty integer

let red_channel = 5u;  // Binary ...0101
let green_channel = 11u; // Binary ...1011

// Insert the 4 bits of the red channel at the beginning (offset 0).
// packed_color is now ...00000101
packed_color = insertBits(packed_color, red_channel, 0u, 4u);

// Insert the 4 bits of the green channel starting at bit 4.
// packed_color is now ...000010110101
packed_color = insertBits(packed_color, green_channel, 4u, 4u);

// The final packed_color is 181u, which contains both pieces of data.
// This can now be unpacked using `extractBits`.
</code></pre><h3 id="reversebits"><code>reverseBits</code></h3><h4 id="signature-69">Signature</h4><p><code>reverseBits(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input integer or vector of integers.</li><li><code>T</code>: Can be <code>i32</code>, <code>u32</code>, or a vector of these types (e.g., <code>vec3&lt;u32&gt;</code>).</li></ul><h4 id="description-69">Description</h4><p>Reverses the order of the 32 bits in the binary representation of <code>e</code>. The most significant bit (bit 31) becomes the least significant bit (bit 0), and so on.</p><p>For example, for a u32, the bit at position <code>k</code> in the result is taken from the bit at position <code>31 - k</code> in the input.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#reverseBits-builtin"><code>reverseBits</code></a></em></p><h4 id="use-case-59">Use Case</h4><p>This is a low-level bit manipulation function used in specific algorithms that require reordering of data at the bit level, such as certain <a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform">Fast Fourier Transform</a> (FFT) implementations, <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">Cyclic Redundancy Checks</a> (CRCs), or as a component in some hash functions.</p><pre><code class="language-wgsl">// Let&#39;s take the number 13u.
// Its 32-bit binary representation is:
// 00000000 00000000 00000000 00001101
let value = 13u;

// `reverseBits` will flip this entire sequence.
let reversed_value = reverseBits(value);

// The result&#39;s binary representation will be:
// 10110000 00000000 00000000 00000000
// which is the decimal value 2952790016u.
</code></pre><h2 id="buffer-and-array-functions">Buffer and Array Functions</h2><p>This category contains functions that query metadata about buffer resources, specifically those containing arrays whose size is not known at shader compilation time.</p><p>In WGSL, <code>storage</code> buffers can be declared with runtime-sized arrays, meaning their final length is determined by the buffer that is bound on the CPU side. This is a powerful feature for handling dynamic data, but it requires a special mechanism within the shader to determine the array’s bounds. The functions in this group provide that mechanism, allowing you to safely query the size of a runtime array to prevent out-of-bounds memory access.</p><h3 id="arraylength"><code>arrayLength</code></h3><h4 id="signature-70">Signature</h4><p>arrayLength(p: ptr&lt;storage, T&gt;) -&gt; u32</p><ul><li><code>p</code>: A pointer to a runtime-sized array.</li><li><code>T</code>: The type of the array itself (e.g., <code>array&lt;f32&gt;</code>).</li></ul><h4 id="description-70">Description</h4><p>Returns the number of elements in a runtime-sized array that is stored in a storage buffer.</p><p>This function has a critical structural requirement: it can <strong>only</strong> be used on an array that is the <strong>last member of a struct</strong> which is the type for a storage buffer variable. The size is not known at shader compilation time; it is determined by the size of the actual buffer that is bound on the CPU side at runtime.</p><p>This function is the primary mechanism for safely working with dynamic-sized data in shaders, as it allows you to query the buffer’s bounds before accessing it.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#arrayLength-builtin"><code>arrayLength</code></a></em></p><h4 id="use-case-60">Use Case</h4><p>The most common use case is to get the size of an input buffer in a compute shader to use as a loop bound or for safety checks to prevent out-of-bounds memory access.</p><pre><code class="language-wgsl">// This struct defines the layout of our storage buffer.
// The runtime-sized array MUST be the last member.
struct MyBuffer {
    some_config_value: f32,
    data: array&lt;f32&gt;,
}

@group(0) @binding(0) var&lt;storage, read&gt; my_buffer: MyBuffer;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) {
    // Get the total number of elements in the &#39;data&#39; array at runtime.
    // Note the &#39;&amp;&#39; to pass a pointer to the array.
    let num_elements = arrayLength(&amp;my_buffer.data);

    // Use the length to prevent reading past the end of the buffer.
    if (global_id.x &gt;= num_elements) {
        return;
    }

    // Now it&#39;s safe to access the element.
    let value = my_buffer.data[global_id.x];
    // ... do work with the value ...
}
</code></pre><h2 id="type-conversion--reinterpretation">Type Conversion &amp; Reinterpretation</h2><p>This category contains functions that perform low-level reinterpretation of a value’s underlying binary representation.</p><p>Unlike standard type conversions (e.g., <code>f32(my_int)</code>), which change a value from one numerical representation to another while preserving its meaning, these functions change the type label of a block of memory without altering the raw bits.</p><p>This is an advanced operation used for specialized algorithms, data packing, or when you need to operate directly on the bit pattern of a number. The core principle for these operations is that the total bit-width of the source and destination types must be identical.</p><h3 id="bitcast"><code>bitcast</code></h3><p>A low-level operation that reinterprets the raw binary bits of an input value as if they were of a different type, without changing the bit pattern itself. This is <strong>not a traditional type conversion</strong> that preserves numerical value (e.g., <code>bitcast&lt;i32&gt;(1.0)</code> will not result in <code>1</code>).</p><p>The fundamental rule of <code>bitcast</code> is that the <strong>total bit-width of the input and output types must be identical</strong>. The target type <code>T</code> is specified using a unique angle-bracket syntax: <code>bitcast&lt;T&gt;(...)</code>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#bitcast-builtin"><code>bitcast</code></a></em></p><h4 id="overloads-same-size-reinterpretation-f32-i32-u32">Overloads: Same-Size Reinterpretation (<code>f32</code>, <code>i32</code>, <code>u32</code>)</h4><p>This group of overloads reinterprets the bits between the fundamental 32-bit types.</p><h5 id="signature-71">Signature</h5><ul><li><p><code>bitcast&lt;T&gt;(e: S) -&gt; T (Scalar)</code></p></li><li><p><code>bitcast&lt;vecN&lt;T&gt;&gt;(e: vecN&lt;S&gt;) -&gt; vecN&lt;T&gt; (Vector)</code></p></li><li><p><code>S</code>: The source type, can be <code>f32</code>, <code>i32</code>, or <code>u32</code>.</p></li><li><p><code>T</code>: The target type, a different type from <code>S</code>, can be <code>f32</code>, <code>i32</code>, or <code>u32</code>.</p></li></ul><h5 id="description-71">Description</h5><p>Reinterprets the 32 bits of a scalar or each 32-bit component of a vector. For example, <code>bitcast&lt;u32&gt;(1.0)</code> takes the 32 bits that represent the <code>f32</code> value 1.0 (which is <code>0x3F800000</code> in hex) and interprets them as a <code>u32</code>, resulting in the integer <code>1065353216</code>.</p><h5 id="use-case-61">Use Case</h5><p>Used for data packing or implementing highly specialized algorithms that rely on the binary representation of numbers.</p><pre><code class="language-wgsl">// Use case: Packing a floating-point value into an integer for storage.
let my_float: f32 = -2.0;

// Reinterpret the 32 bits of the float as a 32-bit unsigned integer.
// The result is not 2, but the integer value of the float&#39;s bit pattern.
let my_packed_int: u32 = bitcast&lt;u32&gt;(my_float);

// You could now store this integer in a buffer that only accepts integers.
// To retrieve it, you would bitcast back:
let my_unpacked_float = bitcast&lt;f32&gt;(my_packed_int); // Restores -2.0
</code></pre><h4 id="overloads-packing-and-unpacking-f16">Overloads: Packing and Unpacking (<code>f16</code>)</h4><p>This group of overloads reinterprets bits between types of different sizes but the same total bit-width. This is used for packing smaller <code>f16</code> values into larger 32-bit types and vice versa.</p><h5 id="signature-72">Signature</h5><ul><li><p><code>bitcast&lt;T&gt;(e: vec2&lt;f16&gt;) -&gt; T</code> (Pack two <code>f16</code> into one 32-bit value)</p></li><li><p><code>bitcast&lt;vec2&lt;f16&gt;&gt;(e: T) -&gt; vec2&lt;f16&gt;</code> (Unpack one 32-bit value into two <code>f16s</code>)</p></li><li><p><code>bitcast&lt;vec2&lt;T&gt;&gt;(e: vec4&lt;f16&gt;) -&gt; vec2&lt;T&gt;</code> (Pack four <code>f16</code> into two 32-bit values)</p></li><li><p><code>bitcast&lt;vec4&lt;f16&gt;&gt;(e: vec2&lt;T&gt;) -&gt; vec4&lt;f16&gt;</code> (Unpack two 32-bit values into four <code>f16s</code>)</p></li><li><p><code>T</code>: Can be <code>f32</code>, <code>i32</code>, or <code>u32</code>.</p></li></ul><h5 id="description-72">Description</h5><p>These overloads allow you to treat a block of memory as different types. For example, since an <code>f16</code> is 16 bits, two of them (<code>vec2&lt;f16&gt;</code>) occupy the same 32 bits of memory as a single <code>f32</code>. <code>bitcast</code> allows you to convert between these representations.</p><h5 id="use-case-62">Use Case</h5><p>Used for memory optimization, allowing you to store data with lower precision (<code>f16</code>) and unpack it to higher precision (<code>f32</code>) for calculations.</p><pre><code class="language-wgsl">// Imagine you have two f16 values representing UV coordinates.
let uvs_f16 = vec2&lt;f16&gt;(0.5, 0.25);

// You can pack them into a single u32 to save space in a storage buffer.
// The 32 bits of the u32 will now contain the 16 bits of the first f16
// and the 16 bits of the second f16.
let packed_uvs = bitcast&lt;u32&gt;(uvs_f16);

// Later, in another shader, you can unpack them to do math.
let unpacked_uvs = bitcast&lt;vec2&lt;f16&gt;&gt;(packed_uvs);

// And convert to f32 for high-precision calculations.
let uvs_f32 = vec2&lt;f32&gt;(unpacked_uvs);
</code></pre><h4 id="overload-identity-transform">Overload: Identity Transform</h4><p>This overload handles the case where the source and target types are the same.</p><h5 id="signature-73">Signature</h5><p><code>bitcast&lt;T&gt;(e: T) -&gt; T</code></p><ul><li><code>T</code>: A concrete numeric scalar or vector type (e.g., <code>f32</code>, <code>vec3&lt;i32&gt;</code>).</li></ul><h5 id="description-73">Description</h5><p>When the source type e and the target type <code>T</code> are identical, <code>bitcast</code> performs an <strong>identity transform</strong>. It simply returns the input value <code>e</code> without any modification.</p><p>While this has no effect on the value, it exists for language completeness and can be useful in generic, programmatic shader generation where the source and target types might sometimes be the same.</p><h5 id="use-case-63">Use Case</h5><pre><code class="language-wgsl">let my_val: f32 = 123.45;

// This is a valid operation, but it does nothing.
let same_val = bitcast&lt;f32&gt;(my_val); // `same_val` is also 123.45
</code></pre><h2 id="packing--unpacking-functions">Packing &amp; Unpacking Functions</h2><p>This family of functions provides a low-level way to optimize memory usage by converting multiple floating-point values into a single 32-bit unsigned integer (<code>u32</code>), and vice versa. This is a common and critical technique for efficiently storing vertex attributes or data in storage buffers.</p><p>The core idea is to reduce the precision of the data to a more compact format before storing it:</p><ul><li><strong>Packing</strong> functions take a vector of <code>f32</code> values and convert each component to a smaller representation (like a 16-bit float or an 8/16-bit normalized integer). The bits of these smaller components are then packed together into a single <code>u32</code>. This is a <strong>lossy</strong> conversion, as precision is intentionally discarded.</li><li><strong>Unpacking</strong> functions perform the reverse operation. They take a <code>u32</code>, split it into its smaller bit-chunks, and convert each chunk back into a <code>f32</code> value according to the specified format.</li></ul><p>These functions support several standard formats, including half-precision floats (<code>float</code>), unsigned normalized integers (<code>unorm</code> for values in the <code>[0.0, 1.0]</code> range like colors and UVs), and signed normalized integers (<code>snorm</code> for values in the <code>[-1.0, 1.0]</code> range like normals and tangents).</p><hr><h3 id="pack2x16float"><code>pack2x16float</code></h3><h4 id="signature-74">Signature</h4><p><code>pack2x16float(e: vec2&lt;f32&gt;) -&gt; u32</code></p><ul><li><code>e</code>: The input vector containing two 32-bit floats.</li></ul><h4 id="description-74">Description</h4><p>Packs two 32-bit floating-point values (<code>f32</code>) into a single 32-bit unsigned integer (<code>u32</code>).</p><p>The function performs this by converting each component of the input <code>vec2&lt;f32&gt;</code> to its nearest 16-bit half-precision representation (an <code>f16</code>). This is a <strong>lossy conversion</strong>, as the <code>f16</code> type has less precision and a smaller range than <code>f32</code>.</p><p>The 16 bits of the first component (<code>e.x</code>) are placed into the lower half (bits 0-15) of the resulting <code>u32</code>, and the 16 bits of the second component (e.y) are placed into the upper half (bits 16-31).</p><p>The input values must be within the representable range of an <code>f16</code> float. Providing a value that is too large, too small, or <code>NaN</code> will result in an error if the value is known at compile time, or an indeterminate <code>u32</code> value at runtime.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#pack2x16float-builtin"><code>pack2x16float</code></a></em></p><h4 id="use-case-64">Use Case</h4><p>This function is essential for memory optimization. It allows you to store data that does not require full 32-bit precision, such as texture coordinates, more compactly.</p><pre><code class="language-wgsl">// A pair of texture coordinates that don&#39;t need high precision.
let uvs_f32 = vec2&lt;f32&gt;(0.5, 0.25);

// Pack the two 32-bit floats into a single 32-bit integer.
let packed_uvs: u32 = pack2x16float(uvs_f32);

// The `packed_uvs` variable now holds both UV coordinates in just 32 bits,
// whereas the original `vec2&lt;f32&gt;` required 64 bits. This is highly useful
// for storing data compactly in storage buffers. The corresponding
// `unpack2x16float` function is used to reverse the operation.
</code></pre><h3 id="pack2x16snorm"><code>pack2x16snorm</code></h3><h4 id="signature-75">Signature</h4><p><code>pack2x16snorm(e: vec2&lt;f32&gt;) -&gt; u32</code></p><ul><li><code>e</code>: The input vector containing two <code>f32</code> values, typically in the range <code>[-1.0, 1.0]</code>.</li></ul><h4 id="description-75">Description</h4><p>Packs two 32-bit floating-point values into a single 32-bit unsigned integer, treating the inputs as “signed normalized” (<code>snorm</code>) numbers. This is the inverse operation of <a href="unpack2x16snorm"><code>unpack2x16snorm</code></a>.</p><p>The packing process works as follows for each component of the input <code>vec2&lt;f32&gt;</code>:</p><ol><li>The <code>f32</code> value is first clamped to the <code>[-1.0, 1.0]</code> range.</li><li>It is then scaled by <code>32767.0</code>.</li><li>The result is rounded to the nearest whole number.</li><li>This number is stored as a 16-bit two’s-complement signed integer.</li></ol><p>The 16 bits of the first component (<code>e.x</code>) are placed into the lower half (bits 0-15) of the resulting <code>u32</code>, and the 16 bits of the second component (<code>e.y</code>) are placed into the upper half (bits 16-31).</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#pack2x16snorm-builtin"><code>pack2x16snorm</code></a></em></p><h4 id="use-case-65">Use Case</h4><p>This function is used to compactly store data that naturally fits the <code>[-1.0, 1.0]</code> range, such as normal vectors or other signed directional data, saving significant memory.</p><pre><code class="language-wgsl">// A normal vector&#39;s x and y components. The z component is often omitted and
// reconstructed later to save even more space.
let normal_xy = vec2&lt;f32&gt;(0.707, -0.707);

// Pack the two 32-bit floats into a single 32-bit integer.
let packed_normal_xy: u32 = pack2x16snorm(normal_xy);

// The `packed_normal_xy` variable now holds both vector components in just 32 bits.
// This can be stored efficiently in a storage buffer or texture.
// The `unpack2x16snorm` function is used to reverse the operation.
</code></pre><h3 id="pack2x16unorm"><code>pack2x16unorm</code></h3><h4 id="signature-76">Signature</h4><p><code>pack2x16unorm(e: vec2&lt;f32&gt;) -&gt; u32</code></p><ul><li><code>e</code>: The input vector containing two <code>f32</code> values, typically in the range <code>[0.0, 1.0]</code>.</li></ul><h4 id="description-76">Description</h4><p>Packs two 32-bit floating-point values into a single 32-bit unsigned integer, treating the inputs as “unsigned normalized” (<code>unorm</code>) numbers. This is the inverse operation of <a href="#unpack2x16unorm"><code>unpack2x16unorm</code></a>.</p><p>The packing process works as follows for each component of the input <code>vec2&lt;f32&gt;</code>:</p><ol><li>The <code>f32</code> value is first clamped to the <code>[0.0, 1.0]</code> range.</li><li>It is then scaled by <code>65535.0</code>.</li><li>The result is rounded to the nearest whole number.</li><li>This number is stored as a 16-bit unsigned integer.</li></ol><p>The 16 bits of the first component (<code>e.x</code>) are placed into the lower half (bits 0-15) of the resulting <code>u32</code>, and the 16 bits of the second component (<code>e.y</code>) are placed into the upper half (bits 16-31).</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#pack2x16unorm-builtin"><code>pack2x16unorm</code></a></em></p><h4 id="use-case-66">Use Case</h4><p>This is the most common packing function for data that is naturally in the <code>[0.0, 1.0]</code> range, such as texture coordinates or HDR color components that have been tone-mapped.</p><pre><code class="language-wgsl">// A pair of texture coordinates.
let uvs = vec2&lt;f32&gt;(0.25, 0.75);

// Pack the two 32-bit floats into a single 32-bit integer.
let packed_uvs: u32 = pack2x16unorm(uvs);

// The `packed_uvs` variable now holds both UV coordinates in just 32 bits,
// saving half the memory compared to a vec2&lt;f32&gt;.
// The `unpack2x16unorm` function is used to reverse the operation.
</code></pre><h3 id="pack4x8snorm"><code>pack4x8snorm</code></h3><h4 id="signature-77">Signature</h4><p><code>pack4x8snorm(e: vec4&lt;f32&gt;) -&gt; u32</code></p><ul><li><code>e</code>: The input vector containing four <code>f32</code> values, typically in the range <code>[-1.0, 1.0]</code>.</li></ul><h4 id="description-77">Description</h4><p>Packs four 32-bit floating-point values into a single 32-bit unsigned integer, treating the inputs as “signed normalized” (<code>snorm</code>) numbers. This is the inverse operation of <a href="#unpack4x8snorm"><code>unpack4x8snorm</code></a>.</p><p>This function offers greater compression than the <code>pack2x16</code> variants, but with lower precision (8 bits per component, allowing for 256 discrete values). The packing process works as follows for each component of the input <code>vec4&lt;f32&gt;</code>:</p><ol><li>The <code>f32</code> value is first clamped to the <code>[-1.0, 1.0]</code> range.</li><li>It is then scaled by <code>127.0</code>.</li><li>The result is rounded to the nearest whole number.</li><li>This number is stored as an 8-bit two’s-complement signed integer.</li></ol><p>The four resulting 8-bit integers are then packed into the <code>u32</code> result:</p><ul><li><code>e.x</code> is placed in bits 0-7.</li><li><code>e.y</code> is placed in bits 8-15.</li><li><code>e.z</code> is placed in bits 16-23.</li><li><code>e.w</code> is placed in bits 24-31.</li></ul><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#pack4x8snorm-builtin"><code>pack4x8snorm</code></a></em></p><h4 id="use-case-67">Use Case</h4><p>This function is ideal for storing four-component data where each component is in the <code>[-1.0, 1.0]</code> range and high precision is not required. A common example is packing a tangent vector, which has an <code>xyz</code> direction and a <code>w</code> component for handedness.</p><pre><code class="language-wgsl">// A tangent vector for normal mapping.
// The .xyz is the direction, and .w is the handedness (-1.0 or 1.0).
let tangent = vec4&lt;f32&gt;(0.707, 0.0, 0.707, 1.0);

// Pack the four 32-bit floats into a single 32-bit integer.
let packed_tangent: u32 = pack4x8snorm(tangent);

// The `packed_tangent` variable now holds the entire tangent vector in
// just 32 bits, a 4x memory saving compared to the original vec4&lt;f32&gt;.
// This is very efficient for storing vertex attributes.
</code></pre><h3 id="pack4x8unorm"><code>pack4x8unorm</code></h3><h4 id="signature-78">Signature</h4><p><code>pack4x8unorm(e: vec4&lt;f32&gt;) -&gt; u32</code></p><ul><li><code>e</code>: The input vector containing four <code>f32</code> values, typically in the range <code>[0.0, 1.0]</code>.</li></ul><h4 id="description-78">Description</h4><p>Packs four 32-bit floating-point values into a single 32-bit unsigned integer, treating the inputs as “unsigned normalized” (<code>unorm</code>) numbers. This is the inverse operation of <a href="#unpack4x8unorm"><code>unpack4x8unorm</code></a>.</p><p>This function is one of the most common packing operations, as its format directly corresponds to the standard 8-bit RGBA color representation. The packing process works as follows for each component of the input <code>vec4&lt;f32&gt;</code>:</p><ol><li>The <code>f32</code> value is first clamped to the <code>[0.0, 1.0]</code> range.</li><li>It is then scaled by <code>255.0</code>.</li><li>The result is rounded to the nearest whole number.</li><li>This number is stored as an 8-bit unsigned integer.</li></ol><p>The four resulting 8-bit integers are then packed into the u32 result:</p><ul><li><code>e.x</code> (Red) is placed in bits 0-7.</li><li><code>e.y</code> (Green) is placed in bits 8-15.</li><li><code>e.z</code> (Blue) is placed in bits 16-23.</li><li><code>e.w</code> (Alpha) is placed in bits 24-31.</li></ul><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#pack4x8unorm-builtin"><code>pack4x8unorm</code></a></em></p><h4 id="use-case-68">Use Case</h4><p>This function is the standard method for packing a floating-point RGBA color into a single 32-bit integer, which is how colors are often stored in textures and buffers to save memory.</p><pre><code class="language-wgsl">// A standard RGBA color with floating-point components.
let my_color = vec4&lt;f32&gt;(1.0, 0.5, 0.25, 1.0); // An orange color

// Pack the four f32 components into a single u32.
let packed_color: u32 = pack4x8unorm(my_color);

// The `packed_color` now holds the entire color in 32 bits, a 4x memory saving.
// This integer value could be written directly to a texture format like `Rgba8Unorm`.
// For example, the resulting integer would be 4284901375u, which is
// 0xFF4080FF in hexadecimal (AABBGGRR in little-endian).
</code></pre><h3 id="unpack2x16float"><code>unpack2x16float</code></h3><h4 id="signature-79">Signature</h4><p><code>unpack2x16float(e: u32) -&gt; vec2&lt;f32&gt;</code></p><ul><li><code>e</code>: The input 32-bit unsigned integer containing the packed data.</li></ul><h4 id="description-79">Description</h4><p>Unpacks a single <code>u32</code> value into two 32-bit floating-point values (<code>f32</code>). This is the inverse operation of <a href="#pack2x16float"><code>pack2x16float</code></a>.</p><p>The unpacking process works as follows:</p><ol><li>The <code>u32</code> input <code>e</code> is split into two 16-bit chunks.</li><li>Each 16-bit chunk is interpreted as an IEEE-754 binary16 (half-precision float) value.</li><li>This 16-bit float value is then converted (promoted) to a full 32-bit <code>f32</code>.</li></ol><p>The two resulting <code>f32</code> values are placed into a <code>vec2&lt;f32&gt;</code>:</p><ul><li>Bits 0-15 of <code>e</code> become the first component of the result (<code>.x</code>).</li><li>Bits 16-31 of <code>e</code> become the second component (<code>.y</code>).</li></ul><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#unpack2x16float-builtin"><code>unpack2x16float</code></a></em></p><h4 id="use-case-69">Use Case</h4><p>This function is used to read and decode data that was previously packed with <a href="#pack2x16float"><code>pack2x16float</code></a> to save memory. It allows you to restore lower-precision data into a high-precision format suitable for calculations.</p><pre><code class="language-wgsl">// A u32 value received from a storage buffer, which contains packed UV coordinates.
let packed_uvs: u32 = ...;

// Unpack the u32 back into two f32s.
let unpacked_uvs: vec2&lt;f32&gt; = unpack2x16float(packed_uvs);

// Now `unpacked_uvs` is a standard vec2&lt;f32&gt; that can be used for
// texture sampling or other calculations. The precision of the unpacked
// values will be limited to that of the original f16 representation.
let color = textureSample(my_texture, my_sampler, unpacked_uvs);
</code></pre><h3 id="unpack2x16snorm"><code>unpack2x16snorm</code></h3><h4 id="signature-80">Signature</h4><p><code>unpack2x16snorm(e: u32) -&gt; vec2&lt;f32&gt;</code></p><ul><li><code>e</code>: The input 32-bit unsigned integer containing the packed data.</li></ul><h4 id="description-80">Description</h4><p>Unpacks a single <code>u32</code> value into two 32-bit floating-point values (<code>f32</code>), interpreting the packed data as “signed normalized” (<code>snorm</code>) numbers. This is the inverse operation of <a href="#pack2x16snorm"><code>pack2x16snorm</code></a>.</p><p>The process works as follows:</p><ol><li>The <code>u32</code> input e is split into two 16-bit chunks.</li><li>Each 16-bit chunk is interpreted as a two’s-complement signed integer, giving a value <code>v</code> in the range <code>[-32768, 32767]</code>.</li><li>This integer v is converted to a floating-point number in the range [-1.0, 1.0] by dividing it by <code>32767.0</code> and clamping the result at <code>-1.0</code>.</li></ol><ul><li>Bits 0-15 of e become the first component of the result (<code>.x</code>).</li><li>Bits 16-31 of e become the second component (<code>.y</code>).</li></ul><p>“Signed Normalized” (<code>snorm</code>) is a standard format for storing values that have a direction (like components of a normal vector) efficiently in an integer.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#unpack2x16snorm-builtin"><code>unpack2x16snorm</code></a></em></p><h4 id="use-case-70">Use Case</h4><p>This function is used to read and decode data that was previously packed with <a href="#pack2x16snorm"><code>pack2x16snorm</code></a> to save memory. It’s ideal for data that naturally fits the <code>[-1.0, 1.0]</code> range.</p><pre><code class="language-wgsl">// A u32 value received from a storage buffer, which contains a packed normal vector&#39;s x and y components.
let packed_normal_xy: u32 = ...;

// Unpack the u32 back into two f32s in the [-1.0, 1.0] range.
let unpacked_normal_xy: vec2&lt;f32&gt; = unpack2x16snorm(packed_normal_xy);

// Now the unpacked_normal_xy can be used in lighting calculations.
// For example, reconstructing the full 3D normal:
let normal_xy = unpacked_normal_xy;
let normal_z = sqrt(1.0 - saturate(dot(normal_xy, normal_xy)));
let full_normal = vec3&lt;f32&gt;(normal_xy, normal_z);
</code></pre><h3 id="unpack2x16unorm"><code>unpack2x16unorm</code></h3><h4 id="signature-81">Signature</h4><p><code>unpack2x16unorm(e: u32) -&gt; vec2&lt;f32&gt;</code></p><ul><li><code>e</code>: The input 32-bit unsigned integer containing the packed data.</li></ul><h4 id="description-81">Description</h4><p>Unpacks a single <code>u32</code> value into two 32-bit floating-point values (<code>f32</code>), interpreting the packed data as “unsigned normalized” (<code>unorm</code>) numbers. This is the inverse operation of <a href="#pack2x16unorm"><code>pack2x16unorm</code></a>.</p><p>The process works as follows:</p><ol><li>The <code>u32</code> input e is split into two 16-bit chunks.</li><li>Each 16-bit chunk is interpreted as an unsigned integer, giving a value v in the range <code>[0, 65535]</code>.</li><li>This integer <code>v</code> is converted to a floating-point number in the range <code>[0.0, 1.0]</code> by dividing it by <code>65535.0</code>.</li></ol><ul><li>Bits 0-15 of e become the first component of the result (<code>.x</code>).</li><li>Bits 16-31 of e become the second component (<code>.y</code>).</li></ul><p>“Unsigned Normalized” (<code>unorm</code>) is a standard format for storing values that have a natural <code>[0.0, 1.0]</code> range, such as texture coordinates or color channels.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#unpack2x16unorm-builtin"><code>unpack2x16unorm</code></a></em></p><h4 id="use-case-71">Use Case</h4><p>This function is used to read and decode data that was previously packed with <a href="#pack2x16unorm"><code>pack2x16unorm</code></a> to save memory. It’s the standard way to reconstruct 16-bit <code>unorm</code> data, like UV coordinates, into a format suitable for high-precision calculations.</p><pre><code class="language-wgsl">// A u32 value received from a storage buffer, which contains packed UV coordinates.
let packed_uvs: u32 = ...;

// Unpack the u32 back into two f32s in the [0.0, 1.0] range.
let unpacked_uvs: vec2&lt;f32&gt; = unpack2x16unorm(packed_uvs);

// Now `unpacked_uvs` is a standard vec2&lt;f32&gt; that can be used for
// texture sampling or other calculations.
let color = textureSample(my_texture, my_sampler, unpacked_uvs);```

---
</code></pre><h3 id="unpack4x8snorm"><code>unpack4x8snorm</code></h3><h4 id="signature-82">Signature</h4><p><code>unpack4x8snorm(e: u32) -&gt; vec4&lt;f32&gt;</code></p><ul><li><code>e</code>: The input 32-bit unsigned integer containing the packed data.</li></ul><h4 id="description-82">Description</h4><p>Unpacks a single <code>u32</code> value into four 32-bit floating-point values (<code>f32</code>), interpreting the packed data as “signed normalized” (<code>snorm</code>) numbers. This is the inverse operation of <a href="#pack4x8snorm"><code>pack4x8snorm</code></a>.</p><p>The process works as follows:</p><ol><li>The <code>u32</code> input e is split into four 8-bit chunks.</li><li>Each 8-bit chunk is interpreted as a two’s-complement signed integer, giving a value <code>v</code> in the range <code>[-128, 127]</code>.</li><li>This integer <code>v</code> is converted to a floating-point number in the range <code>[-1.0, 1.0]</code> by dividing it by <code>127.0</code> and clamping the result at <code>-1.0</code>.</li></ol><p>The four resulting <code>f32</code> values are placed into a <code>vec4&lt;f32&gt;</code>:</p><ul><li>Bits 0-7 of <code>e</code> become the first component (<code>.x</code>).</li><li>Bits 8-15 of <code>e</code> become the second component (<code>.y</code>).</li><li>Bits 16-23 of <code>e</code> become the third component (<code>.z</code>).</li><li>Bits 24-31 of <code>e</code> become the fourth component (<code>.w</code>).</li></ul><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#unpack4x8snorm-builtin"><code>unpack4x8snorm</code></a></em></p><h4 id="use-case-72">Use Case</h4><p>This function is used to read and decode four-component data, like tangent vectors, that were previously packed with <a href="#pack4x8snorm"><code>pack4x8snorm</code></a> to save memory.</p><pre><code class="language-wgsl">// A u32 value received as a vertex attribute, containing a packed tangent vector.
let packed_tangent: u32 = ...;

// Unpack the u32 back into four f32s in the [-1.0, 1.0] range.
let unpacked_tangent: vec4&lt;f32&gt; = unpack4x8snorm(packed_tangent);

// Now `unpacked_tangent` is a standard vec4&lt;f32&gt; that can be used
// to build the TBN matrix for normal mapping.
let tangent_direction = unpacked_tangent.xyz;
let tangent_handedness = unpacked_tangent.w;
</code></pre><h3 id="unpack4x8unorm"><code>unpack4x8unorm</code></h3><h4 id="signature-83">Signature</h4><p><code>unpack4x8unorm(e: u32) -&gt; vec4&lt;f32&gt;</code></p><ul><li><code>e</code>: The input 32-bit unsigned integer containing the packed data.</li></ul><h4 id="description-83">Description</h4><p>Unpacks a single <code>u32</code> value into four 32-bit floating-point values (<code>f32</code>), interpreting the packed data as “unsigned normalized” (<code>unorm</code>) numbers. This is the inverse operation of <a href="#pack4x8unorm"><code>pack4x8unorm</code></a>.</p><p>This is a very common operation, as it directly corresponds to decoding a standard 32-bit RGBA color. The process works as follows:</p><ol><li>The <code>u32</code> input e is split into four 8-bit chunks.</li><li>Each 8-bit chunk is interpreted as an unsigned integer, giving a value <code>v</code> in the range <code>[0, 255]</code>.</li><li>This integer <code>v</code> is converted to a floating-point number in the range <code>[0.0, 1.0]</code> by dividing it by <code>255.0</code>.</li></ol><p>The four resulting <code>f32</code> values are placed into a <code>vec4&lt;f32&gt;</code>:</p><ul><li>Bits 0-7 of <code>e</code> become the first component (<code>.x</code>, Red).</li><li>Bits 8-15 of <code>e</code> become the second component (<code>.y</code>, Green).</li><li>Bits 16-23 of <code>e</code> become the third component (<code>.z</code>, Blue).</li><li>Bits 24-31 of <code>e</code> become the fourth component (<code>.w</code>, Alpha).</li></ul><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#unpack4x8unorm-builtin"><code>unpack4x8unorm</code></a></em></p><h4 id="use-case-73">Use Case</h4><p>This is the standard function for converting a color from its compact 32-bit integer representation (as found in <code>Rgba8Unorm</code> textures or buffers) into the <code>vec4&lt;f32&gt;</code> format required for high-precision color calculations.</p><pre><code class="language-wgsl">// A u32 value representing an orange color (R=255, G=128, B=64, A=255).
// In hex, this is 0xFF4080FF (AABBGGRR in little-endian).
// The corresponding u32 literal is 4282589439u.
let packed_color: u32 = 4282589439u;

// Unpack the u32 back into a vec4&lt;f32&gt; color in the [0.0, 1.0] range.
let unpacked_color: vec4&lt;f32&gt; = unpack4x8unorm(packed_color);

// The result is approximately vec4&lt;f32&gt;(1.0, 0.5019, 0.2509, 1.0).
// This color can now be used in lighting calculations, blended, etc.
</code></pre><h2 id="texture-functions">Texture Functions</h2><p>This family of functions is the primary interface for all interactions with texture objects in WGSL. These powerful functions can be broadly divided into three main purposes: reading texel data, writing to special storage textures, and querying a texture’s properties.</p><p>A fundamental concept within this group is the distinction between <strong>sampling</strong> and <strong>loading</strong>.</p><ul><li><strong>Sampling</strong> (e.g., using <code>textureSample</code> and its variants) is a complex operation. It uses a <code>sampler</code> object to apply filtering (like linear interpolation), wrapping (like repeating), and automatic mipmap selection, all based on floating-point coordinates (typically UVs).</li><li><strong>Loading</strong> (using <code>textureLoad</code>) is a direct, unfiltered read. It uses integer texel coordinates to fetch the exact data from a specific location in the texture’s memory, bypassing the sampler entirely.</li></ul><p>Additionally, this category includes functions to query a texture’s metadata (like its dimensions and layer count), as well as highly specialized functions for advanced techniques like custom shadow filtering and writing output from compute shaders.</p><h3 id="texturedimensions"><code>textureDimensions</code></h3><p>Returns the dimensions (width, height, depth) of a texture in texels. This function has several overloads depending on the texture’s type and whether you are querying the base size or the size of a specific mipmap level.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#texturedimensions"><code>textureDimensions</code></a></em></p><h4 id="overloads-1d-textures">Overloads: 1D Textures</h4><p>These overloads return a single u32 representing the width of a 1D texture.</p><h5 id="signature-84">Signature</h5><ul><li><p><code>textureDimensions(t: texture_1d&lt;T&gt;) -&gt; u32</code></p></li><li><p><code>textureDimensions(t: texture_storage_1d&lt;F,A&gt;) -&gt; u32</code></p></li><li><p><code>textureDimensions(t: texture_1d&lt;T&gt;, level: u32) -&gt; u32</code></p></li><li><p><code>T</code>: The 1D texture type, can be <code>texture_1d&lt;ST&gt;</code> or <code>texture_storage_1d&lt;F,A&gt;</code>.</p></li><li><p><code>ST</code>: The stored texel type for a sampled texture (<code>f32</code>, <code>i32</code>, or <code>u32</code>).</p></li><li><p><code>F</code>: The texel format for a storage texture (e.g., <code>rgba8unorm</code>).</p></li><li><p><code>A</code>: The access mode for a storage texture (<code>read</code>, <code>write</code>, or <code>read_write</code>).</p></li><li><p><code>level</code> / <code>L</code>: An optional <code>i32</code> or <code>u32</code> specifying the mipmap level to query.</p></li></ul><h5 id="description-84">Description</h5><p>Returns the width, in texels, of the 1D texture. If the optional <code>level</code> parameter is provided, it returns the width of that specific mipmap level; otherwise, it returns the width of the base level (level 0).</p><h5 id="use-case-74">Use Case</h5><pre><code class="language-wgsl">@group(0) @binding(0) var my_texture: texture_1d&lt;f32&gt;;

let width_level_0 = textureDimensions(my_texture);
let width_level_1 = textureDimensions(my_texture, 1u); // Half of level 0
</code></pre><h4 id="overloads-2d-textures">Overloads: 2D Textures</h4><p>These overloads return a <code>vec2&lt;u32&gt;</code> representing the width and height of a 2D texture, texture array, or cube map face.</p><h5 id="signature-85">Signature</h5><ul><li><code>textureDimensions(t: T) -&gt; vec2&lt;u32&gt;</code></li><li><code>textureDimensions(t: T, level: u32) -&gt; vec2&lt;u32&gt;</code></li><li><code>T</code>: A 2D-based texture type (see list below).</li><li><code>level</code> / <code>L</code>: An optional <code>i32</code> or <code>u32</code> specifying the mipmap level.</li></ul><p><code>T</code> can be one of many 2D-based texture types:</p><ul><li><code>texture_2d&lt;ST&gt;</code>, <code>texture_2d_array&lt;ST&gt;</code></li><li><code>texture_cube&lt;ST&gt;</code>, <code>texture_cube_array&lt;ST&gt;</code></li><li><code>texture_multisampled_2d&lt;ST&gt;</code></li><li><code>texture_depth_2d</code>, <code>texture_depth_2d_array</code></li><li><code>texture_depth_cube</code>, <code>texture_depth_cube_array</code></li><li><code>texture_depth_multisampled_2d</code></li><li><code>texture_storage_2d&lt;F,A&gt;</code>, <code>texture_storage_2d_array&lt;F,A&gt;</code></li><li><code>texture_external</code></li></ul><h5 id="description-85">Description</h5><p>Returns the width and height, in texels, of the 2D texture. If the optional <code>level</code> parameter is provided, it returns the dimensions of that specific mipmap level; otherwise, it returns the dimensions of the base level (level 0). For cube maps, this returns the dimensions of a single face (which are always square).</p><h5 id="use-case-75">Use Case</h5><p>The most common use is to convert pixel coordinates into UV coordinates (<code>[0.0, 1.0]</code>), which is essential for screen-space effects.</p><pre><code class="language-wgsl">@group(0) @binding(0) var screen_texture: texture_2d&lt;f32&gt;;

// `in.position` is the fragment&#39;s pixel coordinate (e.g., from 0 to 1920).
let screen_coords = vec2&lt;f32&gt;(in.position.xy);

// Get the full size of the texture.
let tex_dims = vec2&lt;f32&gt;(textureDimensions(screen_texture));

// Divide the pixel coordinate by the total size to get the UV coordinate.
let screen_uv = screen_coords / tex_dims;
</code></pre><h4 id="overloads-3d-textures">Overloads: 3D Textures</h4><p>These overloads return a <code>vec3&lt;u32&gt;</code> representing the width, height, and depth of a 3D texture.</p><h5 id="signature-86">Signature</h5><ul><li><p><code>textureDimensions(t: texture_3d&lt;T&gt;) -&gt; vec3&lt;u32&gt;</code></p></li><li><p><code>textureDimensions(t: texture_storage_3d&lt;F,A&gt;) -&gt; vec3&lt;u32&gt;</code></p></li><li><p><code>textureDimensions(t: texture_3d&lt;T&gt;, level: u32) -&gt; vec3&lt;u32&gt;</code></p></li><li><p><code>T</code>: The 3D texture type, can be <code>texture_3d&lt;ST&gt;</code> or <code>texture_storage_3d&lt;F,A&gt;</code>.</p></li><li><p><code>ST</code>: The stored texel type for a sampled texture (<code>f32</code>, <code>i32</code>, or <code>u32</code>).</p></li><li><p><code>F</code>: The texel format for a storage texture (e.g., <code>rgba8unorm</code>).</p></li><li><p><code>A</code>: The access mode for a storage texture (<code>read</code>, <code>write</code>, or <code>read_write</code>).</p></li><li><p><code>level</code> / <code>L</code>: An optional <code>i32</code> or <code>u32</code> specifying the mipmap level.</p></li></ul><h5 id="description-86">Description</h5><p>Returns the width, height, and depth, in texels, of the 3D texture. If the optional <code>level</code> parameter is provided, it returns the dimensions of that specific mipmap level; otherwise, it returns the dimensions of the base level (level 0).</p><h5 id="use-case-76">Use Case</h5><pre><code class="language-wgsl">@group(0) @binding(0) var my_3d_texture: texture_3d&lt;f32&gt;;

// Get the volume dimensions of the base mip level.
let volume_dims = textureDimensions(my_3d_texture);
</code></pre><h4 id="parameter-details--behavior">Parameter Details &amp; Behavior</h4><ul><li><strong><code>level</code> Parameter:</strong> When you provide the <code>level</code> parameter, you are querying the size of a specific mipmap. If the provided <code>level</code> is outside the valid range of mipmap levels for the texture, the function may return an indeterminate value.</li><li><strong>What is Returned:</strong> The function returns the logical dimensions of a single image in the texture. It does <strong>not</strong> include the number of layers in a texture array or the number of samples in a multisampled texture. For those, you must use <code>textureNumLayers</code> and <code>textureNumSamples</code> respectively.</li></ul><h3 id="texturegather"><code>textureGather</code></h3><p>Samples the four texels that would be used for bilinear filtering and returns their values directly in a <code>vec4</code>. This is a low-level operation primarily used for implementing custom texture filtering, most notably Percentage-Closer Filtering (PCF) for high-quality shadow mapping.</p><p>Instead of blending the four texels into a single color like <a href="#texturesample"><code>textureSample</code></a>, <code>textureGather</code> gives you the raw data from a specific channel of those four texels, allowing you to perform your own manual interpolation or comparison.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#texturegather"><code>textureGather</code></a></em></p><h4 id="overloads-colordata-textures-component-required">Overloads: Color/Data Textures (<code>component</code> required)</h4><p>This family of overloads is used for standard color or data textures (<code>texture_2d</code>, <code>texture_cube</code>, etc.).</p><h5 id="signature-87">Signature</h5><p><code>textureGather(component: C, t: TextureType, s: sampler, coords: VecType, ...)</code></p><ul><li><code>component</code>: A compile-time constant <code>i32</code> or <code>u32</code> (0, 1, 2, or 3) that specifies which channel to gather from the four source texels (0=R, 1=G, 2=B, 3=A).</li><li><code>t</code>: A color/data texture type, such as <code>texture_2d&lt;f32&gt;</code>, <code>texture_2d_array&lt;u32&gt;</code>, or <code>texture_cube&lt;i32&gt;</code>.</li><li><code>s</code>: A <code>sampler</code>.</li><li><code>coords</code>: The coordinates for sampling (<code>vec2&lt;f32&gt;</code> for 2D, <code>vec3&lt;f32&gt;</code> for cubes).</li><li>…: Optional or required parameters depending on the texture type, such as <code>array_index</code> or <code>offset</code>.</li></ul><h5 id="description-87">Description</h5><p>Finds the 2x2 block of texels that surround the given <code>coords</code>. It then extracts the value of the specified component from each of these four texels and returns them in a <code>vec4</code>.</p><p>For example, if <code>component</code> is <code>1</code> (the Green channel):</p><ul><li>The result’s <code>.x</code> component will be the Green value of the top-left texel.</li><li>The result’s <code>.y</code> component will be the Green value of the top-right texel.</li><li>The result’s <code>.z</code> component will be the Green value of the bottom-left texel.</li><li>The result’s <code>.w</code> component will be the Green value of the bottom-right texel.</li></ul><h5 id="use-case-77">Use Case</h5><p>Used for custom filtering algorithms that need to operate on a single channel of neighboring texels.</p><pre><code class="language-wgsl">@group(0) @binding(0) var my_texture: texture_2d&lt;f32&gt;;
@group(0) @binding(1) var my_sampler: sampler;

// Gather the values from the RED channel (component 0) of the four
// texels surrounding the given UV coordinate.
let red_values: vec4&lt;f32&gt; = textureGather(0, my_texture, my_sampler, in.uv);

// Now we have the raw red values and can perform custom logic,
// for example, finding the average red value in the 2x2 block.
let avg_red = (red_values.x + red_values.y + red_values.z + red_values.w) * 0.25;
</code></pre><h4 id="overloads-depth-textures">Overloads: Depth Textures</h4><p>This family of overloads is used specifically for depth textures.</p><h5 id="signature-88">Signature</h5><p><code>textureGather(t: DepthTextureType, s: sampler, coords: VecType, ...)</code></p><ul><li><code>t</code>: A depth texture type, such as <code>texture_depth_2d</code> or <code>texture_depth_cube_array</code>.</li><li><code>s</code>: A <code>sampler</code>.</li><li><code>coords</code>: The coordinates for sampling (<code>vec2&lt;f32&gt;</code> for 2D, <code>vec3&lt;f32&gt;</code> for cubes).</li><li>…: Optional or required parameters depending on the texture type, such as <code>array_index</code> or <code>offset</code>.</li></ul><h5 id="description-88">Description</h5><p>Finds the 2x2 block of texels that surround the given coords in a depth texture. It returns a <code>vec4&lt;f32&gt;</code> where each component contains the raw depth value from one of the four texels.</p><p>Unlike the color version, there is no <code>component</code> parameter, as depth textures only have a single channel.</p><h5 id="use-case-78">Use Case</h5><p>This is the cornerstone of custom shadow mapping algorithms like PCF.</p><pre><code class="language-wgsl">@group(0) @binding(0) var shadow_map: texture_depth_2d;
@group(0) @binding(1) var shadow_sampler: sampler;

let fragment_depth: f32 = ...; // The current fragment&#39;s depth from the light&#39;s perspective

// Gather the four closest depth values from the shadow map.
let shadow_depths: vec4&lt;f32&gt; = textureGather(shadow_map, shadow_sampler, in.shadow_coords);

// Manually compare the current fragment&#39;s depth to the four stored depths.
// The result of `&gt;` is a boolean vector.
let comparison = vec4&lt;f32&gt;(fragment_depth &gt; shadow_depths);

// Average the results to get a soft shadow value (0.0 to 1.0).
let shadow_factor = dot(comparison, vec4&lt;f32&gt;(0.25));
</code></pre><h3 id="texturegathercompare"><code>textureGatherCompare</code></h3><p>Performs a hardware-accelerated depth comparison against a 2x2 block of texels from a depth texture. This is a highly specialized and optimized function designed almost exclusively for implementing high-quality, soft shadows with Percentage-Closer Filtering (PCF).</p><p>It combines the “gather” step of <a href="#texturegather"><code>textureGather</code></a> and a subsequent comparison step into a single, efficient hardware operation.</p><h4 id="signatures">Signatures</h4><p>The function is overloaded for various depth texture types.</p><ul><li><p><code>textureGatherCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2&lt;f32&gt;, depth_ref: f32, ...)</code></p></li><li><p><code>textureGatherCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2&lt;f32&gt;, array_index: u32, depth_ref: f32, ...)</code></p></li><li><p><code>textureGatherCompare(t: texture_depth_cube, s: sampler_comparison, coords: vec3&lt;f32&gt;, depth_ref: f32, ...)</code></p></li><li><p><code>textureGatherCompare(t: texture_depth_cube_array, s: sampler_comparison, coords: vec3&lt;f32&gt;, array_index: u32, depth_ref: f32, ...)</code></p></li><li><p><code>t</code>: The depth texture to sample.</p></li><li><p><code>s</code>: A <code>sampler_comparison</code>. This special <code>sampler</code> type is configured on the CPU side with a comparison function (e.g., <code>LessEqual</code>, <code>Greater</code>).</p></li><li><p><code>coords</code>: The coordinates for sampling (<code>vec2&lt;f32&gt;</code> for 2D, <code>vec3&lt;f32&gt;</code> for cubes).</p></li><li><p><code>depth_ref</code>: The depth value to compare against the values in the texture.</p></li><li><p>…: Optional offset can be provided for some texture types.</p></li></ul><h4 id="description-89">Description</h4><p>This function executes a complete, optimized shadow-PCF step in hardware:</p><ol><li>It identifies the 2x2 quad of texels in the depth texture that surround the given <code>coords</code>.</li><li>For each of those four texels, it performs a comparison between the provided <code>depth_ref</code> and the depth value stored in the texel.</li><li>The specific comparison operation (e.g., <code>depth_ref &lt;= texel_depth</code>) is determined by the <code>compare</code> property of the <code>sampler_comparison</code> object, which is set in your Rust code.</li><li>It returns a <code>vec4&lt;f32&gt;</code> where each component is either <code>1.0</code> (if the comparison passed) or <code>0.0</code> (if it failed).</li></ol><p>The result is a vector containing four binary pass/fail results, ready to be averaged for a soft shadow effect.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#texturegathercompare"><code>textureGatherCompare</code></a></em></p><h4 id="use-case-79">Use Case</h4><p>The sole purpose of this function is to implement PCF for soft shadows efficiently. It is significantly faster than using a manual <a href="#texturegather"><code>textureGather</code></a> followed by a comparison in the shader code.</p><pre><code class="language-wgsl">@group(0) @binding(0) var shadow_map: texture_depth_2d;
@group(0) @binding(1) var shadow_sampler: sampler_comparison;

// The current fragment&#39;s depth from the light&#39;s perspective.
let fragment_depth_ref: f32 = ...;

// The hardware performs the gather and four comparisons in one go.
// The result is already a vector of 0.0s and 1.0s.
let comparison_results: vec4&lt;f32&gt; = textureGatherCompare(
    shadow_map,
    shadow_sampler,
    in.shadow_coords,
    fragment_depth_ref
);

// Average the four pass/fail results to get a smooth shadow value.
// If all four tests passed (fragment is not in shadow), the result is 1.0.
// If two passed, the result is 0.5 (a penumbra).
// If none passed, the result is 0.0 (fully shadowed).
let shadow_factor = dot(comparison_results, vec4&lt;f32&gt;(0.25));
</code></pre><h3 id="textureload"><code>textureLoad</code></h3><p>Fetches the unfiltered data for a single texel from a texture using integer texel coordinates.</p><p>This function is fundamentally different from <a href="#texturesample"><code>textureSample</code></a>:</p><ul><li>It uses <strong>integer coordinates</strong> (e.g., <code>(10, 20)</code>) to specify an exact texel, not floating-point UVs (<code>[0.0, 1.0]</code>).</li><li>It <strong>does not use a sampler</strong>. There is no filtering (bilinear, trilinear) or wrapping.</li><li>For mipmapped textures, you must explicitly provide the mipmap <strong>level</strong> to read from.</li></ul><p>It is a direct, unfiltered read from a specific location in the texture’s memory.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#textureload"><code>textureLoad</code></a></em></p><h4 id="overloads-standard-mipmapped-textures">Overloads: Standard (Mipmapped) Textures</h4><p>This is the most common family of overloads for reading from standard 1D, 2D, 3D, and array textures.</p><h5 id="signatures-1">Signatures</h5><ul><li><p><code>textureLoad(t: texture_1d&lt;ST&gt;, coords: u32, level: u32) -&gt; vec4&lt;ST&gt;</code></p></li><li><p><code>textureLoad(t: texture_2d&lt;ST&gt;, coords: vec2&lt;u32&gt;, level: u32) -&gt; vec4&lt;ST&gt;</code></p></li><li><p><code>textureLoad(t: texture_2d_array&lt;ST&gt;, coords: vec2&lt;u32&gt;, array_index: u32, level: u32) -&gt; vec4&lt;ST&gt;</code></p></li><li><p><code>textureLoad(t: texture_3d&lt;ST&gt;, coords: vec3&lt;u32&gt;, level: u32) -&gt; vec4&lt;ST&gt;</code></p></li><li><p><code>ST</code>: The stored texel type (<code>f32</code>, <code>i32</code>, or <code>u32</code>).</p></li><li><p><code>coords</code> / <code>C</code>: The integer texel coordinates. Can be <code>i32</code> or <code>u32</code> (or a vector of them).</p></li><li><p><code>level</code> / <code>L</code>: The integer mipmap level. Can be <code>i32</code> or <code>u32</code>.</p></li><li><p><code>array_index</code> / <code>A</code>: The integer array layer. Can be <code>i32</code> or <code>u32</code>.</p></li></ul><h5 id="description-90">Description</h5><p>Reads the texel data from the specified integer <code>coords</code> within a specific <code>array_index</code> (for array textures) and mipmap <code>level</code>. The <code>coords</code> are 0-indexed from the top-left corner of the specified mip level.</p><h5 id="use-case-80">Use Case</h5><p>Ideal for situations where you need precise, unfiltered data, such as reading from a data texture or manually implementing a custom filtering algorithm.</p><pre><code class="language-wgsl">@group(0) @binding(0) var data_texture: texture_2d&lt;f32&gt;;

// Read the exact texel value from coordinate (5, 10) on the second mipmap level.
// There is no blending or interpolation with neighboring texels.
let texel_data = textureLoad(data_texture, vec2&lt;u32&gt;(5u, 10u), 1u);
</code></pre><h4 id="overloads-multisampled-textures">Overloads: Multisampled Textures</h4><p>This family of overloads reads from multisampled textures, which store multiple data samples per texel.</p><h5 id="signatures-2">Signatures</h5><ul><li><p><code>textureLoad(t: texture_multisampled_2d&lt;ST&gt;, coords: vec2&lt;u32&gt;, sample_index: u32) -&gt; vec4&lt;ST&gt;</code></p></li><li><p><code>textureLoad(t: texture_depth_multisampled_2d, coords: vec2&lt;u32&gt;, sample_index: u32) -&gt; f32</code></p></li><li><p><code>ST</code>: The stored texel type (<code>f32</code>, <code>i32</code>, or <code>u32</code>).</p></li><li><p><code>coords</code> / <code>C</code>: The integer texel coordinates. Can be <code>i32</code> or <code>u32</code> (or a vector of them).</p></li><li><p><code>sample_index</code> / <code>S</code>: The integer sample index. Can be <code>i32</code> or <code>u32</code>.</p></li></ul><h5 id="description-91">Description</h5><p>Reads the data from a single <code>sample_index</code> within the texel at the specified integer <code>coords</code>. Multisampled textures do not have mipmaps, so there is no <code>level</code> parameter.</p><h5 id="use-case-81">Use Case</h5><p>Used to manually “resolve” a multisampled texture, for example, by averaging all the samples for a given pixel to produce a final anti-aliased color.</p><pre><code class="language-wgsl">@group(0) @binding(0) var msaa_texture: texture_multisampled_2d&lt;f32&gt;;

let texel_coords = vec2&lt;u32&gt;(in.position.xy);
let num_samples = textureNumSamples(msaa_texture);
var final_color = vec4&lt;f32&gt;(0.0);

// Loop through all samples for the current pixel and average them.
for (var i: u32 = 0u; i &lt; num_samples; i = i + 1u) {
    final_color = final_color + textureLoad(msaa_texture, texel_coords, i);
}
final_color = final_color / f32(num_samples);
</code></pre><h4 id="overloads-depth-textures-1">Overloads: Depth Textures</h4><p>This family of overloads reads a single depth value from a depth texture.</p><h5 id="signatures-3">Signatures</h5><ul><li><p><code>textureLoad(t: texture_depth_2d, coords: vec2&lt;u32&gt;, level: u32) -&gt; f32</code></p></li><li><p><code>textureLoad(t: texture_depth_2d_array, coords: vec2&lt;u32&gt;, array_index: u32, level: u32) -&gt; f32</code></p></li><li><p><code>coords</code> / <code>C</code>: The integer texel coordinates. Can be <code>i32</code> or <code>u32</code> (or a vector of them).</p></li><li><p><code>level</code> / <code>L</code>: The integer mipmap level. Can be <code>i32</code> or <code>u32</code>.</p></li><li><p><code>array_index</code> / <code>A</code>: The integer array layer. Can be <code>i32</code> or <code>u32</code>.</p></li></ul><h5 id="description-92">Description</h5><p>Reads the single depth value from the specified integer coords and mipmap level. The key difference is that the return type is a single <code>f32</code>, not a <code>vec4</code>.</p><h5 id="use-case-82">Use Case</h5><p>Used to fetch a precise, unfiltered depth value, which is useful in some custom shadow or post-processing techniques.</p><pre><code class="language-wgsl">@group(0) @binding(0) var depth_texture: texture_depth_2d;

// Get the exact depth value stored at texel (100, 200) on mip level 0.
let precise_depth = textureLoad(depth_texture, vec2&lt;u32&gt;(100u, 200u), 0u);
</code></pre><h4 id="behavior-with-invalid-coordinates">Behavior with Invalid Coordinates</h4><p>If the provided coords, <code>array_index</code>, <code>level</code>, or <code>sample_index</code> are outside the valid bounds of the texture, the address is considered invalid. In this case, the function’s return value is defined by the GPU implementation and may be one of the following:</p><ul><li>The data for a different texel that is within the texture’s bounds.</li><li>A vector of zeros <code>(0,0,0,0)</code> or <code>(0,0,0,1)</code> for color/data textures.</li><li><code>0.0</code> for depth textures.</li></ul><h3 id="texturenumlayers"><code>textureNumLayers</code></h3><h4 id="signature-89">Signature</h4><p><code>textureNumLayers(t: T) -&gt; u32</code></p><ul><li><code>t</code>: The input arrayed texture.</li></ul><p><code>T</code> must be an arrayed texture type:</p><ul><li><code>texture_2d_array&lt;ST&gt;</code></li><li><code>texture_cube_array&lt;ST&gt;</code></li><li><code>texture_depth_2d_array</code></li><li><code>texture_depth_cube_array</code></li><li><code>texture_storage_2d_array&lt;F,A&gt;</code></li></ul><h4 id="description-93">Description</h4><p>Returns the number of layers in an arrayed texture.</p><p>The meaning of a “layer” depends on the texture type:</p><ul><li>For a <code>texture_2d_array</code>, it returns the number of 2D texture layers in the array.</li><li>For a <code>texture_cube_array</code>, it returns the number of cubes in the array (where each cube itself consists of 6 faces/layers).</li></ul><p>This function is distinct from <a href="#texturedimensions"><code>textureDimensions</code></a>, which returns the width and height of a single layer.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#texturenumlayers"><code>textureNumLayers</code></a></em></p><h4 id="use-case-83">Use Case</h4><p>Used to query the size of a texture array, which is often necessary for looping through all the layers or for clamping an array index to be within a valid range.</p><pre><code class="language-wgsl">@group(0) @binding(0) var my_texture_array: texture_2d_array&lt;f32&gt;;

// Get the total number of layers available in the texture array.
let total_layers = textureNumLayers(my_texture_array);

// This can be used as the upper bound for a loop.
for (var i: u32 = 0u; i &lt; total_layers; i = i + 1u) {
    // ... sample from layer `i` of the texture array ...
    let color = textureSample(my_texture_array, my_sampler, in.uv, i);
}

// Or it can be used to safely clamp a runtime index.
let some_runtime_index: u32 = ...;
let safe_index = min(some_runtime_index, total_layers - 1u);
</code></pre><h3 id="texturenumlevels"><code>textureNumLevels</code></h3><h4 id="signature-90">Signature</h4><p><code>textureNumLevels(t: T) -&gt; u32</code></p><ul><li><code>t</code>: The input mipmapped texture.</li></ul><p><code>T</code> must be a texture type that supports mipmaps:</p><ul><li><code>texture_1d&lt;ST&gt;</code></li><li><code>texture_2d&lt;ST&gt;</code>, <code>texture_2d_array&lt;ST&gt;</code></li><li><code>texture_3d&lt;ST&gt;</code></li><li><code>texture_cube&lt;ST&gt;</code>, <code>texture_cube_array&lt;ST&gt;</code></li><li><code>texture_depth_2d</code>, <code>texture_depth_2d_array</code></li><li><code>texture_depth_cube</code>, <code>texture_depth_cube_array</code></li></ul><h4 id="description-94">Description</h4><p>Returns the total number of mipmap levels available in the texture. Level 0 is the original, full-resolution texture, and subsequent levels are progressively smaller.</p><p>This function does not work with texture types that do not have mipmaps, such as <code>texture_storage_*</code> or <code>texture_multisampled_*</code>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#texturenumlevels"><code>textureNumLevels</code></a></em></p><h4 id="use-case-84">Use Case</h4><p>This function is useful for algorithms that need to manually iterate through mipmap levels, such as in some advanced post-processing or image analysis techniques.</p><pre><code class="language-wgsl">@group(0) @binding(0) var my_texture: texture_2d&lt;f32&gt;;

// Get the total number of mip levels.
let mip_count = textureNumLevels(my_texture);

// This can be used as the upper bound for a loop that processes
// each mipmap level of a texture.
var total_red_value = 0.0;
for (var i: u32 = 0u; i &lt; mip_count; i = i + 1u) {
    // Load a texel from the center of the current mip level.
    let mip_dims = textureDimensions(my_texture, i);
    let center_coord = mip_dims / 2u;
    total_red_value = total_red_value + textureLoad(my_texture, center_coord, i).r;
}
</code></pre><h3 id="texturenumsamples"><code>textureNumSamples</code></h3><h4 id="signature-91">Signature</h4><p><code>textureNumSamples(t: T) -&gt; u32</code></p><ul><li><code>t</code>: The input multisampled texture.</li><li><code>T</code> must be a multisampled texture type:<ul><li><code>texture_multisampled_2d&lt;ST&gt;</code></li><li><code>texture_depth_multisampled_2d</code></li></ul></li></ul><h4 id="description-95">Description</h4><p>Returns the number of samples stored for each texel in a multisampled texture. The result is typically a small power of two, such as 2, 4, or 8, depending on the MSAA (Multi-Sample Anti-Aliasing) level configured when the texture was created.</p><p>This function only works with multisampled textures. Attempting to use it on a non-multisampled texture will result in a shader compilation error.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#texturenumsamples"><code>textureNumSamples</code></a></em></p><h4 id="use-case-85">Use Case</h4><p>This function is essential for manually resolving a multisampled texture. “Resolving” is the process of combining the multiple samples within each texel into a single, final anti-aliased value.</p><pre><code class="language-wgsl">@group(0) @binding(0) var msaa_texture: texture_multisampled_2d&lt;f32&gt;;

// The integer coordinates of the texel to resolve.
let texel_coords = vec2&lt;u32&gt;(in.position.xy);

// Get the number of samples per texel (e.g., 4).
let sample_count = textureNumSamples(msaa_texture);

// A variable to accumulate the color from all samples.
var resolved_color = vec4&lt;f32&gt;(0.0);

// Loop through each sample, load its color, and add it to the total.
for (var i: u32 = 0u; i &lt; sample_count; i = i + 1u) {
    resolved_color = resolved_color + textureLoad(msaa_texture, texel_coords, i);
}

// Divide by the number of samples to get the final averaged color.
resolved_color = resolved_color / f32(sample_count);
</code></pre><h3 id="texturesample"><code>textureSample</code></h3><p>The primary and most common function for reading from a texture. It uses a sampler to apply filtering, wrapping, and automatic mipmap selection based on floating-point coordinates.</p><p>This function must be called in <strong>uniform control flow</strong> (i.e., not inside if statements or loops that depend on per-fragment data). If it is used inside a loop with a variable number of iterations or an if statement with a per-fragment condition, the result is an indeterminate value.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#texturesample"><code>textureSample</code></a></em></p><h4 id="overloads-colordata-textures">Overloads: Color/Data Textures</h4><h5 id="signature-92">Signature</h5><ul><li><p><code>textureSample(t: texture_1d&lt;f32&gt;, s: sampler, coords: f32) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSample(t: texture_2d&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSample(t: texture_2d&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSample(t: texture_2d_array&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSample(t: texture_2d_array&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSample(t: T, s: sampler, coords: vec3&lt;f32&gt;) -&gt; vec4&lt;f32&gt; where T is texture_3d&lt;f32&gt; or texture_cube&lt;f32&gt;</code></p></li><li><p><code>textureSample(t: texture_3d&lt;f32&gt;, s: sampler, coords: vec3&lt;f32&gt;, offset: vec3&lt;i32&gt;) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSample(t: texture_cube_array&lt;f32&gt;, s: sampler, coords: vec3&lt;f32&gt;, array_index: A) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>A</code> is <code>i32</code> or <code>u32</code>.</p></li><li><p><code>t</code>: The texture to be sampled.</p></li><li><p><code>s</code>: A <code>sampler</code> object that defines filtering and wrapping rules.</p></li><li><p><code>coords</code>: The floating-point coordinates for sampling (e.g., UVs for a <code>texture_2d</code>, or a direction vector for a <code>texture_cube</code>).</p></li><li><p><code>array_index</code>: The 0-indexed layer of the texture array to sample from.</p></li><li><p><code>offset</code>: An optional, compile-time constant integer vector that applies a texel offset before sampling.</p></li></ul><h5 id="description-96">Description</h5><p>Samples the texture <code>t</code> using the filtering and wrapping rules defined in the <code>sampler</code> <code>s</code>. The GPU automatically calculates the appropriate mipmap level based on the screen-space derivatives of the texture <code>coords</code>. The return value is a filtered <code>vec4&lt;f32&gt;</code> representing the color or data at that location.</p><h5 id="use-case-86">Use Case</h5><p>This is the standard function for applying a texture to a 3D model.</p><pre><code class="language-wgsl">@group(1) @binding(0) var my_texture: texture_2d&lt;f32&gt;;
@group(1) @binding(1) var my_sampler: sampler;

// The `in.uv` coordinate is a floating-point value from 0.0 to 1.0.
// The sampler handles blending between texels if coords fall between them.
let albedo_color = textureSample(my_texture, my_sampler, in.uv);
</code></pre><h4 id="overloads-depth-textures-2">Overloads: Depth Textures</h4><p>These overloads sample from a depth texture and return a single f32 depth value.</p><h5 id="signature-93">Signature</h5><ul><li><p><code>textureSample(t: texture_depth_2d, s: sampler, coords: vec2&lt;f32&gt;) -&gt; f32</code></p></li><li><p><code>textureSample(t: texture_depth_2d, s: sampler, coords: vec2&lt;f32&gt;, offset: vec2&lt;i32&gt;) -&gt; f32</code></p></li><li><p><code>textureSample(t: texture_depth_2d_array, s: sampler, coords: vec2&lt;f32&gt;, array_index: A) -&gt; f32</code></p></li><li><p><code>textureSample(t: texture_depth_2d_array, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, offset: vec2&lt;i32&gt;) -&gt; f32</code></p></li><li><p><code>textureSample(t: texture_depth_cube, s: sampler, coords: vec3&lt;f32&gt;) -&gt; f32</code></p></li><li><p><code>textureSample(t: texture_depth_cube_array, s: sampler, coords: vec3&lt;f32&gt;, array_index: A) -&gt; f32</code></p></li><li><p><code>A</code> is <code>i32</code> or <code>u32</code>.</p></li><li><p><code>t</code>: The depth texture to be sampled.</p></li><li><p><code>s</code>: A <code>sampler</code> object.</p></li><li><p><code>coords</code>: The floating-point coordinates for sampling.</p></li><li><p><code>array_index</code>: The 0-indexed layer of the texture array to sample from.</p></li><li><p><code>offset</code>: An optional, compile-time constant integer vector that applies a texel offset before sampling.</p></li></ul><h5 id="description-97">Description</h5><p>Samples the depth texture <code>t</code> using the <code>sampler</code> <code>s</code>. The return value is a single filtered <code>f32</code> representing the depth at that location.</p><h5 id="use-case-87">Use Case</h5><p>Used to read a filtered depth value, for example, to visualize a shadow map or for post-processing effects. For actual shadow comparisons, textureSampleCompare is usually preferred.</p><pre><code class="language-wgsl">@group(1) @binding(0) var shadow_map: texture_depth_2d;
@group(1) @binding(1) var my_sampler: sampler;

// Read the filtered depth value from the shadow map.
let sampled_depth = textureSample(shadow_map, my_sampler, in.shadow_coords);

// Visualize the depth map by converting the depth value to a grayscale color.
let shadow_map_color = vec4&lt;f32&gt;(vec3(sampled_depth), 1.0);
</code></pre><h4 id="parameters-and-behavior">Parameters and Behavior</h4><ul><li><strong><code>sampler</code>:</strong> An object defined in Rust code that controls how the texture is read. It specifies the filtering mode (e.g., nearest, linear), the wrapping mode (e.g., repeat, clamp-to-edge), and mipmapping behavior.</li><li><strong><code>coords</code>:</strong> The floating-point coordinates used for sampling. For 2D textures, this is typically a UV coordinate in the <code>[0.0, 1.0]</code> range. For cube maps, this is a 3D direction vector.</li><li><strong><code>offset</code>:</strong> An optional <code>vec2&lt;i32&gt;</code> or <code>vec3&lt;i32&gt;</code> parameter that must be a compile-time constant. It applies an integer texel offset to the coordinates before sampling.</li><li><strong>Uniform Control Flow:</strong> This function (and its variants like <code>textureSampleBias</code>) must be called in uniform control flow. If it is used inside a loop with a variable number of iterations or an <code>if</code> statement with a per-fragment condition, the result is an indeterminate value. For sampling in such situations, you must use <code>textureSampleLevel</code>.</li></ul><h3 id="texturesamplebaseclamptoedge"><code>textureSampleBaseClampToEdge</code></h3><h4 id="signature-94">Signature</h4><p><code>textureSampleBaseClampToEdge(t: T, s: sampler, coords: vec2&lt;f32&gt;) -&gt; vec4&lt;f32&gt;</code></p><ul><li><code>t</code>: The texture to sample.</li><li><code>T</code>: Must be <code>texture_2d&lt;f32&gt;</code> or <code>texture_external</code>.</li><li><code>s</code>: A <code>sampler</code>.</li><li><code>coords</code>: The <code>vec2&lt;f32&gt;</code> coordinates for sampling.</li></ul><h4 id="description-98">Description</h4><p>Samples a 2D texture, but with two specific and non-overridable behaviors:</p><ol><li>It <strong>always</strong> samples from the base mipmap level (level 0).</li><li>It <strong>always</strong> uses a <code>clamp-to-edge</code> wrapping mode for the coordinates, regardless of the wrapping mode configured in the <code>sampler</code>.</li></ol><p>The primary reason this function exists is to be the <strong>only</strong> sampling function that can operate on the special <code>texture_external</code> type. An external texture is a handle to an image produced by an external system, such as a video decoder, and has special restrictions. It cannot be sampled with the standard <code>textureSample</code> function.</p><p>While it can also be used on a regular <code>texture_2d&lt;f32&gt;</code>, its behavior in that case is equivalent to using <code>textureSampleLevel(..., 0.0)</code> with a sampler configured for <code>clamp-to-edge</code>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#textureSampleBaseClampToEdge"><code>textureSampleBaseClampToEdge</code></a></em></p><h4 id="use-case-88">Use Case</h4><p>The exclusive use case for this function is sampling from a <code>texture_external</code>, which is typically used for displaying video frames in a WebGPU context.</p><pre><code class="language-wgsl">// This binding would be provided by the browser when working with a video element.
@group(0) @binding(0) var video_frame: texture_external;
@group(0) @binding(1) var video_sampler: sampler;

// Use this special function to sample the video frame texture.
// Using `textureSample` here would result in a shader compilation error.
let video_color = textureSampleBaseClampToEdge(video_frame, video_sampler, in.uv);
</code></pre><h3 id="texturesamplebias"><code>textureSampleBias</code></h3><h4 id="signatures-4">Signatures</h4><ul><li><p><code>textureSampleBias(t: texture_2d&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, bias: f32) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSampleBias(t: texture_2d&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, bias: f32, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSampleBias(t: texture_2d_array&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, bias: f32) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSampleBias(t: texture_2d_array&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, bias: f32, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSampleBias(t: T, s: sampler, coords: vec3&lt;f32&gt;, bias: f32) -&gt; vec4&lt;f32&gt; where T is texture_3d&lt;f32&gt; or texture_cube&lt;f32&gt;</code></p></li><li><p><code>textureSampleBias(t: texture_3d&lt;f32&gt;, s: sampler, coords: vec3&lt;f32&gt;, bias: f32, offset: vec3&lt;i32&gt;) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSampleBias(t: texture_cube_array&lt;f32&gt;, s: sampler, coords: vec3&lt;f32&gt;, array_index: A, bias: f32) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>A</code> is <code>i32</code> or <code>u32</code>.</p></li><li><p><code>t</code>: The texture to be sampled.</p></li><li><p><code>s</code>: A sampler object that defines filtering and wrapping rules.</p></li><li><p><code>coords</code>: The floating-point coordinates for sampling (e.g., UVs for a <code>texture_2d</code>, or a direction vector for a <code>texture_cube</code>).</p></li><li><p><code>bias</code>: A floating-point value that provides a manual adjustment to the calculated mipmap level.</p></li><li><p><code>array_index</code>: The 0-indexed layer of the texture array to sample from.</p></li><li><p><code>offset</code>: An optional, compile-time constant integer vector (<code>vec2&lt;i32&gt;</code> or <code>vec3&lt;i32&gt;</code>) that applies a texel offset before sampling.</p></li></ul><h4 id="description-99">Description</h4><p>Samples a texture with a manual adjustment to the mipmap level selection. This function is identical to textureSample but adds a bias parameter that allows you to make the texture appear sharper or blurrier than it normally would. The function first calculates the ideal mipmap level based on the texture coordinate derivatives, then adds the floating-point <code>bias</code> value to it before sampling.</p><ul><li>A <strong>positive bias</strong> (<code>&gt; 0.0</code>) forces the GPU to sample from a smaller, more distant mipmap level, resulting in a <strong>blurrier</strong> appearance.</li><li>A <strong>negative bias</strong> (<code>&lt; 0.0</code>) forces the GPU to sample from a larger, closer mipmap level, resulting in a <strong>sharper</strong> appearance (which can also lead to aliasing).</li></ul><p>This function must be called in <strong>uniform control flow</strong> (i.e., not inside if statements or loops that depend on per-fragment data). If it is used inside a loop with a variable number of iterations or an if statement with a per-fragment condition, the result is an indeterminate value.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#texturesamplebias"><code>textureSampleBias</code></a></em></p><h4 id="use-case-89">Use Case</h4><p><code>textureSampleBias</code> is used for effects that require programmatic control over texture sharpness. A classic example is faking a depth-of-field effect or creating a “blur in” transition.</p><pre><code class="language-wgsl">@group(1) @binding(0) var scene_texture: texture_2d&lt;f32&gt;;
@group(1) @binding(1) var my_sampler: sampler;

let distance_from_camera: f32 = ...;
let focus_point = 10.0;

// Calculate a blur amount based on distance from the camera&#39;s focus point.
// Objects far from the focus point will get a larger positive bias.
let blur_bias = abs(distance_from_camera - focus_point) * 0.5;

// Sample the scene texture with the calculated bias.
// Distant or very close objects will appear blurry, while objects near
// the focus point will be sharp (bias ≈ 0.0).
let final_color = textureSampleBias(scene_texture, my_sampler, in.uv, blur_bias);
</code></pre><h3 id="texturesamplecompare"><code>textureSampleCompare</code></h3><h4 id="signature-95">Signature</h4><ul><li><p><code>textureSampleCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2&lt;f32&gt;, depth_ref: f32) -&gt; f32</code></p></li><li><p><code>textureSampleCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2&lt;f32&gt;, depth_ref: f32, offset: vec2&lt;i32&gt;) -&gt; f32</code></p></li><li><p><code>textureSampleCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2&lt;f32&gt;, array_index: A, depth_ref: f32) -&gt; f32</code></p></li><li><p><code>textureSampleCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2&lt;f32&gt;, array_index: A, depth_ref: f32, offset: vec2&lt;i32&gt;) -&gt; f32</code></p></li><li><p><code>textureSampleCompare(t: texture_depth_cube, s: sampler_comparison, coords: vec3&lt;f32&gt;, depth_ref: f32) -&gt; f32</code></p></li><li><p><code>textureSampleCompare(t: texture_depth_cube_array, s: sampler_comparison, coords: vec3&lt;f32&gt;, array_index: A, depth_ref: f32) -&gt; f32</code></p></li><li><p><code>A</code> is <code>i32</code> or <code>u32</code>.</p></li><li><p><code>t</code>: A depth texture to sample from.</p></li><li><p><code>s</code>: A <code>sampler_comparison</code> object. This special sampler type is configured on the CPU side with a specific comparison function (e.g., <code>LessEqual</code>, <code>Greater</code>).</p></li><li><p><code>coords</code>: The floating-point coordinates for sampling.</p></li><li><p><code>depth_ref</code>: The depth value to compare against the values in the texture.</p></li><li><p><code>array_index</code>: The 0-indexed layer of the texture array to sample from.</p></li><li><p><code>offset</code>: An optional, compile-time constant integer vector (<code>vec2&lt;i32&gt;</code>) that applies a texel offset before sampling.</p></li></ul><h4 id="description-100">Description</h4><p>Performs a hardware-accelerated depth comparison against a sampled value from a depth texture. This is a highly specialized function designed almost exclusively for efficient shadow mapping.</p><p>The function samples a depth texture and compares the sampled depth value(s) against the provided <code>depth_ref</code>. The comparison operation (e.g., <code>depth_ref &lt;= texel_depth</code>) is determined by the <code>compare</code> property of the <code>sampler_comparison</code> object.</p><p>The return value is a float in the range <code>[0.0, 1.0]</code>. If the sampler’s filter mode is <code>linear</code>, the hardware will sample the four nearest texels, perform the comparison for each, and return a bilinearly filtered average of the four <code>0.0</code> or <code>1.0</code> results. If the filter mode is <code>nearest</code>, it compares against a single texel and returns either <code>0.0</code> or <code>1.0</code>.</p><p>This function must be called in <strong>uniform control flow</strong> (i.e., not inside if statements or loops that depend on per-fragment data). If it is used inside a loop with a variable number of iterations or an if statement with a per-fragment condition, the result is an indeterminate value.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#texturesamplecompare"><code>textureSampleCompare</code></a></em></p><h4 id="use-case-90">Use Case</h4><p>This is the standard, high-performance way to implement Percentage-Closer Filtering (PCF) for soft shadows, as the hardware handles the sampling, comparison, and filtering in a single, highly optimized step.</p><pre><code class="language-wgsl">@group(1) @binding(0) var shadow_map: texture_depth_2d;
@group(1) @binding(1) var shadow_sampler: sampler_comparison;

// The current fragment&#39;s depth from the light&#39;s perspective.
let fragment_depth = ...;

// The hardware performs the sampling, comparison, and (if configured)
// the filtering of the comparison results all in one operation.
// The result is a shadow factor (0.0 = shadowed, 1.0 = lit).
let shadow_factor = textureSampleCompare(
    shadow_map,
    shadow_sampler,
    in.shadow_coords,
    fragment_depth
);
</code></pre><h3 id="texturesamplecomparelevel"><code>textureSampleCompareLevel</code></h3><h4 id="signature-96">Signature</h4><ul><li><p><code>textureSampleCompareLevel(t: texture_depth_2d, s: sampler_comparison, coords: vec2&lt;f32&gt;, depth_ref: f32) -&gt; f32</code></p></li><li><p><code>textureSampleCompareLevel(t: texture_depth_2d, s: sampler_comparison, coords: vec2&lt;f32&gt;, depth_ref: f32, offset: vec2&lt;i32&gt;) -&gt; f32</code></p></li><li><p><code>textureSampleCompareLevel(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2&lt;f32&gt;, array_index: A, depth_ref: f32) -&gt; f32</code></p></li><li><p><code>textureSampleCompareLevel(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2&lt;f32&gt;, array_index: A, depth_ref: f32, offset: vec2&lt;i32&gt;) -&gt; f32</code></p></li><li><p><code>textureSampleCompareLevel(t: texture_depth_cube, s: sampler_comparison, coords: vec3&lt;f32&gt;, depth_ref: f32) -&gt; f32</code></p></li><li><p><code>textureSampleCompareLevel(t: texture_depth_cube_array, s: sampler_comparison, coords: vec3&lt;f32&gt;, array_index: A, depth_ref: f32) -&gt; f32</code></p></li><li><p><code>A</code> is <code>i32</code> or <code>u32</code>.</p></li><li><p><code>t</code>: A depth texture to sample from.</p></li><li><p><code>s</code>: A sampler_comparison object.</p></li><li><p><code>coords</code>: The floating-point coordinates for sampling.</p></li><li><p><code>depth_ref</code>: The depth value to compare against the values in the texture.</p></li><li><p><code>array_index</code>: The 0-indexed layer of the texture array to sample from.</p></li><li><p><code>offset</code>: An optional, compile-time constant integer vector (<code>vec2&lt;i32&gt;</code>) that applies a texel offset before sampling.</p></li></ul><h4 id="description-101">Description</h4><p>Performs a hardware-accelerated depth comparison against a depth texture, similar to <a href="#texturesamplecompare"><code>textureSampleCompare</code></a>, but with several key differences that make it safe to use in more contexts.</p><p>The main distinctions are:</p><ol><li>It <strong>always</strong> samples texels from the base mipmap level (level 0).</li><li>It does not compute derivatives for mipmap selection.</li><li>Because of this, it is <strong>not required to be invoked in uniform control flow</strong>.</li><li>It can be used in <strong>any shader stage</strong>, including vertex and compute shaders.</li></ol><p>The function samples the nearest texel(s) on mip level 0, compares them against <code>depth_ref</code> using the comparison function from the <code>sampler_comparison</code>, and returns a filtered average of the pass/fail results in the range <code>[0.0, 1.0]</code>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#texturesamplecomparelevel"><code>textureSampleCompareLevel</code></a></em></p><h4 id="use-case-91">Use Case</h4><p>This function is required for any shadow mapping algorithm that performs depth comparisons inside loops with variable iteration counts or if statements with per-fragment conditions, as <a href="#texturesamplecompare"><code>textureSampleCompare</code></a> would be invalid in those scenarios.</p><pre><code class="language-wgsl">@group(1) @binding(0) var shadow_map: texture_depth_2d;
@group(1) @binding(1) var shadow_sampler: sampler_comparison;

let fragment_depth = ...;
let num_samples = get_sample_count_for_this_pixel(); // A non-uniform value

var total_shadow = 0.0;

// This loop has a variable number of iterations, so it is non-uniform control flow.
// We MUST use textureSampleCompareLevel inside it.
for (var i = 0; i &lt; num_samples; i = i + 1) {
    let offset = get_sample_offset(i); // Get a pre-defined offset
    total_shadow = total_shadow + textureSampleCompareLevel(
        shadow_map,
        shadow_sampler,
        in.shadow_coords + offset,
        fragment_depth
    );
}
let shadow_factor = total_shadow / f32(num_samples);
</code></pre><h3 id="texturesamplegrad"><code>textureSampleGrad</code></h3><h4 id="signature-97">Signature</h4><ul><li><p><code>textureSampleGrad(t: texture_2d&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, ddx: vec2&lt;f32&gt;, ddy: vec2&lt;f32&gt;) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSampleGrad(t: texture_2d&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, ddx: vec2&lt;f32&gt;, ddy: vec2&lt;f32&gt;, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSampleGrad(t: texture_2d_array&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, ddx: vec2&lt;f32&gt;, ddy: vec2&lt;f32&gt;) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSampleGrad(t: texture_2d_array&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, ddx: vec2&lt;f32&gt;, ddy: vec2&lt;f32&gt;, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSampleGrad(t: T, s: sampler, coords: vec3&lt;f32&gt;, ddx: vec3&lt;f32&gt;, ddy: vec3&lt;f32&gt;) -&gt; vec4&lt;f32&gt; where T is texture_3d&lt;f32&gt; or texture_cube&lt;f32&gt;</code></p></li><li><p><code>textureSampleGrad(t: texture_3d&lt;f32&gt;, s: sampler, coords: vec3&lt;f32&gt;, ddx: vec3&lt;f32&gt;, ddy: vec3&lt;f32&gt;, offset: vec3&lt;i32&gt;) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSampleGrad(t: texture_cube_array&lt;f32&gt;, s: sampler, coords: vec3&lt;f32&gt;, array_index: A, ddx: vec3&lt;f32&gt;, ddy: vec3&lt;f32&gt;) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>A</code> is <code>i32</code> or <code>u32</code>.</p></li><li><p><code>t</code>: The texture to be sampled.</p></li><li><p><code>s</code>: A <code>sampler</code> object.</p></li><li><p><code>coords</code>: The floating-point coordinates for sampling.</p></li><li><p><code>ddx</code>, <code>ddy</code>: The explicit gradients (derivatives) of the texture coordinates with respect to the horizontal (<code>x</code>) and vertical (<code>y</code>) screen axes.</p></li><li><p><code>array_index</code>: The 0-indexed layer of the texture array to sample from.</p></li><li><p><code>offset</code>: An optional, compile-time constant integer vector that applies a texel offset before sampling.</p></li></ul><h4 id="description-102">Description</h4><p>Samples a texture using explicitly provided gradients, giving you manual control over mipmap level selection.</p><p>Normally, <a href="#texturesample"><code>textureSample</code></a> automatically calculates the rate of change of the coords to determine the correct mip level. However, this automatic calculation fails if the coords are manipulated procedurally within the shader (e.g., inside a loop or a complex <code>if</code> statement). <code>textureSampleGrad</code> solves this by letting you provide the gradients (<code>ddx</code> and <code>ddy</code>) yourself. The GPU then uses these manual gradients to perform a correct mipmap selection.</p><p>This is an advanced function required for specific rendering techniques.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#texturesamplegrad"><code>textureSampleGrad</code></a></em></p><h4 id="use-case-92">Use Case</h4><p>The canonical use case is in advanced materials like Parallax Occlusion Mapping (POM), where the texture coordinates are modified inside a raymarching loop. To get correct mipmapping, you must calculate the derivatives before the loop and then pass them into <code>textureSampleGrad</code> inside the loop.</p><pre><code class="language-wgsl">@group(1) @binding(0) var my_texture: texture_2d&lt;f32&gt;;
@group(1) @binding(1) var my_sampler: sampler;

// 1. Calculate the gradients on the original, unmodified UVs.
let uv_ddx = dpdx(in.uv);
let uv_ddy = dpdy(in.uv);

var final_uv = in.uv;

// 2. Perform some procedural UV manipulation (e.g., a raymarching loop for POM).
// This loop makes the final_uv value non-uniform, breaking automatic derivatives.
for (var i = 0; i &lt; 16; i = i + 1) {
    // ... complex logic that modifies final_uv ...
}

// 3. Sample the texture using the modified UVs, but provide the original,
// correct gradients. This ensures the texture is sampled with the correct mip level.
let final_color = textureSampleGrad(my_texture, my_sampler, final_uv, uv_ddx, uv_ddy);
</code></pre><h3 id="texturesamplelevel"><code>textureSampleLevel</code></h3><p>Samples a texture from a single, explicitly specified mipmap level, bypassing the GPU’s automatic level-of-detail selection.</p><p>This function has one critical advantage over <a href="#texturesample"><code>textureSample</code></a>: because it does not implicitly calculate derivatives, it is <strong>not required to be invoked in uniform control flow</strong>. This makes it the correct and safe choice for sampling textures inside loops with variable iteration counts or if statements with per-fragment conditions.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#texturesamplelevel"><code>textureSampleLevel</code></a></em></p><h4 id="overloads-colordata-textures-1">Overloads: Color/Data Textures</h4><p>These overloads sample from standard color or data textures.</p><h5 id="signature-98">Signature</h5><ul><li><p><code>textureSampleLevel(t: texture_2d&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, level: f32) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSampleLevel(t: texture_2d&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, level: f32, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSampleLevel(t: texture_2d_array&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, level: f32) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSampleLevel(t: texture_2d_array&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, level: f32, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSampleLevel(t: T, s: sampler, coords: vec3&lt;f32&gt;, level: f32) -&gt; vec4&lt;f32&gt; where T is texture_3d&lt;f32&gt; or texture_cube&lt;f32&gt;</code></p></li><li><p><code>textureSampleLevel(t: texture_3d&lt;f32&gt;, s: sampler, coords: vec3&lt;f32&gt;, level: f32, offset: vec3&lt;i32&gt;) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>textureSampleLevel(t: texture_cube_array&lt;f32&gt;, s: sampler, coords: vec3&lt;f32&gt;, array_index: A, level: f32) -&gt; vec4&lt;f32&gt;</code></p></li><li><p><code>A</code> is <code>i32</code> or <code>u32</code>.</p></li><li><p><code>t</code>: The texture to be sampled.</p></li><li><p><code>s</code>: A <code>sampler</code> object.</p></li><li><p><code>coords</code>: The floating-point coordinates for sampling.</p></li><li><p><code>level</code>: The <code>f32</code> mipmap level to sample from.</p></li><li><p><code>array_index</code>: The 0-indexed layer of the texture array.</p></li><li><p><code>offset</code>: An optional, compile-time constant integer offset.</p></li></ul><h5 id="description-103">Description</h5><p>Samples the texture using the specified <code>sampler</code> rules, but only from the mipmap level indicated by <code>level</code>. Because the <code>level</code> is a floating-point value, the GPU can perform trilinear filtering by blending the results from the two nearest integer mip levels if the sampler is configured to do so.</p><h5 id="use-case-93">Use Case</h5><p>Ideal for effects that need data from a specific level of detail or for sampling inside non-uniform control flow.</p><pre><code class="language-wgsl">@group(1) @binding(0) var scene_texture: texture_2d&lt;f32&gt;;
@group(1) @binding(1) var my_sampler: sampler;

// Use Case 1: Getting a blurred version of a texture for a bloom effect.
// Sample from a high mip level (e.g., 4.0) to get a small, blurry image.
let bloom_source = textureSampleLevel(scene_texture, my_sampler, in.uv, 4.0);

// Use Case 2: Sampling inside a non-uniform loop.
var final_color = vec4(0.0);
if (in.world_position.x &gt; 0.0) { // Non-uniform condition
    // We MUST use textureSampleLevel here.
    final_color = textureSampleLevel(scene_texture, my_sampler, in.uv, 0.0);
}
</code></pre><h4 id="overloads-depth-textures-3">Overloads: Depth Textures</h4><p>These overloads sample from a single mip level of a depth texture.</p><h5 id="signature-99">Signature</h5><ul><li><p><code>textureSampleLevel(t: texture_depth_2d, s: sampler, coords: vec2&lt;f32&gt;, level: L) -&gt; f32</code></p></li><li><p><code>textureSampleLevel(t: texture_depth_2d, s: sampler, coords: vec2&lt;f32&gt;, level: L, offset: vec2&lt;i32&gt;) -&gt; f32</code></p></li><li><p><code>textureSampleLevel(t: texture_depth_2d_array, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, level: L) -&gt; f32</code></p></li><li><p><code>textureSampleLevel(t: texture_depth_2d_array, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, level: L, offset: vec2&lt;i32&gt;) -&gt; f32</code></p></li><li><p><code>textureSampleLevel(t: texture_depth_cube, s: sampler, coords: vec3&lt;f32&gt;, level: L) -&gt; f32</code></p></li><li><p><code>textureSampleLevel(t: texture_depth_cube_array, s: sampler, coords: vec3&lt;f32&gt;, array_index: A, level: L) -&gt; f32</code></p></li><li><p><code>A</code> and <code>L</code> are <code>i32</code> or <code>u32</code>.</p></li><li><p><code>t</code>: The depth texture to be sampled.</p></li><li><p><code>s</code>: A <code>sampler</code> object.</p></li><li><p><code>coords</code>: The floating-point coordinates for sampling.</p></li><li><p><code>level</code>: The integer <code>i32</code> or <code>u32</code> mipmap level to sample from.</p></li><li><p><code>array_index</code>: The 0-indexed layer of the texture array.</p></li><li><p><code>offset</code>: An optional, compile-time constant integer offset.</p></li></ul><h5 id="description-104">Description</h5><p>Samples the depth texture, returning a single <code>f32</code> depth value from the specified integer mip <code>level</code>. Unlike the color texture overloads, the level parameter is an integer, so no blending between mip levels is performed.</p><h5 id="use-case-94">Use Case</h5><p>Used to fetch a precise depth value from a specific mip level, often in custom post-processing effects.</p><pre><code class="language-wgsl">@group(1) @binding(0) var depth_texture: texture_depth_2d;
@group(1) @binding(1) var my_sampler: sampler;

// Get the unfiltered depth value from the center of the highest-resolution mip level.
let center_depth = textureSampleLevel(depth_texture, my_sampler, vec2(0.5), 0);
</code></pre><h3 id="texturestore"><code>textureStore</code></h3><h4 id="signature-100">Signature</h4><ul><li><p><code>textureStore(t: texture_storage_1d&lt;F,A&gt;, coords: C, value: vec4&lt;CF&gt;)</code></p></li><li><p><code>textureStore(t: texture_storage_2d&lt;F,A&gt;, coords: vec2&lt;C&gt;, value: vec4&lt;CF&gt;)</code></p></li><li><p><code>textureStore(t: texture_storage_2d_array&lt;F,A&gt;, coords: vec2&lt;C&gt;, array_index: A_idx, value: vec4&lt;CF&gt;)</code></p></li><li><p><code>textureStore(t: texture_storage_3d&lt;F,A&gt;, coords: vec3&lt;C&gt;, value: vec4&lt;CF&gt;)</code></p></li><li><p><code>t</code>: The storage texture to write to.</p></li><li><p><code>F</code>: The texel format of the texture, declared in Rust/CPU code (e.g., <code>rgba8unorm</code>, <code>r32uint</code>).</p></li><li><p><code>A</code>: The access mode, which must be <code>write</code> or <code>read_write</code>.</p></li><li><p><code>coords</code> / <code>C</code>: The integer texel coordinates (<code>i32</code> or <code>u32</code>).</p></li><li><p><code>array_index</code> / <code>A_idx</code>: The integer array layer (<code>i32</code> or <code>u32</code>).</p></li><li><p><code>value</code>: A <code>vec4</code> containing the data to write.</p></li><li><p><code>CF</code>: The required “channel format” for the value parameter. This type depends on the texture’s texel format <code>F</code>. For example:</p><ul><li>If <code>F</code> is <code>rgba8unorm</code>, <code>CF</code> must be <code>f32</code>.</li><li>If <code>F</code> is <code>r32uint</code>, <code>CF</code> must be <code>u32</code>.</li><li>If <code>F</code> is <code>rg32sint</code>, <code>CF</code> must be <code>i32</code>.</li></ul></li></ul><h4 id="description-105">Description</h4><p>Writes a <code>vec4</code> value to a specific texel in a <code>storage</code> texture. This is an output-only function that does not return a value. It is fundamentally different from sampling functions: it only works with <code>texture_storage_*</code> types, uses integer coordinates instead of UVs, does not use a sampler, and requires that the texture’s access mode be <code>write</code> or <code>read_write</code>.</p><p>The <code>value</code> is written to the texel specified by the integer <code>coords</code>. If the coordinates are outside the bounds of the texture, the operation is simply discarded and has no effect. For single-channel formats (like <code>r32float</code>), only the first component of the value (<code>.x</code>) is used.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#texturestore"><code>textureStore</code></a></em></p><h4 id="use-case-95">Use Case</h4><p><code>textureStore</code> is the primary way to write output from a <strong>compute shader</strong>. It is commonly used for image processing, simulations, or any general-purpose GPU computation where the result is an image or data grid.</p><pre><code class="language-wgsl">// A simple compute shader that inverts the colors of an image.

// Input texture (read-only)
@group(0) @binding(0) var input_texture: texture_2d&lt;f32&gt;;
// Output texture (write-only)
@group(0) @binding(1) var output_texture: texture_storage_2d&lt;rgba8unorm, write&gt;;

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) id: vec3&lt;u32&gt;) {
    // `id.xy` is the integer coordinate of the pixel this shader instance is processing.

    // 1. Read the original color using `textureLoad`.
    let original_color = textureLoad(input_texture, id.xy, 0);

    // 2. Perform the image processing (in this case, a simple inversion).
    let inverted_color = vec4&lt;f32&gt;(1.0 - original_color.rgb, original_color.a);

    // 3. Write the new color to the output texture at the same coordinate.
    // The value must be a vec4&lt;f32&gt; because the output format is `rgba8unorm`.
    textureStore(output_texture, id.xy, inverted_color);
}
</code></pre><h2 id="derivative-functions">Derivative Functions</h2><p>This family of functions calculates the rate of change of a value with respect to the screen axes. They are powerful tools available <strong>only in fragment shaders</strong>.</p><p>These functions operate by implicitly comparing the value in the current fragment with the value in an adjacent fragment. They provide derivatives for both the horizontal (X) and vertical (Y) screen axes, as well as a combined measure of the total change.</p><p>A critical requirement for these functions is that they must be called in <strong>uniform control flow</strong>. The GPU executes fragment shaders in small 2x2 blocks of pixels, and derivatives are calculated by differencing values within this block. If an <code>if</code> statement causes one fragment in the block to take a different code path than its neighbor, the values are no longer comparable, making the derivative result meaningless.</p><p>While their most common use is implicit (the GPU uses them behind the scenes for <code>textureSample</code> to select mipmap levels), they are powerful explicit tools for advanced effects like procedural anti-aliasing and generating normal maps from height maps.</p><h3 id="dpdx"><code>dpdx</code></h3><h4 id="signature-101">Signature</h4><p><code>dpdx(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector to find the derivative of.</li><li><code>T</code>: Can be <code>f32</code> or a vector of <code>f32</code> (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-106">Description</h4><p>Calculates the partial derivative of the input <code>e</code> with respect to the horizontal screen axis (X). This function is only available in fragment shaders.</p><p>In practice, this means it computes the rate of change of <code>e</code> by finding the difference between its value in the current fragment and its value in the adjacent fragment to the right. The result can be positive or negative. <code>dpdx</code> is a general version of this function; the GPU is free to use either a high-precision (<a href="#dpdxfine"><code>dpdxFine</code></a>) or a faster, less-precise (<a href="#dpdxcoarse"><code>dpdxCoarse</code></a>) calculation. For explicit control, those functions can be called directly.</p><p>This function must be called in <strong>uniform control flow</strong>. This is because the GPU computes derivatives by running the same code on a 2x2 block of fragments and comparing their results. If fragments in the block take different code paths (due to an <code>if</code> statement), the comparison is meaningless, and the function will return an indeterminate value.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#dpdx-builtin"><code>dpdx</code></a></em></p><h4 id="use-case-96">Use Case</h4><p>Derivative functions are fundamental for many advanced effects. While they are used implicitly by <a href="#texturesample"><code>textureSample</code></a> to select mipmap levels, an explicit use is to procedurally generate normal maps from a height map.</p><pre><code class="language-wgsl">// Assume we have a function that generates a procedural height value (e.g., noise).
let height = procedural_height(in.uv);

// Calculate how the height changes along the screen&#39;s X and Y axes.
let height_dx = dpdx(height);
let height_dy = dpdy(height); // (dpdy is the derivative on the Y axis)

// Create two vectors that lie on the surface of our procedural height map.
// These represent the tangents in the X and Y directions.
let tangent_x = vec3&lt;f32&gt;(1.0, 0.0, height_dx);
let tangent_y = vec3&lt;f32&gt;(0.0, 1.0, height_dy);

// The cross product of the two tangents gives us the surface normal.
let procedural_normal = normalize(cross(tangent_x, tangent_y));

// This normal can now be used for realistic lighting on a procedural surface.
</code></pre><h3 id="dpdxcoarse"><code>dpdxCoarse</code></h3><h4 id="signature-102">Signature</h4><p><code>dpdxCoarse(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector to find the derivative of.</li><li><code>T</code>: Can be <code>f32</code> or a vector of <code>f32</code> (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-107">Description</h4><p>Calculates a low-precision (“coarse”) partial derivative of the input <code>e</code> with respect to the horizontal screen axis (X). This function is only available in fragment shaders.</p><p>Like <a href="#dpdx"><code>dpdx</code></a>, it computes the rate of change of e between adjacent fragments. However, <code>dpdxCoarse</code> allows the GPU to perform the calculation using “local differences,” which may mean it reuses derivative calculations across a larger 2x2 group of fragments rather than computing a unique value for each one. This can be faster but may result in a less precise derivative, potentially leading to blocky artifacts in some algorithms.</p><p>This function must be called in <strong>uniform control flow</strong>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#dpdxCoarse-builtin"><code>dpdxCoarse</code></a></em></p><h4 id="use-case-97">Use Case</h4><p>Used in situations where performance is more critical than perfect derivative accuracy. It can be a performance optimization over <a href="#dpdx"><code>dpdx</code></a> or <a href="#dpdxfine"><code>dpdxFine</code></a> if the visual impact of the lower precision is negligible.</p><pre><code class="language-wgsl">// Calculating a procedural normal where maximum precision is not required.
let height = procedural_height(in.uv);

// Using the coarse derivatives may be slightly faster. For many procedural
// patterns, the visual difference will be unnoticeable.
let height_dx = dpdxCoarse(height);
let height_dy = dpdyCoarse(height);

let tangent_x = vec3&lt;f32&gt;(1.0, 0.0, height_dx);
let tangent_y = vec3&lt;f32&gt;(0.0, 1.0, height_dy);

let procedural_normal = normalize(cross(tangent_x, tangent_y));
</code></pre><h3 id="dpdxfine"><code>dpdxFine</code></h3><h4 id="signature-103">Signature</h4><p><code>dpdxFine(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector to find the derivative of.</li><li><code>T</code>: Can be <code>f32</code> or a vector of <code>f32</code> (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-108">Description</h4><p>Calculates a high-precision (“fine”) partial derivative of the input <code>e</code> with respect to the horizontal screen axis (X). This function is only available in fragment shaders.</p><p>Like <a href="#dpdx"><code>dpdx</code></a>, it computes the rate of change of <code>e</code> by finding the difference between its value in the current fragment and its value in an adjacent fragment to the right. The “fine” qualifier suggests that the GPU will use a more precise, per-fragment calculation, potentially providing a more accurate local derivative than <a href="#dpdxcoarse"><code>dpdxCoarse</code></a>. This can be important for avoiding artifacts when working with high-frequency data.</p><p>This function must be called in <strong>uniform control flow</strong>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#dpdxFine-builtin"><code>dpdxFine</code></a></em></p><h4 id="use-case-98">Use Case</h4><p>Used in situations where derivative accuracy is critical, and you want to ensure the highest-quality result, even at a potential minor performance cost compared to <a href="#dpdxcoarse"><code>dpdxCoarse</code></a>. This is important for procedural normals based on detailed height maps or for texture sampling with explicit gradients where precision is key.</p><pre><code class="language-wgsl">// A height map texture that contains fine, sharp details.
@group(1) @binding(0) var height_map: texture_2d&lt;f32&gt;;
@group(1) @binding(1) var my_sampler: sampler;

let height = textureSample(height_map, my_sampler, in.uv).r;

// Using the fine derivatives ensures we capture the sharp changes
// in the height map as accurately as possible, preventing aliasing
// or blocky artifacts in the resulting normal.
let height_dx = dpdxFine(height);
let height_dy = dpdyFine(height);

let tangent_x = vec3&lt;f32&gt;(1.0, 0.0, height_dx);
let tangent_y = vec3&lt;f32&gt;(0.0, 1.0, height_dy);

let procedural_normal = normalize(cross(tangent_x, tangent_y));
</code></pre><h3 id="dpdy"><code>dpdy</code></h3><h4 id="signature-104">Signature</h4><p><code>dpdy(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector to find the derivative of.</li><li><code>T</code>: Can be <code>f32</code> or a vector of <code>f32</code> (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-109">Description</h4><p>Calculates the partial derivative of the input <code>e</code> with respect to the vertical screen axis (Y). This function is the vertical counterpart to <a href="#dpdx"><code>dpdx</code></a> and is only available in fragment shaders.</p><p>It computes the rate of change of <code>e</code> by finding the difference between its value in the current fragment and its value in the adjacent fragment below it. The result can be positive or negative. <code>dpdy</code> is a general version of this function; the GPU is free to use either a high-precision (<a href="#dpdyfine"><code>dpdyFine</code></a>) or a faster, less-precise (<a href="#dpdycoarse"><code>dpdyCoarse</code></a>) calculation. For explicit control, those functions can be called directly.</p><p>This function must be called in <strong>uniform control flow</strong>. If it is used inside a loop with a variable number of iterations or an <code>if</code> statement with a per-fragment condition, the result is an indeterminate value.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#dpdy-builtin"><code>dpdy</code></a></em></p><h4 id="use-case-99">Use Case</h4><p>Derivative functions are fundamental for many advanced effects. <code>dpdy</code> is almost always used in conjunction with <a href="#dpdx"><code>dpdx</code></a> to understand how a value is changing across a 2D surface. A primary use is generating procedural normal maps from a height map.</p><pre><code class="language-wgsl">// Assume we have a function that generates a procedural height value (e.g., noise).
let height = procedural_height(in.uv);

// Calculate how the height changes along the screen&#39;s X and Y axes.
let height_dx = dpdx(height);
let height_dy = dpdy(height);

// Create two vectors that lie on the surface of our procedural height map.
// These represent the tangents in the X and Y directions.
let tangent_x = vec3&lt;f32&gt;(1.0, 0.0, height_dx);
let tangent_y = vec3&lt;f32&gt;(0.0, 1.0, height_dy);

// The cross product of the two tangents gives us the surface normal.
let procedural_normal = normalize(cross(tangent_x, tangent_y));

// This normal can now be used for realistic lighting on a procedural surface.
</code></pre><h3 id="dpdycoarse"><code>dpdyCoarse</code></h3><h4 id="signature-105">Signature</h4><p><code>dpdyCoarse(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector to find the derivative of.</li><li><code>T</code>: Can be <code>f32</code> or a vector of <code>f32</code> (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-110">Description</h4><p>Calculates a low-precision (“coarse”) partial derivative of the input <code>e</code> with respect to the vertical screen axis (Y). This function is the vertical counterpart to <a href="#dpdxcoarse"><code>dpdxCoarse</code></a> and is only available in fragment shaders.</p><p>Like <a href="#dpdy"><code>dpdy</code></a>, it computes the rate of change of e between adjacent vertical fragments. However, <code>dpdyCoarse</code> allows the GPU to perform the calculation using “local differences,” which may mean it reuses derivative calculations across a larger 2x2 group of fragments rather than computing a unique value for each one. This can be faster but may result in a less precise derivative.</p><p>This function must be called in <strong>uniform control flow</strong>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#dpdyCoarse-builtin"><code>dpdyCoarse</code></a></em></p><h4 id="use-case-100">Use Case</h4><p>Used in situations where performance is more critical than perfect derivative accuracy. It can be a performance optimization over <a href="#dpdy"><code>dpdy</code></a> or <a href="#dpdyfine"><code>dpdyFine</code></a> if the visual impact of the lower precision is negligible. It is typically used alongside <a href="#dpdxcoarse"><code>dpdxCoarse</code></a>.</p><pre><code class="language-wgsl">// Calculating a procedural normal where maximum precision is not required.
let height = procedural_height(in.uv);

// Using the coarse derivatives may be slightly faster. For many procedural
// patterns, the visual difference will be unnoticeable.
let height_dx = dpdxCoarse(height);
let height_dy = dpdyCoarse(height);

let tangent_x = vec3&lt;f32&gt;(1.0, 0.0, height_dx);
let tangent_y = vec3&lt;f32&gt;(0.0, 1.0, height_dy);

let procedural_normal = normalize(cross(tangent_x, tangent_y));
</code></pre><h3 id="dpdyfine"><code>dpdyFine</code></h3><h4 id="signature-106">Signature</h4><p><code>dpdyFine(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector to find the derivative of.</li><li><code>T</code>: Can be <code>f32</code> or a vector of <code>f32</code> (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-111">Description</h4><p>Calculates a high-precision (“fine”) partial derivative of the input <code>e</code> with respect to the vertical screen axis (Y). This function is the vertical counterpart to <a href="#dpdxfine"><code>dpdxFine</code></a> and is only available in fragment shaders.</p><p>Like <a href="#dpdy"><code>dpdy</code></a>, it computes the rate of change of e by finding the difference between its value in the current fragment and its value in an adjacent vertical fragment. The “fine” qualifier suggests that the GPU will use a more precise, per-fragment calculation, potentially providing a more accurate local derivative than <a href="#dpdycoarse"><code>dpdyCoarse</code></a>.</p><p>This function must be called in <strong>uniform control flow</strong>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#dpdyFine-builtin"><code>dpdyFine</code></a></em></p><h4 id="use-case-101">Use Case</h4><p>Used in situations where derivative accuracy is critical, particularly when creating procedural normals from high-frequency data. It is almost always used in conjunction with <a href="#dpdxfine"><code>dpdxFine</code></a> to ensure consistent precision.</p><pre><code class="language-wgsl">// A height map texture that contains fine, sharp details.
@group(1) @binding(0) var height_map: texture_2d&lt;f32&gt;;
@group(1) @binding(1) var my_sampler: sampler;

let height = textureSample(height_map, my_sampler, in.uv).r;

// Using the fine derivatives ensures we capture the sharp changes
// in the height map as accurately as possible, preventing aliasing
// or blocky artifacts in the resulting normal.
let height_dx = dpdxFine(height);
let height_dy = dpdyFine(height);

let tangent_x = vec3&lt;f32&gt;(1.0, 0.0, height_dx);
let tangent_y = vec3&lt;f32&gt;(0.0, 1.0, height_dy);

let procedural_normal = normalize(cross(tangent_x, tangent_y));
</code></pre><h3 id="fwidth"><code>fwidth</code></h3><h4 id="signature-107">Signature</h4><p><code>fwidth(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector to find the derivative of.</li><li><code>T</code>: Can be <code>f32</code> or a vector of <code>f32</code> (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-112">Description</h4><p>Calculates the sum of the absolute values of the partial derivatives with respect to the screen axes. It is a convenient shorthand for <code>abs(dpdx(e)) + abs(dpdy(e))</code>. This function is only available in fragment shaders.</p><p>The result is a single positive value that represents the total rate of change of the input <code>e</code> at the current fragment, combining both horizontal and vertical changes. It provides a measure of how “busy” or how steep the gradient of <code>e</code> is across the pixel.</p><p>This function must be called in <strong>uniform control flow</strong>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#fwidth-builtin"><code>fwidth</code></a></em></p><h4 id="use-case-102">Use Case</h4><p>The primary use of <code>fwidth</code> is for procedural anti-aliasing. It can determine the “width” of a procedural shape in screen space, allowing you to create a smooth transition that is exactly one pixel wide, eliminating aliasing (jagged edges).</p><pre><code class="language-wgsl">// Use Case: Drawing an anti-aliased procedural line.

let line_pos = 0.5;
let uv = in.uv;

// An aliased (jagged) vertical line using `step`.
let aliased_line = step(line_pos, uv.x);

// To anti-alias it, we need to know how much `uv.x` changes from
// one pixel to the next. This is exactly what `fwidth` provides.
let pixel_width = fwidth(uv.x);

// Now, instead of a hard step, we create a smooth transition that is
// exactly one pixel wide, centered on our line position.
let anti_aliased_line = smoothstep(
    line_pos - pixel_width,
    line_pos + pixel_width,
    uv.x
);

// The `anti_aliased_line` will be a soft, non-jagged line, while
// `aliased_line` will be pixelated.
</code></pre><h3 id="fwidthcoarse"><code>fwidthCoarse</code></h3><h4 id="signature-108">Signature</h4><p><code>fwidthCoarse(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector to find the derivative of.</li><li><code>T</code>: Can be <code>f32</code> or a vector of <code>f32</code> (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-113">Description</h4><p>Calculates the sum of the absolute values of the low-precision (“coarse”) partial derivatives. It is a convenient shorthand for <code>abs(dpdxCoarse(e)) + abs(dpdyCoarse(e))</code>. This function is only available in fragment shaders.</p><p>This is the less precise but potentially faster version of <a href="#fwidth"><code>fwidth</code></a>. It provides an estimate of the total rate of change of the input <code>e</code> at the current fragment.</p><p>This function must be called in <strong>uniform control flow</strong>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#fwidthCoarse-builtin"><code>fwidthCoarse</code></a></em></p><h4 id="use-case-103">Use Case</h4><p>Used for procedural anti-aliasing in situations where maximum performance is desired and a slightly less accurate gradient calculation is acceptable. For many effects, the visual difference between <a href="#fwidth"><code>fwidth</code></a> and <code>fwidthCoarse</code> is negligible.</p><pre><code class="language-wgsl">// Use Case: Procedural anti-aliasing where performance is a priority.

let circle_radius = 0.4;
let dist = length(in.uv - 0.5);

// Get a fast, approximate measure of how much `dist` changes across one pixel.
let pixel_width = fwidthCoarse(dist);

// Create a smooth transition (anti-aliasing) that is approximately one pixel wide.
let anti_aliased_circle = 1.0 - smoothstep(
    circle_radius - pixel_width,
    circle_radius + pixel_width,
    dist
);```

---
</code></pre><h3 id="fwidthfine"><code>fwidthFine</code></h3><h4 id="signature-109">Signature</h4><p><code>fwidthFine(e: T) -&gt; T</code></p><ul><li><code>e</code>: The input value or vector to find the derivative of.</li><li><code>T</code>: Can be <code>f32</code> or a vector of <code>f32</code> (e.g., <code>vec3&lt;f32&gt;</code>).</li></ul><h4 id="description-114">Description</h4><p>Calculates the sum of the absolute values of the high-precision (“fine”) partial derivatives. It is a convenient shorthand for <code>abs(dpdxFine(e)) + abs(dpdyFine(e))</code>. This function is only available in fragment shaders.</p><p>This is the high-precision version of <a href="#fwidth"><code>fwidth</code></a>. It provides a more accurate measure of the total rate of change of the input <code>e</code> at the current fragment, which is important for effects that rely on precise gradient information.</p><p>This function must be called in <strong>uniform control flow</strong>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#fwidthFine-builtin"><code>fwidthFine</code></a></em></p><h4 id="use-case-104">Use Case</h4><p>Used for high-quality procedural anti-aliasing, especially for patterns with sharp, high-frequency details where a less precise gradient from <a href="#fwidthcoarse"><code>fwidthCoarse</code></a> might lead to visual artifacts like moiré patterns or inconsistent line thickness.</p><pre><code class="language-wgsl">// Use Case: Drawing a high-quality, anti-aliased procedural grid.
let uv = in.uv * 10.0; // Create a 10x10 grid.

// `fract()` gives us sawtooth waves. `abs(v - 0.5)` gives us triangles.
// `dist` will be 0 at the grid lines and 0.5 at the center of cells.
let dist_to_line = abs(fract(uv) - 0.5);

// Get a precise measure of how much `dist_to_line` changes across one pixel.
let pixel_width = fwidthFine(dist_to_line);

// Use this precise width to create a smooth transition around the grid lines.
// `smoothstep` will create a line that is exactly one pixel thick.
let grid_lines = 1.0 - smoothstep(
    0.5 - pixel_width, // Start fading in one pixel-width before the line
    0.5,               // The line itself
    dist_to_line
);

// The result is a crisp, perfectly anti-aliased grid.
</code></pre><h2 id="atomic-read-modify-write-functions">Atomic Read-Modify-Write Functions</h2><p>This family of functions performs atomic <strong>read-modify-write</strong> operations on a memory location shared between multiple shader invocations (threads). They are primarily used in <strong>compute shaders</strong> to safely modify data without causing race conditions.</p><p>An <strong>atomic operation</strong> is guaranteed by the hardware to be indivisible. When a thread performs one of these functions, it executes a complete sequence:</p><ol><li>It reads the original value from a memory location.</li><li>It performs a calculation using that original value and a new input value (e.g., addition, comparison, or a bitwise operation).</li><li>It writes the result of the calculation back to the memory location.</li></ol><p>This entire sequence happens without any other thread being able to interfere. A key feature of all functions in this group is that they return the <strong>original value</strong> that was in memory <em>before</em> the modification took place.</p><h3 id="atomicadd"><code>atomicAdd</code></h3><h4 id="signature-110">Signature</h4><p><code>atomicAdd(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T) -&gt; T</code></p><ul><li><code>atomic_ptr</code>: A pointer to the atomic integer to be modified.<ul><li><code>AS</code>: The address space of the variable, typically workgroup or storage.</li><li><code>atomic&lt;T&gt;</code>: The special type indicating this memory is for atomic access.</li><li><code>read_write</code>: The access mode for the pointer.</li></ul></li><li><code>v</code>: The integer value to add.</li><li><code>T</code>: The data type, which must be either <code>i32</code> or <code>u32</code>.</li></ul><h4 id="description-115">Description</h4><p>Atomically adds the value <code>v</code> to the integer stored at the memory location <code>atomic_ptr</code>. The function returns the <strong>original value</strong> that was stored in memory before the addition occurred.</p><p>An <strong>atomic operation</strong> is guaranteed by the hardware to be indivisible. When a thread performs <code>atomicAdd</code>, it reads the original value, calculates the sum, and writes the new value back to memory without any other thread being able to interfere in the middle of that sequence. This is essential for preventing race conditions in compute shaders where multiple threads might try to modify the same shared variable at the same time.</p><p>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#atomic-add">atomicAdd</a></p><h4 id="use-case-105">Use Case</h4><p>The most common use case is to safely increment a shared counter from multiple threads in a compute shader.</p><pre><code class="language-wgsl">// A shared counter in `workgroup` memory, accessible by all threads.
// Note the `atomic&lt;u32&gt;` type declaration.
var&lt;workgroup&gt; shared_counter: atomic&lt;u32&gt;;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(local_invocation_index) local_id: u32) {
    // A single thread initializes the counter.
    if (local_id == 0u) {
        // `atomicStore` is used for initialization.
        atomicStore(&amp;shared_counter, 0u);
    }
    // Ensure all threads wait until initialization is done.
    workgroupBarrier();

    // Imagine each thread does some work and needs to increment the counter.
    // Without `atomicAdd`, if two threads read the value &#39;5&#39; at the same time,
    // they would both write back &#39;6&#39;, and one increment would be lost.
    // `atomicAdd` prevents this.
    atomicAdd(&amp;shared_counter, 1u);
}
</code></pre><h3 id="atomicsub"><code>atomicSub</code></h3><h4 id="signature-111">Signature</h4><p><code>atomicSub(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T) -&gt; T</code></p><ul><li><code>atomic_ptr</code>: A pointer to the atomic integer to be modified.<ul><li><code>AS</code>: The address space of the variable, typically workgroup or storage.</li><li><code>atomic&lt;T&gt;</code>: The special type indicating this memory is for atomic access.</li><li><code>read_write</code>: The access mode for the pointer.</li></ul></li><li><code>v</code>: The integer value to subtract.</li><li><code>T</code>: The data type, which must be either <code>i32</code> or <code>u32</code>.</li></ul><h4 id="description-116">Description</h4><p>Atomically subtracts the value <code>v</code> from the integer stored at the memory location <code>atomic_ptr</code>. The function returns the <strong>original value</strong> that was stored in memory before the subtraction occurred.</p><p>An <strong>atomic operation</strong> is guaranteed by the hardware to be indivisible. When a thread performs <code>atomicSub</code>, it reads the original value, calculates the difference, and writes the new value back to memory without any other thread being able to interfere in the middle of that sequence. This is essential for preventing race conditions in compute shaders where multiple threads might try to modify the same shared variable simultaneously.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#atomic-sub"><code>atomicSub</code></a></em></p><h4 id="use-case-106">Use Case</h4><p>Used to safely decrement a shared counter or resource pool from multiple threads in a compute shader. For example, implementing a work queue where threads “claim” items to process.</p><pre><code class="language-wgsl">// A shared counter for the number of items left in a work pool.
var&lt;workgroup&gt; items_remaining: atomic&lt;u32&gt;;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(local_invocation_index) local_id: u32) {
    // A single thread initializes the counter.
    if (local_id == 0u) {
        atomicStore(&amp;items_remaining, 100u); // Start with 100 items.
    }
    workgroupBarrier();

    // Each thread attempts to claim an item by decrementing the counter.
    // `atomicSub` returns the value *before* the subtraction.
    let previous_count = atomicSub(&amp;items_remaining, 1u);

    // If the count before we subtracted was greater than 0, then our claim was successful.
    if (previous_count &gt; 0u) {
        // ... process the item ...
    }
}
</code></pre><h3 id="atomicmax"><code>atomicMax</code></h3><h4 id="signature-112">Signature</h4><p><code>atomicMax(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T) -&gt; T</code></p><ul><li><code>atomic_ptr</code>: A pointer to the atomic integer to be modified.<ul><li><code>AS</code>: The address space of the variable, typically workgroup or storage.</li><li><code>atomic&lt;T&gt;</code>: The special type indicating this memory is for atomic access.</li><li><code>read_write</code>: The access mode for the pointer.</li></ul></li><li><code>v</code>: The integer value to compare against.</li><li><code>T</code>: The data type, which must be either <code>i32</code> or <code>u32</code>.</li></ul><h4 id="description-117">Description</h4><p>Atomically compares the value <code>v</code> with the integer stored at the memory location <code>atomic_ptr</code>. If <code>v</code> is larger, the value at <code>atomic_ptr</code> is replaced with <code>v</code>. The function returns the <strong>original value</strong> that was stored in memory before the comparison and potential replacement occurred.</p><p>An <strong>atomic operation</strong> is guaranteed by the hardware to be indivisible. When a thread performs <code>atomicMax</code>, it reads the original value, performs the comparison, and (if necessary) writes the new value back to memory without any other thread being able to interfere in the middle of that sequence. This is essential for preventing race conditions when finding a maximum value in parallel.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#atomic-max"><code>atomicMax</code></a></em></p><h4 id="use-case-107">Use Case</h4><p>Used to safely find the maximum value in a dataset in parallel. Each thread in a compute shader can process a subset of the data and use atomicMax to update a single shared variable with its local maximum.</p><pre><code class="language-wgsl">// A shared variable to hold the global maximum value found by the workgroup.
var&lt;workgroup&gt; global_maximum: atomic&lt;u32&gt;;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(local_invocation_index) local_id: u32) {
    // A single thread initializes the shared maximum to zero.
    if (local_id == 0u) {
        atomicStore(&amp;global_maximum, 0u);
    }
    workgroupBarrier();

    // Each thread calculates its own local maximum from some data.
    let local_maximum = calculate_local_maximum(local_id); // e.g., 10u, 50u, 20u...

    // Each thread attempts to update the shared global_maximum.
    // `atomicMax` ensures that even if two threads try to write a new
    // maximum at the same time, the correct final maximum is preserved.
    atomicMax(&amp;global_maximum, local_maximum);
}
</code></pre><h3 id="atomicmin"><code>atomicMin</code></h3><h4 id="signature-113">Signature</h4><p><code>atomicMin(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T) -&gt; T</code></p><ul><li><code>atomic_ptr</code>: A pointer to the atomic integer to be modified.<ul><li><code>AS</code>: The address space of the variable, typically workgroup or storage.</li><li><code>atomic&lt;T&gt;</code>: The special type indicating this memory is for atomic access.</li><li>read_write: The access mode for the pointer.</li></ul></li><li>v: The integer value to compare against.</li><li>T: The data type, which must be either <code>i32</code> or <code>u32</code>.</li></ul><h4 id="description-118">Description</h4><p>Atomically compares the value <code>v</code> with the integer stored at the memory location atomic_ptr. If <code>v</code> is smaller, the value at <code>atomic_ptr</code> is replaced with <code>v</code>. The function returns the <strong>original value</strong> that was stored in memory before the comparison and potential replacement occurred.</p><p>An <strong>atomic operation</strong> is guaranteed by the hardware to be indivisible. When a thread performs <code>atomicMin</code>, it reads the original value, performs the comparison, and (if necessary) writes the new value back to memory without any other thread being able to interfere in the middle of that sequence. This is essential for preventing race conditions when finding a minimum value in parallel.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#atomic-min"><code>atomicMin</code></a></em></p><h4 id="use-case-108">Use Case</h4><p>Used to safely find the minimum value in a dataset in parallel. Each thread in a compute shader can process a subset of the data and use atomicMin to update a single shared variable with its local minimum.</p><pre><code class="language-wgsl">// A shared variable to hold the global minimum value found by the workgroup.
var&lt;workgroup&gt; global_minimum: atomic&lt;u32&gt;;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(local_invocation_index) local_id: u32) {
    // A single thread initializes the shared minimum to a very large value.
    if (local_id == 0u) {
        atomicStore(&amp;global_minimum, 4294967295u); // Max u32 value
    }
    workgroupBarrier();

    // Each thread calculates its own local minimum from some data.
    let local_minimum = calculate_local_minimum(local_id); // e.g., 100u, 50u, 200u...

    // Each thread attempts to update the shared global_minimum.
    // `atomicMin` ensures that even if two threads try to write a new
    // minimum at the same time, the correct final minimum is preserved.
    atomicMin(&amp;global_minimum, local_minimum);
}
</code></pre><h3 id="atomicand"><code>atomicAnd</code></h3><h4 id="signature-114">Signature</h4><p><code>atomicAnd(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T) -&gt; T</code></p><ul><li><code>atomic_ptr</code>: A pointer to the atomic integer to be modified.<ul><li><code>AS</code>: The address space of the variable, typically workgroup or storage.</li><li><code>atomic&lt;T&gt;</code>: The special type indicating this memory is for atomic access.</li><li><code>read_write</code>: The access mode for the pointer.</li></ul></li><li><code>v</code>: The integer value to use for the bitwise AND operation.</li><li><code>T</code>: The data type, which must be either <code>i32</code> or <code>u32</code>.</li></ul><h4 id="description-119">Description</h4><p>Atomically performs a bitwise AND operation between the value <code>v</code> and the integer stored at the memory location <code>atomic_ptr</code>, storing the result back at <code>atomic_ptr</code>. The function returns the <strong>original value</strong> that was stored in memory before the AND operation occurred.</p><p>An <strong>atomic operation</strong> is guaranteed by the hardware to be indivisible. When a thread performs <code>atomicAnd</code>, it reads the original value, performs the bitwise AND, and writes the new value back to memory without any other thread being able to interfere in the middle of that sequence. This is essential for safely manipulating shared bitmasks from multiple threads without race conditions.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#atomic-and"><code>atomicAnd</code></a></em></p><h4 id="use-case-109">Use Case</h4><p>Used to safely clear specific bits in a shared integer flag or bitmask. Each thread can use <code>atomicAnd</code> with a custom mask to clear its own bit without affecting the bits being modified by other threads.</p><pre><code class="language-wgsl">// A shared bitmask representing the completion status of 64 tasks.
// A &#39;1&#39; means the task is NOT complete.
var&lt;workgroup&gt; completion_mask: atomic&lt;u32&gt;;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(local_invocation_index) local_id: u32) {
    // A single thread initializes the mask to all &#39;1&#39;s, indicating no tasks are complete.
    if (local_id == 0u) {
        atomicStore(&amp;completion_mask, 0xFFFFFFFFu);
    }
    workgroupBarrier();

    // ... each thread performs its task ...

    // When a thread finishes its task, it clears its corresponding bit in the mask.
    // Create a mask to clear the bit at `local_id`.
    // `~` is the bitwise NOT operator. `1u &lt;&lt; local_id` creates a &#39;1&#39; at the thread&#39;s bit.
    // `~ (1u &lt;&lt; local_id)` creates a mask with a &#39;0&#39; at the thread&#39;s bit and &#39;1&#39;s everywhere else.
    let clear_mask = ~ (1u &lt;&lt; local_id);

    // `atomicAnd` safely applies this mask. For example, if the shared mask was ...1111
    // and our clear_mask is ...1011, the result will be ...1011.
    atomicAnd(&amp;completion_mask, clear_mask);
}
</code></pre><h3 id="atomicor"><code>atomicOr</code></h3><h4 id="signature-115">Signature</h4><p><code>atomicOr(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T) -&gt; T</code></p><ul><li><code>atomic_ptr</code>: A pointer to the atomic integer to be modified.<ul><li><code>AS</code>: The address space of the variable, typically workgroup or storage.</li><li><code>atomic&lt;T&gt;</code>: The special type indicating this memory is for atomic access.</li><li><code>read_write</code>: The access mode for the pointer.</li></ul></li><li><code>v</code>: The integer value to use for the bitwise OR operation.</li><li><code>T</code>: The data type, which must be either <code>i32</code> or <code>u32</code>.</li></ul><h4 id="description-120">Description</h4><p>Atomically performs a bitwise OR operation between the value <code>v</code> and the integer stored at the memory location <code>atomic_ptr</code>, storing the result back at <code>atomic_ptr</code>. The function returns the <strong>original value</strong> that was stored in memory before the OR operation occurred.</p><p>An <strong>atomic operation</strong> is guaranteed by the hardware to be indivisible. When a thread performs <code>atomicOr</code>, it reads the original value, performs the bitwise OR, and writes the new value back to memory without any other thread being able to interfere in the middle of that sequence. This is essential for safely manipulating shared bitmasks from multiple threads without race conditions.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#atomic-or"><code>atomicOr</code></a></em></p><h4 id="use-case-110">Use Case</h4><p>Used to safely set specific bits in a shared integer flag or bitmask. Each thread can use <code>atomicOr</code> with a custom mask to set its own bit without affecting the bits being modified by other threads.</p><pre><code class="language-wgsl">// A shared bitmask representing which tasks have completed.
// A &#39;1&#39; means the task IS complete.
var&lt;workgroup&gt; completion_mask: atomic&lt;u32&gt;;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(local_invocation_index) local_id: u32) {
    // A single thread initializes the mask to all &#39;0&#39;s.
    if (local_id == 0u) {
        atomicStore(&amp;completion_mask, 0u);
    }
    workgroupBarrier();

    // ... each thread performs its task ...
    var task_is_complete = true; // Based on some per-thread calculation.

    if (task_is_complete) {
        // Create a mask to set the bit corresponding to this thread&#39;s ID.
        let set_mask = 1u &lt;&lt; local_id;

        // `atomicOr` safely applies this mask. If thread 2 (mask ...0100) and
        // thread 3 (mask ...1000) both finish at the same time, the `atomicOr`
        // guarantees the final result will correctly have both bits set (...1100).
        atomicOr(&amp;completion_mask, set_mask);
    }
}
</code></pre><h3 id="atomicxor"><code>atomicXor</code></h3><h4 id="signature-116">Signature</h4><p><code>atomicXor(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T) -&gt; T</code></p><ul><li><code>atomic_ptr</code>: A pointer to the atomic integer to be modified.<ul><li><code>AS</code>: The address space of the variable, typically workgroup or storage.</li><li><code>atomic&lt;T&gt;</code>: The special type indicating this memory is for atomic access.</li><li><code>read_write</code>: The access mode for the pointer.</li></ul></li><li><code>v</code>: The integer value to use for the bitwise XOR operation.</li><li><code>T</code>: The data type, which must be either <code>i32</code> or <code>u32</code>.</li></ul><h4 id="description-121">Description</h4><p>Atomically performs a bitwise XOR operation between the value <code>v</code> and the integer stored at the memory location <code>atomic_ptr</code>, storing the result back at <code>atomic_ptr</code>. The function returns the <strong>original value</strong> that was stored in memory before the XOR operation occurred.</p><p>An <strong>atomic operation</strong> is guaranteed by the hardware to be indivisible. When a thread performs <code>atomicXor</code>, it reads the original value, performs the bitwise XOR, and writes the new value back to memory without any other thread being able to interfere in the middle of that sequence. This is essential for safely manipulating shared bitmasks from multiple threads without race conditions.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#atomic-xor"><code>atomicXor</code></a></em></p><h4 id="use-case-111">Use Case</h4><p>Used to safely toggle specific bits in a shared integer flag or bitmask. The XOR operation flips a bit if the corresponding bit in the mask is <code>1</code>, and leaves it unchanged if the mask bit is <code>0</code>.</p><pre><code class="language-wgsl">// A shared bitmask representing a set of toggleable states.
var&lt;workgroup&gt; toggle_states: atomic&lt;u32&gt;;

@compute @workgroup_size(32, 1, 1)
fn main(@builtin(local_invocation_index) local_id: u32) {
    // A single thread initializes the states.
    if (local_id == 0u) {
        atomicStore(&amp;toggle_states, 0u);
    }
    workgroupBarrier();

    // Imagine each thread decides it needs to flip the state of its corresponding bit.
    let should_toggle = some_per_thread_condition();

    if (should_toggle) {
        // Create a mask to toggle the bit for this thread&#39;s ID.
        let toggle_mask = 1u &lt;&lt; local_id;

        // `atomicXor` safely applies this mask. If a thread applies the mask, its bit
        // will flip (0-&gt;1 or 1-&gt;0). If multiple threads do this at the same time,
        // each toggle is guaranteed to be applied correctly without being lost.
        atomicXor(&amp;toggle_states, toggle_mask);
    }
}
</code></pre><h2 id="atomic-access-and-exchange-functions">Atomic Access and Exchange Functions</h2><p>This family of functions provides the fundamental primitives for reading, writing, and swapping values in shared memory atomically.</p><p>Unlike the “Read-Modify-Write” group, these operations do not perform arithmetic calculations. Instead, their focus is on direct memory access and replacement. This category includes the most basic atomic operations: safely reading a complete value from memory and safely writing a complete value to memory. It also contains more powerful primitives for unconditionally swapping a value with a new one, and for performing a conditional swap that only succeeds if the memory currently holds an expected value.</p><p>These functions are the essential building blocks for creating any complex, lock-free algorithm or synchronization mechanism in a compute shader, enabling multiple threads to coordinate their work on shared data without corruption.</p><h3 id="atomicload"><code>atomicLoad</code></h3><h4 id="signature-117">Signature</h4><p><code>atomicLoad(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;) -&gt; T</code></p><ul><li><code>atomic_ptr</code>: A pointer to the atomic integer to be read.<ul><li><code>AS</code>: The address space of the variable, typically workgroup or storage.</li><li><code>atomic&lt;T&gt;</code>: The special type indicating this memory is for atomic access.</li><li><code>read_write</code>: The access mode for the pointer.</li></ul></li><li><code>T</code>: The data type, which must be either <code>i32</code> or <code>u32</code>.</li></ul><h4 id="description-122">Description</h4><p>Atomically loads (reads) the integer value from the memory location <code>atomic_ptr</code> and returns it.</p><p>An <strong>atomic load</strong> guarantees that the entire value is read without being partially modified (“torn”) by another thread writing to the same location at the same time. It ensures you always get a coherent, complete value that was present at some point in time, even during concurrent write operations.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#atomic-load"><code>atomicLoad</code></a></em></p><h4 id="use-case-112">Use Case</h4><p>Used in compute shaders to safely read a shared value that may have been modified by other threads. It is often used after a <code>workgroupBarrier</code> to ensure all previous modifications are visible before the read.</p><pre><code class="language-wgsl">var&lt;workgroup&gt; shared_result: atomic&lt;u32&gt;;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(local_invocation_index) local_id: u32) {
    // A single thread calculates a result and stores it atomically.
    if (local_id == 0u) {
        let result = do_some_complex_calculation();
        atomicStore(&amp;shared_result, result);
    }

    // A workgroup barrier ensures that all threads wait until the `atomicStore`
    // from thread 0 is complete and its result is visible to all other threads.
    workgroupBarrier();

    // Now, all other threads can safely read the calculated result.
    // `atomicLoad` guarantees they get the complete, final value written by thread 0.
    let final_result = atomicLoad(&amp;shared_result);

    // ... use final_result in subsequent calculations ...
}
</code></pre><h3 id="atomicstore"><code>atomicStore</code></h3><h4 id="signature-118">Signature</h4><p><code>atomicStore(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T)</code></p><ul><li><code>atomic_ptr</code>: A pointer to the atomic integer to be modified.<ul><li><code>AS</code>: The address space of the variable, typically workgroup or storage.</li><li><code>atomic&lt;T&gt;</code>: The special type indicating this memory is for atomic access.</li><li><code>read_write</code>: The access mode for the pointer.</li></ul></li><li><code>v</code>: The integer value to store.</li><li><code>T</code>: The data type, which must be either <code>i32</code> or <code>u32</code>.</li></ul><h4 id="description-123">Description</h4><p>Atomically stores (writes) the integer value v to the memory location atomic_ptr. This function does not return a value.</p><p>An <strong>atomic store</strong> guarantees that the entire value is written without being partially overwritten (“torn”) by another thread writing to the same location at the same time. It ensures that any other thread reading this location will see either the value from before the store or the complete value from after the store, but never a corrupt, half-written value.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#atomic-store"><code>atomicStore</code></a></em></p><h4 id="use-case-113">Use Case</h4><p>Used in compute shaders to safely write to a shared memory location. It is the primary way to initialize an atomic variable or to publish a final result from one thread for other threads to read.</p><pre><code class="language-wgsl">var&lt;workgroup&gt; shared_result: atomic&lt;u32&gt;;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(local_invocation_index) local_id: u32) {
    // A single thread is designated to calculate and store an initial value.
    if (local_id == 0u) {
        let initial_value = 123u;

        // The atomic store ensures the value 123 is written completely
        // before any other thread can read it.
        atomicStore(&amp;shared_result, initial_value);
    }

    // A barrier is crucial here. It makes all other threads wait until the
    // store operation from thread 0 is complete and visible.
    workgroupBarrier();

    // Now other threads can safely load the initialized value.
    let value = atomicLoad(&amp;shared_result); // will be 123 for all threads
}
</code></pre><h3 id="atomicexchange"><code>atomicExchange</code></h3><h4 id="signature-119">Signature</h4><p><code>atomicExchange(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T) -&gt; T</code></p><ul><li><code>atomic_ptr</code>: A pointer to the atomic integer to be modified.<ul><li><code>AS</code>: The address space of the variable, typically workgroup or storage.</li><li><code>atomic&lt;T&gt;</code>: The special type indicating this memory is for atomic access.</li><li><code>read_write</code>: The access mode for the pointer.</li></ul></li><li><code>v</code>: The new integer value to store.</li><li><code>T</code>: The data type, which must be either <code>i32</code> or <code>u32</code>.</li></ul><h4 id="description-124">Description</h4><p>Atomically replaces the integer value at the memory location <code>atomic_ptr</code> with <code>v</code>. The function returns the <strong>original value</strong> that was stored in memory before the replacement occurred.</p><p>An <strong>atomic exchange</strong> is an indivisible “read-and-then-write” operation. It guarantees that the old value is read and the new value is written without any other thread being able to interfere in the middle of the sequence.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#atomic-exchange"><code>atomicExchange</code></a></em></p><h4 id="use-case-114">Use Case</h4><p>Used in compute shaders for algorithms that require a “claim and replace” pattern on a shared resource. A common example is implementing a simple spinlock or mutex.</p><pre><code class="language-wgsl">// A shared variable representing a lock. 0 means unlocked, 1 means locked.
var&lt;workgroup&gt; lock: atomic&lt;u32&gt;;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(local_invocation_index) local_id: u32) {
    // Initialize the lock to 0 (unlocked).
    if (local_id == 0u) {
        atomicStore(&amp;lock, 0u);
    }
    workgroupBarrier();

    // Try to acquire the lock.
    // `atomicExchange` attempts to write &#39;1&#39; (locked) and returns the previous value.
    // This entire operation is atomic.
    if (atomicExchange(&amp;lock, 1u) == 0u) {
        // If the previous value was &#39;0&#39; (unlocked), we have successfully
        // acquired the lock because we were the one to write the &#39;1&#39;.

        // ... perform critical section work here ...

        // Release the lock by storing &#39;0&#39; back.
        atomicStore(&amp;lock, 0u);
    }
}
</code></pre><h3 id="atomiccompareexchangeweak"><code>atomicCompareExchangeWeak</code></h3><h4 id="signature-120">Signature</h4><p><code>atomicCompareExchangeWeak(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, cmp: T, v: T) -&gt; R</code></p><ul><li><code>atomic_ptr</code>: A pointer to the atomic integer to be modified.<ul><li><code>AS</code>: The address space of the variable, typically workgroup or storage.</li><li><code>atomic&lt;T&gt;</code>: The special type indicating this memory is for atomic access.</li><li><code>read_write</code>: The access mode for the pointer.</li></ul></li><li><code>cmp</code>: The value to compare against the value stored at <code>atomic_ptr</code>.</li><li><code>v</code>: The new value to store if the comparison is successful.</li><li><code>T</code>: The data type, which must be either <code>i32</code> or <code>u32</code>.</li><li><code>R</code>: A special, built-in struct __<code>atomic_compare_exchange_result&lt;T&gt;</code> that cannot be declared by name. It must be inferred with <code>let</code>. This struct contains two members:<ul><li><code>old_value: T</code>: The value that was in memory at <code>atomic_ptr</code> before this operation began.</li><li><code>exchanged: bool</code>: <code>true</code> if the exchange was successful, <code>false</code> otherwise.</li></ul></li></ul><h4 id="description-125">Description</h4><p>Performs an atomic “compare-and-swap” (CAS) operation. This is a conditional write that is the most powerful of the atomic primitives, forming the basis for many complex, lock-free algorithms.</p><p>The operation follows these indivisible steps:</p><ol><li>Atomically reads the value at <code>atomic_ptr</code> (let’s call it <code>original_value</code>).</li><li>Compares <code>original_value</code> with the provided comparison value, <code>cmp</code>.</li><li><strong>If <code>original_value</code> equals <code>cmp</code></strong>, it atomically attempts to write the new value <code>v</code> to <code>atomic_ptr</code>.</li><li><strong>If <code>original_value</code> does not equal cmp</strong>, it does nothing.</li></ol><p><strong>The “Weak” Guarantee and Spurious Failures:</strong><br>The “weak” in the function’s name is critical. It means the operation can <strong>spuriously fail</strong>. This is a rare event where the exchanged member of the result will be <code>false</code> even though original_value was equal to <code>cmp</code>. This is a performance trade-off allowed by some hardware.</p><p>Because of this possibility, the standard and correct way to use this function is to <strong>always place it inside a <code>loop</code></strong>. The loop should repeat the attempt until <code>exchanged</code> is <code>true</code>.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#atomic-compare-exchange-weak"><code>atomicCompareExchangeWeak</code></a></em></p><h4 id="use-case-115">Use Case</h4><p>The canonical use case is implementing robust, lock-free data structures or synchronization primitives like a spinlock. The <code>loop</code> pattern is mandatory for correctness.</p><pre><code class="language-wgsl">// A shared variable representing a lock. 0 means unlocked, 1 means locked.
var&lt;workgroup&gt; lock: atomic&lt;u32&gt;;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(local_invocation_index) local_id: u32) {
    // Initialize the lock to 0 (unlocked).
    if (local_id == 0u) {
        atomicStore(&amp;lock, 0u);
    }
    workgroupBarrier();

    // Loop until we successfully acquire the lock.
    loop {
        // We expect the lock to be 0 (unlocked). This is our comparison value.
        let expected_value = 0u;

        // Attempt to swap the 0 with a 1 (locked).
        let result = atomicCompareExchangeWeak(&amp;lock, expected_value, 1u);

        // The operation succeeded if:
        // 1. The old value was indeed 0.
        // 2. The exchange was successful (no spurious failure).
        if (result.old_value == expected_value &amp;&amp; result.exchanged) {
            // We have successfully acquired the lock.
            break; // Exit the loop.
        }

        // If we failed (either because another thread got the lock first, or
        // a spurious failure), the loop will repeat the attempt.
    }

    // ... perform critical section work here ...

    // Release the lock. A simple store is sufficient.
    atomicStore(&amp;lock, 0u);
}
</code></pre><h2 id="synchronization-functions">Synchronization Functions</h2><p>This family of functions provides the essential tools for controlling the order of execution and memory visibility between different shader invocations (threads). They are the fundamental primitives for coordinating work in a parallel environment and are primarily used in <strong>compute shaders</strong>.</p><p>By default, shader threads execute independently, and the hardware makes no guarantees about their relative speed or the order in which their memory operations become visible to each other. This can lead to “race conditions,” where one thread reads a value before another thread has had a chance to write its result, leading to incorrect or unpredictable behavior.</p><p>Synchronization functions solve this problem by creating a <strong>barrier</strong>, which is a point in the shader code that all threads in a given scope (like a compute shader <code>workgroup</code>) must reach before any of them are allowed to proceed further. This enforces a strict order of operations. Crucially, barriers also enforce memory visibility, guaranteeing that all memory writes made before the barrier are completed and visible to all threads after the barrier. These functions are the indispensable traffic control for any algorithm that requires threads to collaborate on shared data.</p><h3 id="storagebarrier"><code>storageBarrier</code></h3><h4 id="signature-121">Signature</h4><p><code>storageBarrier()</code></p><p>This function takes no parameters and does not return a value.</p><h4 id="description-126">Description</h4><p>Executes a control barrier and synchronizes memory access for variables in the <code>storage</code> address space. This function is primarily used in <strong>compute shaders</strong>.</p><p>When <code>storageBarrier</code> is called, it has two effects:</p><ol><li><strong>Control Barrier:</strong> All shader invocations (threads) within the same workgroup must reach this point in the code before any of them are allowed to proceed further.</li><li><strong>Memory Barrier:</strong> It guarantees that all writes to <code>storage</code> and <code>atomic</code> variables in the storage address space performed by any thread in the workgroup before the barrier are completed and visible to all threads in the same workgroup after the barrier.</li></ol><p>This ensures that threads reading from a storage buffer after the barrier will not see stale data written by other threads before the barrier. Note that <a href="#workgroupbarrier"><code>workgroupBarrier</code></a> provides a stronger guarantee, as it synchronizes both <code>workgroup</code> and <code>storage</code> memory. <code>storageBarrier</code> is a more granular control for when you only need to synchronize <code>storage</code> access.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#storageBarrier-builtin"><code>storageBarrier</code></a></em></p><h4 id="use-case-116">Use Case</h4><p>Used to coordinate multi-stage algorithms within a compute shader workgroup that use a <code>storage</code> buffer for communication between threads.</p><pre><code class="language-wgsl">// A buffer in the storage address space, accessible for reading and writing.
@group(0) @binding(0) var&lt;storage, read_write&gt; data_buffer: array&lt;f32&gt;;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(local_invocation_id) local_id: vec3&lt;u32&gt;) {
    let idx = local_id.x;

    // --- Stage 1: Initial Calculation ---
    // Each thread performs a calculation and writes its result to the buffer.
    let initial_value = f32(idx) * 2.0;
    data_buffer[idx] = initial_value;

    // --- Synchronization ---
    // This barrier ensures that all 64 writes from Stage 1 are complete
    // and visible to all threads in this workgroup before anyone proceeds.
    storageBarrier();

    // --- Stage 2: Neighbor-dependent Calculation ---
    // Each thread now reads the results written by its neighbors in Stage 1
    // to perform a second calculation (e.g., a simple blur/average).
    let left_neighbor_val = data_buffer[idx - 1u];
    let right_neighbor_val = data_buffer[idx + 1u];

    // Without the barrier, a thread might read the old, incorrect value
    // from its neighbor&#39;s location before the neighbor had a chance to write its new value.
    data_buffer[idx] = (left_neighbor_val + initial_value + right_neighbor_val) / 3.0;
}
</code></pre><h3 id="workgroupbarrier"><code>workgroupBarrier</code></h3><h4 id="signature-122">Signature</h4><p><code>workgroupBarrier()</code></p><p>This function takes no parameters and does not return a value.</p><h4 id="description-127">Description</h4><p>Executes a control barrier and synchronizes memory access for variables in both the <code>workgroup</code> and <code>storage</code> address spaces. This is the strongest synchronization function and is exclusively used in <strong>compute shaders</strong>.</p><p>When <code>workgroupBarrier</code> is called, it has two effects:</p><ol><li><strong>Control Barrier:</strong> All shader invocations (threads) within the same workgroup must reach this point in the code before any of them are allowed to proceed further. This synchronizes the execution flow of all threads in the workgroup.</li><li><strong>Memory Barrier:</strong> It guarantees that all writes to <code>workgroup</code> variables, <code>storage</code> buffers, and <code>atomic</code> variables in those address spaces performed by any thread in the workgroup before the barrier are completed and visible to all other threads in the workgroup after the barrier.</li></ol><p>This is the most common barrier function, as it provides a comprehensive guarantee that a stage of a parallel algorithm is fully complete before the next stage begins.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#workgroupBarrier-builtin"><code>workgroupBarrier</code></a></em></p><h4 id="use-case-117">Use Case</h4><p>Used to coordinate multi-stage algorithms within a compute shader workgroup, especially when using the fast <code>workgroup</code> memory for communication between threads. A classic example is a parallel reduction (e.g., finding the sum of a large array).</p><pre><code class="language-wgsl">// A shared array in fast `workgroup` memory to hold data for one workgroup.
var&lt;workgroup&gt; local_data: array&lt;f32, 64&gt;;

@group(0) @binding(0) var&lt;storage, read&gt; input_data: array&lt;f32&gt;;
@group(0) @binding(1) var&lt;storage, read_write&gt; output_data: array&lt;f32&gt;;

@compute @workgroup_size(64, 1, 1)
fn main(
    @builtin(global_invocation_id) global_id: vec3&lt;u32&gt;,
    @builtin(local_invocation_id) local_id: vec3&lt;u32&gt;,
) {
    let idx = local_id.x;

    // --- Stage 1: Load data from slow global storage to fast workgroup memory ---
    local_data[idx] = input_data[global_id.x];

    // --- Synchronization ---
    // This is CRITICAL. It ensures every thread has finished loading its data
    // into `local_data` before anyone starts reading from it.
    workgroupBarrier();

    // --- Stage 2: Parallel reduction in workgroup memory ---
    // (This is a simplified reduction loop)
    var stride = 32u;
    loop {
        if (stride == 0u) { break; }
        if (idx &lt; stride) {
            local_data[idx] = local_data[idx] + local_data[idx + stride];
        }
        // Barrier inside the loop ensures each level of the reduction is complete
        // before the next level begins.
        workgroupBarrier();
        stride = stride / 2u;
    }

    // --- Stage 3: Write final result ---
    // After the reduction, thread 0 holds the sum for the entire workgroup.
    if (idx == 0u) {
        output_data[global_id.x / 64u] = local_data[0];
    }
}
</code></pre><h3 id="workgroupuniformload"><code>workgroupUniformLoad</code></h3><h4 id="signature-123">Signature</h4><p><code>workgroupUniformLoad(p : ptr&lt;workgroup, T&gt;) -&gt; T</code></p><ul><li><code>p</code>: A pointer to a variable in the workgroup address space. The pointer <code>p</code> itself must be a uniform value (i.e., it must be the same for all invocations in the workgroup).</li><li><code>T</code>: A concrete, non-atomic type with a fixed size, such as <code>f32</code>, <code>vec4&lt;i32&gt;</code>, or a user-defined struct that meets these criteria.</li></ul><h4 id="description-128">Description</h4><p>Atomically reads a value from <code>workgroup</code> memory and <strong>broadcasts</strong> that single value to every invocation (thread) in the workgroup. This function is exclusively used in <strong>compute shaders</strong>.</p><p><code>workgroupUniformLoad</code> has two critical, combined effects:</p><ol><li><strong>Uniform Return Value:</strong> It guarantees that every single thread in the workgroup receives the exact same return value. This is powerful because using this uniform result in a subsequent <code>if</code> statement or loop condition will not cause thread divergence within the workgroup.</li><li><strong>Implicit Barrier:</strong> It executes a control barrier and synchronizes memory for the <code>workgroup</code> address space. This means all threads must reach this function call before any can proceed, and all writes to <code>workgroup</code> memory before the call are guaranteed to be visible to the load operation. It effectively combines a <code>workgroupBarrier</code> with a subsequent load.</li></ol><p>It provides a single, synchronized value that can be safely used to direct the flow of the entire workgroup.</p><p><em>W3C Specification: <a href="https://www.w3.org/TR/WGSL/#workgroupUniformLoad-builtin"><code>workgroupUniformLoad</code></a></em></p><h4 id="use-case-118">Use Case</h4><p>Used to efficiently distribute a single, workgroup-wide value that is calculated by one thread to all other threads in that workgroup, while also providing the necessary synchronization.</p><pre><code class="language-wgsl">// A shared variable in workgroup memory.
var&lt;workgroup&gt; workgroup_id: u32;

@compute @workgroup_size(64, 1, 1)
fn main(
    @builtin(local_invocation_id) local_id: vec3&lt;u32&gt;,
    @builtin(workgroup_id) group_id: vec3&lt;u32&gt;
) {
    // ---- The &quot;Manual&quot; Way ----
    // A single thread calculates a group-wide value.
    if (local_id.x == 0u) {
        workgroup_id = group_id.x;
    }
    // A barrier is required to make the write visible to all other threads.
    workgroupBarrier();
    // Now every thread loads the value.
    let id_manual = workgroup_id;


    // ---- The `workgroupUniformLoad` Way ----
    // A single thread calculates a group-wide value.
    if (local_id.x == 0u) {
        workgroup_id = group_id.x;
    }
    // This single function both waits for all threads (acting as a barrier)
    // and loads the value written by thread 0 into a uniform variable for all threads.
    let id_uniform = workgroupUniformLoad(&amp;workgroup_id);

    // Because `id_uniform` is guaranteed to be the same for all threads,
    // this &#39;if&#39; statement will not cause thread divergence.
    if (id_uniform % 2u == 0u) {
        // ... all threads in this workgroup will either enter this block, or none will ...
    }
}
</code></pre></div></article></main><footer class="footer"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://xav.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://xav.github.io/assets/js/scripts.min.js?v=ffcbea6c02c8178d10092962b235a5b0"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>