<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bevy &amp; WGSL: Data Types &amp; Variables</title><meta name="description" content="Master WGSL data types for Bevy shaders. Our guide covers scalars, vectors (vec3, vec4), swizzling, and variables (let/var) for your first shader."><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="stylesheet" href="https://xav.github.io/media/plugins/syntaxHighlighter/prism-black.css"><link rel="canonical" href="https://xav.github.io/12-wgsl-fundamentals-data-types-and-variables-2/"><link rel="alternate" type="application/atom+xml" href="https://xav.github.io/feed.xml" title="Hexbee&#x27;s Dev Journal - RSS"><link rel="alternate" type="application/json" href="https://xav.github.io/feed.json" title="Hexbee&#x27;s Dev Journal - JSON"><meta property="og:title" content="1.2 - WGSL Fundamentals - Data Types & Variables"><meta property="og:image" content="https://xav.github.io/media/posts/5/cover2.png"><meta property="og:image:width" content="1344"><meta property="og:image:height" content="768"><meta property="og:site_name" content="Hexbee's Dev Journal"><meta property="og:description" content="Master WGSL data types for Bevy shaders. Our guide covers scalars, vectors (vec3, vec4), swizzling, and variables (let/var) for your first shader."><meta property="og:url" content="https://xav.github.io/12-wgsl-fundamentals-data-types-and-variables-2/"><meta property="og:type" content="article"><link rel="stylesheet" href="https://xav.github.io/assets/css/style.css?v=e19cced6341d15e84c3d202e5e386440"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://xav.github.io/12-wgsl-fundamentals-data-types-and-variables-2/"},"headline":"1.2 - WGSL Fundamentals - Data Types & Variables","datePublished":"2025-12-13T19:31+01:00","dateModified":"2025-12-13T19:38+01:00","image":{"@type":"ImageObject","url":"https://xav.github.io/media/posts/5/cover2.png","height":768,"width":1344},"description":"Master WGSL data types for Bevy shaders. Our guide covers scalars, vectors (vec3, vec4), swizzling, and variables (let/var) for your first shader.","author":{"@type":"Person","name":"Xavier Basty Kjellberg","url":"https://xav.github.io/authors/xavier-basty-kjellberg/"},"publisher":{"@type":"Organization","name":"Xavier Basty Kjellberg","logo":{"@type":"ImageObject","url":"https://xav.github.io/media/website/Logo-SideName.png","height":2297,"width":5553}}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><div class="container"><header class="header"><div class="header__logo"><a class="logo" href="https://xav.github.io/"><img src="https://xav.github.io/media/website/Logo-SideName.png" alt="Hexbee&#x27;s Dev Journal" width="5553" height="2297"></a></div></header><main class="content"><article class="post"><header><h1 class="post__title">1.2 - WGSL Fundamentals - Data Types &amp; Variables</h1><div class="post__meta"><time datetime="2025-12-13T19:31" class="post__date">December 13, 2025 </time><span class="post__author"><a href="https://xav.github.io/authors/xavier-basty-kjellberg/" class="feed__author">Xavier Basty Kjellberg</a></span></div><div class="post__tags"><a href="https://xav.github.io/tags/webgpu/" class="invert">bevy</a> <a href="https://xav.github.io/tags/rust/" class="invert">rust</a> <a href="https://xav.github.io/tags/shaders/" class="invert">shaders</a> <a href="https://xav.github.io/tags/wgsl/" class="invert">wgsl</a></div></header><figure class="post__image post__cover"><img src="https://xav.github.io/media/posts/5/cover2.png" srcset="https://xav.github.io/media/posts/5/responsive/cover2-xs.webp 300w, https://xav.github.io/media/posts/5/responsive/cover2-sm.webp 480w, https://xav.github.io/media/posts/5/responsive/cover2-md.webp 768w, https://xav.github.io/media/posts/5/responsive/cover2-lg.webp 1024w" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" height="768" width="1344" alt=""></figure><div class="post__entry"><h2 id="what-were-learning">What We’re Learning</h2><p>In our last article, we built a mental model of the graphics pipeline: a VFX studio where “Layout Artists” (Vertex Shaders) position geometry and “Coloring Artists” (Fragment Shaders) paint the final pixels. But what materials do these artists work with? How do we hand them a 3D coordinate to transform, a surface direction for lighting, or a final color to paint? How do we describe the data that flows through their assembly line?</p><p>This is where WGSL’s data types come in. These aren’t generic programming types; they are the fundamental vocabulary of the GPU - the digital clay, paint, and transformation tools our artists use to build a visual world. Learning them is like learning the alphabet before you can write a story.</p><p>At the lowest level, we have <strong>scalar</strong> types - the individual numbers that form the atoms of our data. But the real power comes from combining these into <strong>vectors</strong>, the workhorse of every shader, representing everything from a <code>vec3&lt;f32&gt;</code> position to a <code>vec4&lt;f32&gt;</code> RGBA color. And to manipulate these vectors - to move, rotate, and project them - we use <strong>matrices</strong>, the mathematical machines of transformation.</p><p>By the end of this article, you’ll understand:</p><ul><li>The atomic building blocks of all shader data: <code>f32</code>, <code>i32</code>, <code>u32</code>, and <code>bool</code>.</li><li>The workhorse of all shaders: how <strong>vectors</strong> (<code>vec2</code>, <code>vec3</code>, <code>vec4</code>) represent everything from 3D positions to RGBA colors.</li><li>The language of transformation: how <strong>matrices</strong> (<code>mat4x4</code>) are the machines that move, rotate, and scale your geometry.</li><li>The crucial difference between an immutable <code>let</code> (a constant) and a mutable <code>var</code> (a variable), and why you should almost always prefer <code>let</code>.</li><li>Powerful GPU-native shortcuts like <strong>constructors</strong> for building vectors and <strong>swizzling</strong> for efficiently accessing and rearranging their components.</li></ul><h2 id="scalar-types-the-basics">Scalar Types: The Basics</h2><p>At the heart of all shader calculations are <strong>scalar</strong> types. A scalar is simply a single value, like one number or a boolean state. WGSL provides four fundamental scalar types that serve as the atoms for all the more complex data we will build.</p><h3 id="floating-point-numbers-f32">Floating-Point Numbers: <code>f32</code></h3><p>This is the single most important type in WGSL and your absolute workhorse for graphics programming. It represents a 32-bit floating-point number, which is essential for describing any data that is continuous and requires precision.</p><pre><code class="language-wgsl">let pi: f32 = 3.14159;
let half: f32 = 0.5;
let negative_one_point_five: f32 = -1.5;
</code></pre><p><strong>Key Rule:</strong> WGSL is very strict about types. A number literal without a decimal point is treated as an integer. To create an <code>f32</code>, you <strong>must</strong> include a decimal point, even for whole numbers.</p><pre><code class="language-wgsl">let correct_float: f32 = 1.0; // ✓ Correct, this is a float.
let wrong: f32 = 1;           // ✗ COMPILE ERROR: Cannot assign an integer to an f32.
</code></pre><p>You will use <code>f32</code> for almost everything, including:</p><ul><li>Positions (X, Y, Z coordinates)</li><li>Colors (R, G, B channels)</li><li>Texture Coordinates (U, V)</li><li>Time, opacity, and any fractional value</li></ul><h3 id="signed-integers-i32">Signed Integers: <code>i32</code></h3><p>This is a standard 32-bit signed integer, meaning it can represent both positive and negative whole numbers.</p><pre><code class="language-wgsl">let count: i32 = 42;
let negative_ten: i32 = -10;
let zero: i32 = 0;
</code></pre><p>Use <code>i32</code> when you need whole numbers and the possibility of a negative value is meaningful, such as for:</p><ul><li>Loop counters that might count down</li><li>Calculations involving differences or offsets</li><li>Bitwise operations</li></ul><h3 id="unsigned-integers-u32">Unsigned Integers: <code>u32</code></h3><p>This is a 32-bit unsigned integer, meaning it can only represent non-negative whole numbers (zero and positive values).</p><pre><code class="language-wgsl">let index: u32 = 0u;
let size: u32 = 256u;
</code></pre><p><strong>Key Rule:</strong> To distinguish an unsigned integer literal from a signed one, you <strong>must</strong> add a <code>u</code> suffix.</p><p>Use u32 when a value can never logically be negative. This is both a safety feature and a way to signal intent. Common uses include:</p><ul><li>Array indices and lengths</li><li>Bevy’s <code>@builtin(instance_index)</code></li><li>Identifiers or flags packed into an integer</li></ul><h3 id="booleans-bool">Booleans: <code>bool</code></h3><p>The <code>bool</code> type represents a simple <code>true</code> or <code>false</code> value.</p><pre><code class="language-wgsl">let is_visible: bool = true;
let has_texture: bool = false;
</code></pre><p>Booleans are the foundation of all logic and control flow in your shaders. You’ll use them for:</p><ul><li><code>if/else</code> statements and other conditional logic</li><li>Storing the result of a comparison (e.g., <code>let is_close = distance &lt; 1.0;</code>)</li><li>Flags passed in from your Rust code to enable or disable shader features</li></ul><h2 id="vector-types-your-new-best-friends">Vector Types: Your New Best Friends</h2><p>If scalars are the atoms of our data, <strong>vectors</strong> are the molecules. They are the heart and soul of shader programming. A vector is an ordered collection of scalars, but in graphics, it’s a powerful tool for representing multi-dimensional data like positions, colors, and directions.</p><p>The GPU is a parallel processing beast. It is specifically designed to perform the same mathematical operation on large batches of data all at once. Vectors are the native language of this architecture. When you add two <code>vec3</code> values together, the GPU can perform all three additions (x+x, y+y, z+z) simultaneously. Using vectors effectively is the key to unlocking the GPU’s performance and writing elegant shader code.</p><h3 id="vector-syntax">Vector Syntax</h3><p>WGSL defines vectors with a simple, clear syntax: <code>vecN&lt;T&gt;</code>, where <code>N</code> is the number of components (2, 3, or 4) and <code>T</code> is the scalar type of those components. While you can create vectors of any scalar type, floating-point vectors are used in over 99% of graphics operations.</p><table><thead><tr><th>Type</th><th>Common Usage</th></tr></thead><tbody><tr><td><code>vec2&lt;f32&gt;</code></td><td>2D positions, and especially texture coordinates (UVs).</td></tr><tr><td><code>vec3&lt;f32&gt;</code></td><td>The workhorse for 3D graphics: 3D positions, RGB colors, surface normals, direction vectors.</td></tr><tr><td><code>vec4&lt;f32&gt;</code></td><td>RGBA colors (with an alpha channel for transparency) and homogeneous coordinates, such as the final clip-space position from a vertex shader.</td></tr><tr><td><code>vec2&lt;i32&gt;</code></td><td>Less common, but useful for things like integer grid coordinates or texture dimensions in pixels.</td></tr></tbody></table><h3 id="creating-vectors-constructors">Creating Vectors (Constructors)</h3><p>WGSL provides a flexible set of “constructors” to build vectors in whatever way is most convenient. This lets you write clean, readable code without needing to manually handle every single component.</p><pre><code class="language-wgsl">// 1. From individual scalar components: The most direct method.
let pos = vec3&lt;f32&gt;(1.0, 2.0, 3.0);
let red = vec4&lt;f32&gt;(1.0, 0.0, 0.0, 1.0); // Red with full alpha

// 2. From a single value (a &quot;splat&quot;): A useful shortcut.
// This creates a vector where all components have the same value.
let gray = vec3&lt;f32&gt;(0.5); // Equivalent to vec3&lt;f32&gt;(0.5, 0.5, 0.5)

// 3. Combining smaller vectors and scalars: Extremely common and powerful.
// The components are simply concatenated in order to form the new vector.
let xy = vec2&lt;f32&gt;(1.0, 2.0);
let xyz = vec3&lt;f32&gt;(xy, 3.0);       // -&gt; Creates vec3(1.0, 2.0, 3.0)
let xyzw = vec4&lt;f32&gt;(xy, 3.0, 4.0); // -&gt; Creates vec4(1.0, 2.0, 3.0, 4.0)

// 4. From another vector and a scalar: The classic way to add a dimension.
// A common example is adding an alpha channel to an existing RGB color.
let rgb_color = vec3&lt;f32&gt;(1.0, 0.5, 0.0); // An orange color
let rgba_color = vec4&lt;f32&gt;(rgb_color, 1.0); // -&gt; Creates vec4(1.0, 0.5, 0.0, 1.0)
</code></pre><h3 id="accessing-vector-components">Accessing Vector Components</h3><p>To work with vectors, you need to access their individual components. WGSL gives you several accessor “schemes” which are aliases for each other. Using the right scheme is a best practice that makes your code much more readable by signaling your intent.</p><pre><code class="language-wgsl">let my_vector = vec4&lt;f32&gt;(1.0, 0.5, 0.0, 1.0);

// The &quot;spatial&quot; or &quot;geometric&quot; scheme: x, y, z, w
// Use this when the vector represents a position, direction, or texture coordinate.
let x_pos = my_vector.x; // 1.0

// The &quot;color&quot; scheme: r, g, b, a
// Use this when the vector represents a color. This makes the code self-documenting.
let green_channel = my_vector.g; // 0.5

// By index (0-based array-style access)
// This is less common for direct access but is useful for programmatic access,
// for instance, if you were iterating through a vector&#39;s components in a loop.
let first_component = my_vector[0]; // 1.0
</code></pre><h3 id="vector-swizzling-a-gpu-superpower">Vector Swizzling: A GPU Superpower</h3><p>“Swizzling” is a powerful and highly efficient GPU feature that lets you create a new vector by rearranging, duplicating, or selecting components from an existing vector. It’s not just a syntax shortcut; it compiles to a single, incredibly fast hardware instruction.</p><pre><code class="language-wgsl">let color = vec4&lt;f32&gt;(1.0, 0.5, 0.0, 1.0); // A bright orange color

// 1. Extract a subset of components
// A very common use is to get the RGB part of an RGBA color.
let rgb = color.rgb; // -&gt; Creates a new vec3&lt;f32&gt; with (1.0, 0.5, 0.0)
let rg = color.rg;   // -&gt; Creates a new vec2&lt;f32&gt; with (1.0, 0.5)

// 2. Reorder components
// Useful for converting between different data layouts (e.g., from an image format).
let bgr = color.bgr; // -&gt; Creates vec3(0.0, 0.5, 1.0). The components are reversed!

// 3. Duplicate components
// A great way to create grayscale values or fill a vector from a single channel.
let grayscale_from_red = color.rrr; // -&gt; Creates vec3(1.0, 1.0, 1.0)

// 4. Mix and match to build new vectors
// This is where swizzling shines for geometric operations.
let pos = vec3&lt;f32&gt;(1.0, 2.0, 3.0);
let yxz = pos.yxz; // -&gt; Creates vec3(2.0, 1.0, 3.0)

// A classic use case: using the X and Z components of a 3D position
// for 2D calculations, like looking up a texture for a ground plane.
let ground_coords = pos.xz; // -&gt; Creates vec2(1.0, 3.0)
</code></pre><p>You can use the accessor schemes <code>xyzw</code>, <code>rgba</code>, or <code>stpq</code> (a convention for texture coordinates) for swizzling. They all access the same underlying components (0, 1, 2, 3), but you <strong>cannot mix schemes</strong> in a single swizzle (e.g., <code>color.xb</code> is illegal).</p><h3 id="vector-arithmetic">Vector Arithmetic</h3><p>Arithmetic operations on vectors are performed <strong>component-wise</strong>. This means the operation is applied independently to each pair of corresponding components. This is a fundamental concept for everything from blending colors to manipulating positions.</p><pre><code class="language-wgsl">let a = vec3&lt;f32&gt;(1.0, 2.0, 3.0);
let b = vec3&lt;f32&gt;(4.0, 5.0, 6.0);

// Addition: result.x = a.x + b.x, result.y = a.y + b.y, etc.
// Use case: Combining light sources, offsetting a position.
let sum = a + b; // -&gt; Result: vec3(5.0, 7.0, 9.0)

// Subtraction: result.x = a.x - b.x, etc.
// Use case: Finding the direction vector from point A to point B (B - A).
let diff = b - a; // -&gt; Result: vec3(3.0, 3.0, 3.0)

// Multiplication (component-wise!): result.x = a.x * b.x, etc.
// Use case: Tinting. Multiplying a base color by a texture color.
let product = a * b; // -&gt; Result: vec3(4.0, 10.0, 18.0)

// Operations with a scalar: The scalar is applied to every component.
// Use case: Uniform scaling an object or changing the brightness of a color.
let scaled_up = a * 2.0;   // -&gt; Result: vec3(2.0, 4.0, 6.0)
let scaled_down = b / 2.0; // -&gt; Result: vec3(2.0, 2.5, 3.0)
</code></pre><p><strong>CRITICAL:</strong> Standard vector multiplication (<code>*</code>) is <strong>component-wise multiplication</strong>, often called the <a href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)">Hadamard product</a>. It is <strong>NOT</strong> a dot product or a cross product! WGSL provides separate built-in functions (<code>dot()</code>, <code>cross()</code>) for those, which we will cover in a later article. This is one of the most common points of confusion for beginners.</p><h2 id="matrix-types-for-transformations">Matrix Types: For Transformations</h2><p>If vectors represent points and directions, then a <strong>matrix</strong> is the machine that transforms them. Matrices are the mathematical tool we use to perform all the essential 3D operations we discussed in the graphics pipeline: moving (translation), rotating, and scaling objects. They are the engine that powers the journey of a vertex through different coordinate spaces.</p><p>A matrix is a grid of numbers arranged in columns and rows. In WGSL, the syntax is <code>matCxR&lt;T&gt;</code>, where <code>C</code> is the number of columns, <code>R</code> is the number of rows, and <code>T</code> is the scalar type (almost always <code>f32</code>).</p><h3 id="common-matrix-types">Common Matrix Types</h3><p>While various sizes exist, you will primarily work with <code>mat4x4&lt;f32&gt;</code> in 3D graphics.</p><table><thead><tr><th>Type</th><th>Common Usage</th></tr></thead><tbody><tr><td><code>mat4x4&lt;f32&gt;</code></td><td>The cornerstone of 3D graphics. A single 4x4 matrix can store a combination of translation, rotation, and scale for a 3D object. Bevy’s Model, View, and Projection matrices are all of this type.</td></tr><tr><td><code>mat3x3&lt;f32&gt;</code></td><td>Often used for transforming 3D direction vectors like normals, where translation information should be ignored.</td></tr><tr><td><code>mat2x2&lt;f32&gt;</code></td><td>Used for 2D transformations, for example, rotating or scaling UV coordinates in a fragment shader.</td></tr></tbody></table><p>In your Bevy shaders, you’ll mostly receive <code>mat4x4&lt;f32&gt;</code> matrices from the engine and use them to transform your vertex positions.</p><h3 id="creating-matrices-and-column-major-order">Creating Matrices and Column-Major Order</h3><p>You will rarely build transformation matrices from scratch inside a shader - Bevy’s <code>Transform</code> component does that complex work for you on the CPU. However, it’s crucial to understand how they are constructed. The constructor takes the values for each <strong>column</strong>, one after the other.</p><p><strong>Key Concept:</strong> WGSL matrices, like those in most modern graphics APIs, are <strong>column-major</strong>. This defines how the numbers you provide are stored in memory. It means you provide all the data for the first column, then all for the second, and so on.</p><p>Think of it as filling the matrix grid vertically, one column at a time:</p><pre><code class="language-wgsl">// A 4x4 identity matrix (which represents &quot;no transformation&quot;).
let identity = mat4x4&lt;f32&gt;(
//  Col 0     Col 1     Col 2     Col 3
    1.0, 0.0, 0.0, 0.0,  // Row 0
    0.0, 1.0, 0.0, 0.0,  // Row 1
    0.0, 0.0, 1.0, 0.0,  // Row 2
    0.0, 0.0, 0.0, 1.0   // Row 3
);

// This is wrong! The constructor takes columns, not rows.
// let wrong = mat4x4&lt;f32&gt;(row0, row1, row2, row3); // ✗

// You can also construct a matrix from column vectors. This is often clearer.
let col0 = vec4&lt;f32&gt;(1.0, 0.0, 0.0, 0.0);
let col1 = vec4&lt;f32&gt;(0.0, 1.0, 0.0, 0.0);
let col2 = vec4&lt;f32&gt;(0.0, 0.0, 1.0, 0.0);
let col3 = vec4&lt;f32&gt;(0.0, 0.0, 0.0, 1.0);
let from_vectors = mat4x4&lt;f32&gt;(col0, col1, col2, col3);
</code></pre><h3 id="accessing-matrix-elements">Accessing Matrix Elements</h3><p>Accessing matrix data follows this column-major logic. The most important rule to remember is: <strong>column-first, then row</strong>.</p><pre><code class="language-wgsl">let m = ... // some mat4x4&lt;f32&gt;

// Get an entire column as a vector
let second_column: vec4&lt;f32&gt; = m[1]; // Index 1 gives you the second column.

// Access a specific element: matrix[column_index][row_index]
let element_c1_r2 = m[1][2]; // Get the element in Column 1, Row 2.
</code></pre><h3 id="the-magic-matrix-vector-multiplication">The Magic: Matrix-Vector Multiplication</h3><p>The real power of a matrix is revealed when you multiply it by a vector. This operation <strong>applies the transformation</strong> stored in the matrix to the vector, producing a new, transformed vector.</p><p>This is <strong>NOT</strong> component-wise multiplication! It’s a special mathematical operation that correctly rotates, scales, and translates the vector. We will dive deep into the math in a later article. For now, just focus on the syntax and the result.</p><pre><code class="language-wgsl">// Conceptual vertex shader code
// These matrices are provided by Bevy&#39;s renderer.
let model_matrix: mat4x4&lt;f32&gt; = ...;
let view_matrix: mat4x4&lt;f32&gt; = ...;
let projection_matrix: mat4x4&lt;f32&gt; = ...;

// The original vertex position from the mesh.
// We use a vec4 with w=1.0 for positions so that translation works correctly.
let local_position = vec4&lt;f32&gt;(1.0, 2.0, 3.0, 1.0);

// Apply the transformations in sequence.
// Note the order: Projection * View * Model * Position
let world_position = model_matrix * local_position;
let view_position = view_matrix * world_position;
let clip_position = projection_matrix * view_position;
</code></pre><p>This sequence of multiplications is the absolute core of every 3D vertex shader. It’s the code that executes the “Coordinate Space Journey” we learned about previously, taking a vertex from its local blueprint all the way to its final place on the screen.</p><h2 id="variables-var-vs-let">Variables: <code>var</code> vs <code>let</code></h2><p>WGSL provides two keywords for declaring a named value: <code>let</code> and var<code>.</code> The choice between them is one of the most important you’ll make, as it signals your intent and has major consequences for safety and performance. The core difference is <strong>mutability</strong>: can the value change after it’s been declared?</p><h3 id="let-immutable-constants"><code>let</code>: Immutable Constants</h3><p>The <code>let</code> keyword declares a <strong>runtime constant</strong>. Once you assign a value to a <code>let</code> binding, it is frozen and <strong>cannot be changed</strong> for the rest of its scope. You should think of it as a named placeholder for a fixed value.</p><pre><code class="language-wgsl">let pi = 3.14159;
let base_color = vec3&lt;f32&gt;(1.0, 0.5, 0.2); // An orange color

// The following lines would cause a compilation error:
// pi = 3.14;                 // ✗ ERROR: Cannot reassign a `let` constant.
// base_color.r = 0.8;        // ✗ ERROR: Cannot modify a component of a `let` constant.
</code></pre><h4 id="why-you-should-prefer-let">Why You Should Prefer <code>let</code></h4><p>As a best practice, <strong>you should use <code>let</code> for every value you declare by default</strong>. This habit makes your code safer, more readable, and often more performant.</p><ol><li><strong>Safety and Readability</strong>: When you see let, you have a guarantee that the value will never change within that part of the code. This makes shaders much easier to read and reason about, as you don’t need to track potential modifications. It prevents a whole class of bugs caused by accidental reassignment.</li><li><strong>Performance and Optimization</strong>: Declaring a value as immutable gives the shader compiler critical information. The compiler knows the value is constant, which allows for powerful optimizations. It might perform calculations at compile time (“constant folding”), store the value more efficiently in a register, or remove entire branches of code. In a highly parallel environment like a GPU, working with immutable data is fundamentally more efficient.</li></ol><h3 id="var-mutable-variables"><code>var</code>: Mutable Variables</h3><p>For situations where a value must change after it has been declared, WGSL provides the var keyword. This declares a <strong>mutable variable</strong>, the traditional variable type you might be used to from other languages. Its value can be changed at any time.</p><pre><code class="language-wgsl">// Declare a mutable variable for a counter
var counter = 0;
counter = counter + 1; // ✓ This is perfectly valid.

// Declare a mutable color to be modified
var color = vec3&lt;f32&gt;(1.0, 0.0, 0.0);
color.r = 0.5; // Modify the red component
color.gb = vec2&lt;f32&gt;(0.2, 0.8); // Modify the green and blue components with a swizzle
</code></pre><h4 id="when-to-use-var">When to Use <code>var</code></h4><p>You should only resort to using <code>var</code> when immutability is not an option. Legitimate scenarios include:</p><ul><li><strong>Accumulators</strong>: When you are summing up values in a loop, such as calculating the total light contribution from multiple light sources.</li></ul><pre><code class="language-wgsl">var total_light = vec3&lt;f32&gt;(0.0);
for (var i = 0; i &lt; 4; i = i + 1) {
    total_light = total_light + calculate_light_contribution(i);
}
</code></pre><ul><li><strong>Loop Counters</strong>: The counter in a for loop must be a <code>var</code>.</li><li><strong>Step-by-Step Modification</strong>: When you start with a base value and apply a series of complex, conditional modifications to it.</li></ul><pre><code class="language-wgsl">var final_color = texture_color;
if (is_in_shadow) {
    final_color = final_color * 0.5;
}
final_color = apply_fog(final_color, distance);
</code></pre><p>Even in this case, it’s often possible (and clearer) to rewrite the logic using <code>let</code> for each stage, as it forces a more explicit data flow.</p><h3 id="type-inference">Type Inference</h3><p>WGSL’s compiler is smart and can often infer a variable’s type from the value you assign to it.</p><pre><code class="language-wgsl">let x = 1.0;                    // Inferred as f32
let pos = vec3(1.0, 2.0, 3.0);  // Components are f32, so inferred as vec3&lt;f32&gt;
let count = 0;                  // Inferred as i32
let flag = true;                // Inferred as bool
</code></pre><p>Technically, number literals like <code>1</code> or <code>1.0</code> start as “abstract” integers or floats. The compiler gives them a concrete type (<code>i32</code>, <code>f32</code>, etc.) the first time they are used in a context that requires one. For <code>let count = 0;</code>, the default concrete type for an abstract integer is <code>i32</code>. This is why type inference works so smoothly.</p><p>While inference is convenient, being explicit about types can sometimes make your code clearer and prevent subtle bugs, especially when you intend to use a less common type like <code>u32</code>.</p><pre><code class="language-wgsl">// Explicit types for clarity
let x: f32 = 1.0;
let pos: vec3&lt;f32&gt; = vec3(1.0, 2.0, 3.0);
let frame_index: u32 = 0u; // Explicitly an unsigned integer
</code></pre><h2 id="putting-it-all-together-a-common-workflow">Putting It All Together: A Common Workflow</h2><p>We’ve learned about scalars, vectors, and the let keyword as separate concepts. Now, let’s put them all together. The following snippet demonstrates a common and powerful workflow you’ll use constantly in your shaders: starting with base values and creating new ones in a series of clear, immutable steps.</p><p>This isn’t a runnable demo, but rather a perfect illustration of how the pieces fit together to achieve a result.</p><pre><code class="language-wgsl">@fragment
fn fragment(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    // Step 1: Define our starting point with `let` and a vector constructor.
    // This base value itself won&#39;t change; we will create new constants based on it.
    let base_color = vec3&lt;f32&gt;(1.0, 0.5, 0.2);

    // Step 2: Adjust brightness with scalar-vector multiplication.
    // In a real shader, this could be a shadow calculation. We&#39;re just making
    // the base color 50% darker via component-wise multiplication.
    let darker_orange = base_color * 0.5;

    // Step 3: Blend with another color using vector arithmetic.
    // We create a final color that is 70% our `darker_orange` and 30% a
    // cool blue accent color. This is a manual linear interpolation.
    let accent_color = vec3&lt;f32&gt;(0.2, 0.3, 0.8);
    let blended_color = darker_orange * 0.7 + accent_color * 0.3;

    // Step 4: Construct the final `vec4` output.
    // The fragment shader must return an RGBA color. We construct this
    // by combining our final `vec3` result with a scalar `f32` for the alpha.
    let final_output = vec4&lt;f32&gt;(blended_color, 1.0);

    return final_output;
}
</code></pre><h3 id="deconstructing-the-process">Deconstructing the Process</h3><p>This short example is a microcosm of everyday shader programming, demonstrating several key concepts in a practical flow:</p><ol><li><strong>Immutability by Default</strong>: We use <code>let</code> to define each stage of the color. This makes the code easy to follow - <code>base_color</code> is always the original orange, <code>darker_orange</code> is always the half-bright version, and so on. There are no surprise mutations, which makes the logic simple to debug.</li><li><strong>Vector as a Unit</strong>: We treat <code>base_color</code> and <code>accent_color</code> as single entities, even though they contain three separate <code>f32</code> values. All our math (<code>*</code> and <code>+</code>) operates on them as a whole, which is clean and intuitive.</li><li><strong>Component-Wise Math in Action</strong>: The multiplication <code>darker_orange * 0.7</code> isn’t a dot product; it’s a scaling of each color channel (R, G, and B) independently. This component-wise behavior is exactly what we need for tinting and blending colors.</li><li><strong>Vector Construction Flexibility</strong>: We see two kinds of construction: <code>vec3&lt;f32&gt;(r, g, b)</code> to define the initial colors from scalars, and the powerful <code>vec4&lt;f32&gt;(vec3, a)</code> to compose the final output by combining an existing <code>vec3</code> with a new scalar alpha channel.</li></ol><p>By following this pattern - starting with base values, applying a series of transformations and blends to create new <code>let</code> constants, and finally constructing the required output - you can build complex visual effects in a clean, readable, and performant way.</p><hr><h2 id="complete-example-vector-operations-visualizer">Complete Example: Vector Operations Visualizer</h2><p>Theory is essential, but seeing is believing. To make these abstract concepts concrete, we’ll build a simple, interactive shader in Bevy. This shader won’t create a realistic object; instead, it will act as a diagnostic tool, allowing us to “see” vector operations in real-time.</p><h3 id="our-goal">Our Goal</h3><p>We will create a custom material for a sphere that can cycle through five different visualization modes by pressing a key. Each mode will apply a different vector operation to the sphere’s base color, visually demonstrating concepts like component access, swizzling, and arithmetic.</p><h3 id="what-this-project-demonstrates">What This Project Demonstrates</h3><ul><li><strong>Component Access</strong>: How to isolate and use a single component of a vector (e.g., <code>.r</code>).</li><li><strong>Swizzling</strong>: The power of rearranging vector components on the fly (e.g., <code>.bgr</code>).</li><li><strong>Vector Arithmetic</strong>: The visual result of component-wise addition and multiplication.</li><li><strong>Vector Construction</strong>: How to build new vectors by combining smaller vectors and scalars.</li><li><strong>Bevy Integration</strong>: The basic structure of a custom <code>Material</code> in Bevy 0.16 and how to pass data (our <code>demo_mode</code>) from Rust to a WGSL shader.</li></ul><h3 id="the-shader-assetsshadersvector_demowgsl">The Shader (<code>assets/shaders/vector_demo.wgsl</code>)</h3><p>This single WGSL file contains both our vertex and fragment shaders. The vertex shader is standard; it calculates the world position and normal for each vertex and passes them to the next stage.</p><p>The fragment shader is where the magic happens. It first calculates a <code>base</code> color from the interpolated world normal. Then, using an <code>if</code> chain, it checks the <code>material.demo_mode</code> uniform (sent from our Rust code) to decide which vector operation to perform, altering the final color of the pixel accordingly.</p><pre><code class="language-wgsl">#import bevy_pbr::mesh_functions
#import bevy_pbr::view_transformations::position_world_to_clip
#import bevy_pbr::forward_io::VertexOutput

struct VectorDemoMaterial {
    demo_mode: u32,
}

@group(2) @binding(0)
var&lt;uniform&gt; material: VectorDemoMaterial;

@vertex
fn vertex(
    @builtin(instance_index) instance_index: u32,
    @location(0) position: vec3&lt;f32&gt;,
    @location(1) normal: vec3&lt;f32&gt;,
) -&gt; VertexOutput {
    var out: VertexOutput;

    let world_from_local = mesh_functions::get_world_from_local(instance_index);
    let world_position = mesh_functions::mesh_position_local_to_world(
        world_from_local,
        vec4&lt;f32&gt;(position, 1.0)
    );

    out.position = position_world_to_clip(world_position.xyz);
    out.world_normal = mesh_functions::mesh_normal_local_to_world(normal, instance_index);
    out.world_position = world_position;

    return out;
}

@fragment
fn fragment(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    // Create a base color from the normal
    let base = (in.world_normal + 1.0) * 0.5;

    // Mode 0: RGB channels separately
    if material.demo_mode == 0u {
        // Show only red channel
        return vec4&lt;f32&gt;(base.r, 0.0, 0.0, 1.0);
    }

    // Mode 1: Swizzling demonstration
    if material.demo_mode == 1u {
        // Reverse the RGB channels (BGR)
        let swizzled = base.bgr;
        return vec4&lt;f32&gt;(swizzled, 1.0);
    }

    // Mode 2: Vector arithmetic
    if material.demo_mode == 2u {
        // Add a constant color
        let added = base + vec3&lt;f32&gt;(0.0, 0.3, 0.0);  // Add green
        return vec4&lt;f32&gt;(added, 1.0);
    }

    // Mode 3: Vector multiplication
    if material.demo_mode == 3u {
        // Multiply by a color (component-wise)
        let tinted = base * vec3&lt;f32&gt;(1.0, 0.5, 0.5);  // Reduce green and blue
        return vec4&lt;f32&gt;(tinted, 1.0);
    }

    // Mode 4: Component extraction and reconstruction
    if material.demo_mode == 4u {
        // Extract xy, ignore z, add new z
        let xy = base.xy;
        let reconstructed = vec3&lt;f32&gt;(xy, 0.5);  // Force z to 0.5
        return vec4&lt;f32&gt;(reconstructed, 1.0);
    }

    // Default: Original
    return vec4&lt;f32&gt;(base, 1.0);
}
</code></pre><h3 id="the-rust-material-srcmaterialsvector_demors">The Rust Material (<code>src/materials/vector_demo.rs</code>)</h3><p>This is the Rust-side definition of our material. It’s a simple struct that mirrors the <code>VectorDemoMaterial</code> struct in our shader, allowing Bevy’s rendering engine to send our chosen <code>demo_mode</code> value to the GPU.</p><pre><code class="language-rust">use bevy::prelude::*;
use bevy::render::render_resource::{AsBindGroup, ShaderRef};

#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
pub struct VectorDemoMaterial {
    #[uniform(0)]
    pub demo_mode: u32,
}

impl Material for VectorDemoMaterial {
    fn fragment_shader() -&gt; ShaderRef {
        &quot;shaders/vector_demo.wgsl&quot;.into()
    }

    fn vertex_shader() -&gt; ShaderRef {
        &quot;shaders/vector_demo.wgsl&quot;.into()
    }
}
</code></pre><p>Don’t forget to add it to <code>src/materials/mod.rs</code>:</p><pre><code class="language-rust">// ... other materials
pub mod vector_demo;
</code></pre><h3 id="the-demo-module-srcdemosvector_demors">The Demo Module (<code>src/demos/vector_demo.rs</code>)</h3><p>This Rust module sets up our Bevy scene. It spawns a sphere with our custom material, adds a camera and light, and sets up the UI text. Most importantly, it contains the <code>cycle_demo_mode</code> system, which listens for the spacebar press and updates the <code>demo_mode</code> field on our material, triggering the change in the shader.</p><pre><code class="language-rust">use crate::materials::vector_demo::VectorDemoMaterial;
use bevy::prelude::*;

pub fn run() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(MaterialPlugin::&lt;VectorDemoMaterial&gt;::default())
        .add_systems(Startup, setup)
        .add_systems(Update, (rotate_camera, cycle_demo_mode))
        .run();
}

fn setup(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;VectorDemoMaterial&gt;&gt;,
) {
    // Spawn a sphere
    commands.spawn((
        Mesh3d(meshes.add(Sphere::new(1.0).mesh().uv(32, 18))),
        MeshMaterial3d(materials.add(VectorDemoMaterial { demo_mode: 0 })),
    ));

    // Light
    commands.spawn((
        PointLight {
            shadows_enabled: true,
            ..default()
        },
        Transform::from_xyz(4.0, 8.0, 4.0),
    ));

    // Camera
    commands.spawn((
        Camera3d::default(),
        Transform::from_xyz(-2.5, 4.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y),
    ));

    // UI
    commands.spawn((
        Text::new(&quot;Press SPACE to cycle modes\nMode 0: Red channel only&quot;),
        Node {
            position_type: PositionType::Absolute,
            top: Val::Px(10.0),
            left: Val::Px(10.0),
            ..default()
        },
    ));
}

fn rotate_camera(time: Res&lt;Time&gt;, mut camera_query: Query&lt;&amp;mut Transform, With&lt;Camera3d&gt;&gt;) {
    for mut transform in camera_query.iter_mut() {
        let radius = 9.0;
        let angle = time.elapsed_secs() * 0.5;
        transform.translation.x = angle.cos() * radius;
        transform.translation.z = angle.sin() * radius;
        transform.look_at(Vec3::ZERO, Vec3::Y);
    }
}

fn cycle_demo_mode(
    keyboard: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;VectorDemoMaterial&gt;&gt;,
    mut text_query: Query&lt;&amp;mut Text&gt;,
) {
    if keyboard.just_pressed(KeyCode::Space) {
        for (_, material) in materials.iter_mut() {
            material.demo_mode = (material.demo_mode + 1) % 5;

            for mut text in text_query.iter_mut() {
                **text = match material.demo_mode {
                    0 =&gt; &quot;Press SPACE to cycle modes\nMode 0: Red channel only&quot;.to_string(),
                    1 =&gt; &quot;Press SPACE to cycle modes\nMode 1: BGR swizzle (reversed)&quot;.to_string(),
                    2 =&gt; &quot;Press SPACE to cycle modes\nMode 2: Add green (vector addition)&quot;
                        .to_string(),
                    3 =&gt; &quot;Press SPACE to cycle modes\nMode 3: Color tint (vector multiplication)&quot;
                        .to_string(),
                    4 =&gt; &quot;Press SPACE to cycle modes\nMode 4: XY extraction with new Z&quot;.to_string(),
                    _ =&gt; &quot;Unknown mode&quot;.to_string(),
                };
            }
        }
    }
}
</code></pre><p>Don’t forget to add it to <code>src/demos/mod.rs</code>:</p><pre><code class="language-rust">// ... other demoss
pub mod vector_demo;
</code></pre><p>And register it in <code>src/main.rs</code>:</p><pre><code class="language-rust">Demo {
    number: &quot;1.2&quot;,
    title: &quot;WGSL Fundamentals - Data Types &amp; Variables&quot;,
    run: demos::vector_demo::run,
},
</code></pre><h3 id="running-the-demo">Running the Demo</h3><p>When you run the project, you will see a multi-colored sphere. Pressing the spacebar will cycle through the five different debug visualizations, each revealing how a different vector operation affects the final color.</p><h4 id="controls">Controls</h4><table><thead><tr><th>Control</th><th>Action</th></tr></thead><tbody><tr><td><strong>SPACE</strong></td><td>Cycle to the next visualization mode (0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 0).</td></tr></tbody></table><h4 id="what-youre-seeing">What You’re Seeing</h4><p>![screenshot 1](/media/files/2.2 - screenshot 1.png) ![screenshot 2](/media/files/2.2 - screenshot 2.png) ![screenshot 3](/media/files/2.2 - screenshot 3.png) ![screenshot 4](/media/files/2.2 - screenshot 4.png) ![screenshot 5](/media/files/2.2 - screenshot 5.png)</p><p>Each mode corresponds to a different branch in our fragment shader’s logic.</p><table><thead><tr><th>Mode</th><th>Description</th><th>What It Proves</th></tr></thead><tbody><tr><td><strong>0 - Red Channel Only</strong></td><td>The sphere is colored only with the red component of the base color.</td><td>Demonstrates <strong>component access</strong> (<code>base.r</code>). We’ve isolated a single <code>f32</code> from a <code>vec3</code>.</td></tr><tr><td><strong>1 - BGR Swizzle</strong></td><td>The colors are reversed. Areas that were red are now blue, and vice-versa.</td><td>Demonstrates <strong>swizzling</strong> (<code>base.bgr</code>). We created a new <code>vec3</code> by reordering the components of the original.</td></tr><tr><td><strong>2 - Vector Addition</strong></td><td>The entire sphere appears brighter and greener.</td><td>Demonstrates <strong>component-wise addition</strong>. We added <code>(0.0, 0.3, 0.0)</code> to every single pixel’s color, increasing its green channel.</td></tr><tr><td><strong>3 - Color Tint</strong></td><td>The sphere appears more reddish-orange, with the greens and blues muted.</td><td>Demonstrates <strong>component-wise multiplication</strong>. We scaled the G and B channels by <code>0.5</code>, effectively tinting the entire result.</td></tr><tr><td><strong>4 - XY Reconstruction</strong></td><td>The color is now only composed of red and green, with a constant blue value of 0.5 across the whole sphere.</td><td>Demonstrates <strong>construction and extraction</strong>. We extracted a <code>vec2 (base.xy)</code> and used it to construct a new <code>vec3</code>.</td></tr></tbody></table><h2 id="key-takeaways">Key Takeaways</h2><p>This article introduced you to the alphabet of the WGSL language. Before moving on, ensure you have a solid grasp of these core concepts, as they are the foundation upon which all shader logic is built.</p><ol><li><strong>Scalars are the Atomic Units, with <code>f32</code> Being King</strong>. WGSL provides the basic building blocks of <code>f32</code> (floats), <code>i32</code>/<code>u32</code> (integers), and bool (booleans). Remember that nearly all graphics math is done with <code>f32</code>, and you must be explicit with literals (use <code>1.0</code> for a float, <code>1u</code> for an unsigned integer).</li><li><strong>Vectors are the Workhorse for All Graphics Data.</strong><br>Positions, colors, directions, texture coordinates - everything is represented by vectors (<code>vec2</code>, <code>vec3</code>, <code>vec4</code>). Learning to think in terms of vectors is the most important step in becoming a shader programmer. They are not just data containers; they are the native language of the GPU.</li><li><strong>Vector Operations are Fast, Powerful, and Component-Wise.</strong><br>The GPU is optimized to perform math on vectors. Operations like addition, subtraction, and multiplication are applied to each component independently. This is perfect for tasks like blending colors or offsetting positions. <strong>Swizzling</strong> (<code>.rgba</code>, <code>.xy</code>, <code>.bgr</code>) is a zero-cost hardware feature that lets you efficiently rearrange and create new vectors from existing ones.</li><li><strong>Matrices are the Machines of Transformation.</strong><br>While we’ll cover the deep math later, understand now that matrices (especially <code>mat4x4&lt;f32&gt;</code>) are the tools used to move, rotate, scale, and project your vectors from one coordinate space to another. The core of a vertex shader is applying matrix transformations to vertex positions.</li><li><strong>Prefer Immutable let for Safety and Performance.</strong><br>Use let to declare constants by default. This makes your code safer, easier to reason about, and provides crucial information to the shader compiler, enabling powerful optimizations. Only use var for mutable variables when you have a specific need to change a value after its initial declaration, such as an accumulator in a loop.</li></ol><h2 id="whats-next">What’s Next?</h2><p>You have now learned the “nouns” of the WGSL language - the fundamental data types and variables used to represent all the data in your shader, from a single boolean flag to a complex transformation matrix. You know how to create, store, and perform basic math on this data.</p><p>But data on its own is static. To bring our shaders to life, we need to create logic. In the next article, we will learn the “verbs” and “grammar” of WGSL. We will explore how to organize your code into reusable <strong>functions</strong> and how to make decisions and repeat operations using <strong>control flow</strong> structures like <code>if/else</code> and <code>for</code> loops.</p><p><em>Next up:</em> <a href="https://hexbee.hashnode.dev/13-wgsl-fundamentals-functions-and-control-flow"><strong><em>1.3 - WGSL Fundamentals - Functions &amp; Control Flow</em></strong></a></p><hr><h2 id="quick-reference">Quick Reference</h2><p>A cheat sheet for the fundamental building blocks of the WGSL language.</p><h3 id="scalar-types">Scalar Types</h3><table><thead><tr><th>Type</th><th>Description</th><th>Example Literal</th></tr></thead><tbody><tr><td><code>f32</code></td><td>32-bit floating-point number. The default for most math.</td><td><code>1.0</code>, <code>-0.5</code>, <code>3.14</code></td></tr><tr><td><code>i32</code></td><td>32-bit signed integer. The default for integers.</td><td><code>42</code>, <code>-10</code>, <code>0</code></td></tr><tr><td><code>u32</code></td><td>32-bit unsigned integer (non-negative).</td><td><code>0u</code>, <code>255u</code>, <code>100u</code></td></tr><tr><td><code>bool</code></td><td>A boolean value.</td><td><code>true</code>, <code>false</code></td></tr></tbody></table><h3 id="variable-declaration">Variable Declaration</h3><ul><li><code>let name = value;</code>: Declares an <strong>immutable constant</strong>. Its value cannot be changed. <strong>Use this by default.</strong></li><li><code>var name = value;</code>: Declares a <strong>mutable variable</strong>. Its value can be reassigned. Use only when necessary (e.g., accumulators, loop counters).</li></ul><h3 id="vector-types">Vector Types</h3><p>The workhorse of shader programming. <code>T</code> can be <code>f32</code>, <code>i32</code>, <code>u32</code>, or bool.</p><p><strong>Syntax:</strong> <code>vecN&lt;T&gt;</code> (e.g., <code>vec3&lt;f32&gt;</code>)</p><h4 id="construction">Construction</h4><pre><code class="language-wgsl">// From components
let v3 = vec3&lt;f32&gt;(1.0, 2.0, 3.0);

// From a single value (&quot;splat&quot;)
let v3 = vec3&lt;f32&gt;(0.5); // -&gt; vec3(0.5, 0.5, 0.5)

// Combining smaller types
let xy = vec2&lt;f32&gt;(1.0, 2.0);
let v3 = vec3&lt;f32&gt;(xy, 3.0); // -&gt; vec3(1.0, 2.0, 3.0)
let v4 = vec4&lt;f32&gt;(v3, 1.0); // -&gt; vec4(1.0, 2.0, 3.0, 1.0)
</code></pre><h4 id="access--swizzling">Access &amp; Swizzling</h4><pre><code class="language-wgsl">let v = vec4&lt;f32&gt;(1.0, 2.0, 3.0, 4.0);

// Access (all are equivalent for the first component)
let c0_a = v.x; // -&gt; 1.0
let c0_b = v.r; // -&gt; 1.0
let c0_c = v[0]; // -&gt; 1.0

// Swizzling (creating new vectors)
let v2 = v.xy;      // -&gt; vec2(1.0, 2.0)
let v3 = v.bgr;     // -&gt; vec3(3.0, 2.0, 1.0) (reordered)
let v3 = v.rrr;     // -&gt; vec3(1.0, 1.0, 1.0) (duplicated)
let v2 = v.wz;      // -&gt; vec2(4.0, 3.0)
</code></pre><h4 id="arithmetic-component-wise">Arithmetic (Component-Wise)</h4><pre><code class="language-wgsl">let a = vec2&lt;f32&gt;(1.0, 2.0);
let b = vec2&lt;f32&gt;(3.0, 4.0);

let sum = a + b;    // -&gt; vec2(4.0, 6.0)
let prod = a * b;   // -&gt; vec2(3.0, 8.0)
let scaled = a * 2.0; // -&gt; vec2(2.0, 4.0)
</code></pre><h3 id="matrix-types">Matrix Types</h3><p>Used for transformations. <code>C</code>=Columns, <code>R</code>=Rows.</p><p><strong>Syntax:</strong> <code>matCxR&lt;T&gt;</code> (e.g., <code>mat4x4&lt;f32&gt;</code>)</p><ul><li><strong>Column-Major</strong>: Data is organized by columns.</li><li><strong>Access</strong>: <code>matrix[column_index][row_index]</code></li><li><strong>Multiplication</strong>: <code>transformed_vector = matrix * vector</code> (This is a mathematical transformation, not component-wise).</li></ul></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on December 13, 2025</p><div class="post__share"></div></footer><nav class="pagination"><div class="pagination__title"><span>Read other posts</span></div><div class="pagination__buttons"><a href="https://xav.github.io/11-understanding-the-graphics-pipeline/" class="btn previous" rel="prev" aria-label="[MISSING TRANSLATION]:  1.1 - Understanding the Graphics Pipeline "><span class="btn__icon">←</span> <span class="btn__text">1.1 - Understanding the Graphics Pipeline</span></a></div></nav></article></main><footer class="footer"><div class="footer__inner"><div class="footer__copyright"><p>© 2024 Powered by Publii CMS :: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank" rel="noopener">Theme</a> ported by the <a href="https://getpublii.com/customization-service/" target="_blank" rel="noopener">Publii Team</a></p></div></div></footer></div><script defer="defer" src="https://xav.github.io/assets/js/scripts.min.js?v=c2232aa7558e9517946129d2a1b8c770"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script defer="defer" src="https://xav.github.io/media/plugins/syntaxHighlighter/prism.js"></script></body></html>