<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>A Practical Guide to WGSL Shaders in Bevy</title><meta name="description" content="Learn to write WGSL shaders in Bevy 0.16 with this practical, step-by-step tutorial. Perfect for Rust developers new to modern shader programming."><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="stylesheet" href="https://xav.github.io/media/plugins/syntaxHighlighter/prism-black.css"><link rel="canonical" href="https://xav.github.io/learning-wgsl-shaders-with-bevy-016-a-practical-journey/"><link rel="alternate" type="application/atom+xml" href="https://xav.github.io/feed.xml" title="Hexbee&#x27;s Dev Journal - RSS"><link rel="alternate" type="application/json" href="https://xav.github.io/feed.json" title="Hexbee&#x27;s Dev Journal - JSON"><meta property="og:title" content="Learning WGSL Shaders with Bevy 0.16: A Practical Journey"><meta property="og:image" content="https://xav.github.io/media/posts/2/cover.png"><meta property="og:image:width" content="1344"><meta property="og:image:height" content="768"><meta property="og:site_name" content="Hexbee's Dev Journal"><meta property="og:description" content="Learn to write WGSL shaders in Bevy 0.16 with this practical, step-by-step tutorial. Perfect for Rust developers new to modern shader programming."><meta property="og:url" content="https://xav.github.io/learning-wgsl-shaders-with-bevy-016-a-practical-journey/"><meta property="og:type" content="article"><link rel="stylesheet" href="https://xav.github.io/assets/css/style.css?v=e19cced6341d15e84c3d202e5e386440"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://xav.github.io/learning-wgsl-shaders-with-bevy-016-a-practical-journey/"},"headline":"Learning WGSL Shaders with Bevy 0.16: A Practical Journey","datePublished":"2025-08-29T22:38+02:00","dateModified":"2025-12-09T22:39+01:00","image":{"@type":"ImageObject","url":"https://xav.github.io/media/posts/2/cover.png","height":768,"width":1344},"description":"Learn to write WGSL shaders in Bevy 0.16 with this practical, step-by-step tutorial. Perfect for Rust developers new to modern shader programming.","author":{"@type":"Person","name":"Xavier Basty Kjellberg","url":"https://xav.github.io/authors/xavier-basty-kjellberg/"},"publisher":{"@type":"Organization","name":"Xavier Basty Kjellberg","logo":{"@type":"ImageObject","url":"https://xav.github.io/media/website/Logo-SideName.png","height":2297,"width":5553}}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><div class="container"><header class="header"><div class="header__logo"><a class="logo" href="https://xav.github.io/"><img src="https://xav.github.io/media/website/Logo-SideName.png" alt="Hexbee&#x27;s Dev Journal" width="5553" height="2297"></a></div></header><main class="content"><article class="post"><header><h1 class="post__title">Learning WGSL Shaders with Bevy 0.16: A Practical Journey</h1><div class="post__meta"><time datetime="2025-08-29T22:38" class="post__date">August 29, 2025 </time><span class="post__author"><a href="https://xav.github.io/authors/xavier-basty-kjellberg/" class="feed__author">Xavier Basty Kjellberg</a></span></div><div class="post__tags"><a href="https://xav.github.io/tags/webgpu/" class="invert">bevy</a> <a href="https://xav.github.io/tags/rust/" class="invert">rust</a> <a href="https://xav.github.io/tags/shaders/" class="invert">shaders</a> <a href="https://xav.github.io/tags/wgsl/" class="invert">wgsl</a></div></header><figure class="post__image post__cover"><img src="https://xav.github.io/media/posts/2/cover.png" srcset="https://xav.github.io/media/posts/2/responsive/cover-xs.webp 300w, https://xav.github.io/media/posts/2/responsive/cover-sm.webp 480w, https://xav.github.io/media/posts/2/responsive/cover-md.webp 768w, https://xav.github.io/media/posts/2/responsive/cover-lg.webp 1024w" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" loading="eager" height="768" width="1344" alt=""></figure><div class="post__entry"><h2 id="does-this-sound-familiar">Does This Sound Familiar?</h2><p>Youâ€™re a Bevy developer. You love Rustâ€™s power and safety, and youâ€™ve started to feel comfortable building scenes and game logic. But now you want to create something truly unique - a shimmering shield, a stylized water surface, a custom lighting model - and you realize you need to write a shader.</p><p>So you open aÂ <code>.wgsl</code>Â fileâ€¦ and you hit a wall.</p><p>You look for tutorials, but theyâ€™re almost all for GLSL or Unity, using a different language and a different engine. You look at the official Bevy examples, but they seem to assume you already know how shaders work. Youâ€™re stuck in a frustrating gap: you know the engine, you know the language, but you donâ€™t know how to bridge the two to speak directly to the GPU.</p><p><strong>I created this series because I was that developer.</strong></p><p>This is not a theoretical textbook or a high-level overview. It is the practical, step-by-step guide I wish I had when I was starting. Itâ€™s the result of systematically navigating that gap, figuring out the fundamentals, hitting the common pitfalls, and documenting what finally made the concepts â€œclick.â€</p><p>My goal is to provide a clear, linear path that takes you from the absolute basics of the graphics pipeline all the way to advanced techniques, with every single concept explained and demonstrated inside a working Bevy project. This is the journey of learning how to think in shaders, and Iâ€™m thrilled to share it with you.</p><h2 id="our-approach-a-practical-incremental-journey">Our Approach: A Practical, Incremental Journey</h2><p>This is aÂ <strong>practical, hands-on series</strong>. We will learn by building, not just by reading. Every single article is built around a working Bevy project that you can run, modify, and experiment with. Our philosophy is that you donâ€™t truly understand a concept until youâ€™ve seen it work, broken it, and fixed it again.</p><p>Our journey is structured to build your knowledge from the ground up, ensuring you have a solid foundation before moving on to more complex topics. Hereâ€™s the path weâ€™ll take:</p><ol><li><p><strong>First, weâ€™ll build the foundation.</strong>Â We will demystify theÂ <strong>Graphics Pipeline</strong>Â and learn the fundamental â€œalphabetâ€ of WGSL - its data types, variables, and functions. Youâ€™ll understandÂ whereÂ your code runs and the language it speaks.</p></li><li><p><strong>Then, weâ€™ll take control of geometry.</strong>Â Weâ€™ll dive deep into theÂ <strong>Vertex Shader</strong>, where you will learn to manipulate the very shape of your 3D models. Youâ€™ll create waving flags, rippling water, and fields of animated grass, learning how to breathe life into static meshes.</p></li><li><p><strong>Next, weâ€™ll learn to paint those shapes with light and color.</strong>Â Weâ€™ll master theÂ <strong>Fragment Shader</strong>, moving beyond simple colors to create procedural patterns, sample textures, and implement our own lighting models. This is where youâ€™ll define the unique visual identity of your projects.</p></li><li><p><strong>Finally, weâ€™ll explore the advanced frontier.</strong>Â With the fundamentals in place, weâ€™ll unlock the true power of the GPU, exploring post-processing effects, compute shaders, performance optimization, and how to achieve specific artistic styles.</p></li></ol><p>By the end of this series, you wonâ€™t just know how to copy and paste shader code - you will have the confidence and the deep understanding to create your own custom rendering effects from scratch.</p><h2 id="who-this-series-is-for-and-what-youll-need">Who This Series Is For (And What Youâ€™ll Need)</h2><p>This series is designed for the curious Bevy developer who is ready to take the next step in their creative journey. If youâ€™re comfortable with the basics of Rust and Bevy but feel like the GPU is still a â€œblack box,â€ youâ€™re in the perfect place.</p><h3 id="the-prerequisites">The Prerequisites</h3><p>This is not a â€œfrom zeroâ€ programming course. Weâ€™ll be moving at a steady pace, and Iâ€™ll assume you have a solid footing in the following areas:</p><ul><li><p><strong>A Good Grasp of Rust:</strong>Â You donâ€™t need to be a systems-level expert, but you should be comfortable with core concepts like structs, traits, ownership, and the module system.</p></li><li><p><strong>Bevy Fundamentals:</strong>Â You should have worked through the official Bevy book or built a small project. You know what Components, Systems, and Resources are, and you feel comfortable setting up a basic scene.</p></li><li><p><strong>Basic Vector Math Intuition:</strong>Â You donâ€™t need a math degree, but you should know what a vector is (<code>Vec3</code>) and have a general idea of what operations like adding, subtracting, or normalizing them mean. Weâ€™ll review the more complex math (like dot products and matrices) as we need it, focusing on intuition over raw proofs.</p></li></ul><h3 id="what-you-dont-need">What YouÂ Donâ€™tÂ Need</h3><p>This is just as important. YouÂ <strong>do not</strong>Â need:</p><ul><li>Any prior shader programming experience (thatâ€™s what weâ€™re here to learn!).</li><li>A deep background in low-level graphics APIs like OpenGL, Vulkan, or DirectX.</li><li>To be a math wizard. A willingness to engage with the concepts is far more important than a formal education in linear algebra.</li></ul><p>Our goal is to build up your knowledge from first principles, right here in the Bevy ecosystem.</p><h2 id="setting-up-your-development-playground">Setting Up Your Development Playground</h2><p>A fast, smooth iteration loop is the secret to enjoying shader development. You want to be able to make a small change to your shader code and see the result instantly, without fighting with long compile times. Letâ€™s create a Bevy project specifically configured for this rapid, creative workflow.</p><h3 id="recommended-tools">Recommended Tools</h3><p>While you can use any text editor, this series is written with a specific, highly effective setup in mind:</p><ul><li><ul><li><strong>Editor</strong>:Â <strong>Visual Studio Code (VS Code)</strong>Â is strongly recommended. ItsÂ rust-analyzerÂ extension provides top-tier support for Rust, and there are excellent extensions that add syntax highlighting for WGSL, making your shader code much easier to read.</li></ul></li><li><p><strong>Graphics Debugger (Optional but Powerful)</strong>: For advanced debugging, a dedicated tool that can capture and inspect a single frame is invaluable. We wonâ€™t need this for the early articles, but knowing it exists is important.</p><ul><li><strong>Windows / Linux</strong>:Â <strong>RenderDoc</strong>Â is the open-source industry standard.</li><li><strong>macOS</strong>: Appleâ€™sÂ <strong>Metal GPU Debugger and Frame Capture</strong>, which is built directly intoÂ <strong>Xcode</strong>, is the essential tool for debugging Metal applications.</li></ul></li></ul><h3 id="step-1-install-the-essentials">Step 1: Install the Essentials</h3><p>First, ensure you have the Rust toolchain installed. If youâ€™re already a Rust developer, you can likely skip this.</p><pre><code class="language-bash"># Install Rust if you don&#39;t have it
curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre><h3 id="step-2-create-the-project-and-configure-cargotoml">Step 2: Create the Project and ConfigureÂ <code>Cargo.toml</code></h3><p>Letâ€™s create a new Bevy project that will be our home for this entire series.</p><pre><code class="language-bash">mkdir bevy-shader-journey
cd bevy-shader-journey
cargo init
</code></pre><p>Now, replace the contents of yourÂ <code>Cargo.toml</code>Â file with the following configuration. Weâ€™re adding a few key dependencies and settings to optimize our development experience.</p><pre><code class="language-toml">[package]
name = &quot;bevy-shader-journey&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot; # Sticking with the 2021 edition for maximum compatibility

[dependencies]
# The core Bevy engine, version 0.16
bevy = { version = &quot;0.16&quot;, features = [&quot;file_watcher&quot;] }
# For faster compile times in debug builds, you can enable this feature.
# It doesn&#39;t work on Windows though :(
# bevy = { version = &quot;0.16&quot;, features = [&quot;dynamic_linking&quot;, &quot;file_watcher&quot;] }

# Interactive demo selection - makes it easy to jump between examples
inquire = &quot;0.7&quot;

# An incredibly useful debugging tool we&#39;ll use in later articles
# to tweak shader values in real-time.
bevy-inspector-egui = &quot;0.23&quot;

# This section makes our local code compile faster (opt-level = 1)
# while keeping our dependencies fully optimized (opt-level = 3).
# It&#39;s a great trick for improving Bevy&#39;s debug build times.
[profile.dev]
opt-level = 1

[profile.dev.package.&quot;*&quot;]
opt-level = 3
</code></pre><h3 id="step-3-create-the-project-directory-structure">Step 3: Create the Project Directory Structure</h3><p>A good project organization will make life much easier as we add more examples. Create the necessary directories and files with this command:</p><pre><code class="language-bash">mkdir -p assets/shaders src/demos src/materials

# Create the module files
touch src/demos/mod.rs
touch src/materials/mod.rs
</code></pre><p>This gives us:</p><ul><li><code>assets/shaders/</code>: Where all our <code>.wgsl</code> shader files will live.</li><li><code>src/demos/</code>: Where each articleâ€™s interactive example will go.</li><li><code>src/materials/</code>: Where the Rust â€œglueâ€ code for our custom materials will go.</li></ul><h3 id="step-4-set-up-the-demo-selection-system">Step 4: Set Up the Demo Selection System</h3><p>Hereâ€™s where things get interesting. Instead of creating separate example files or constantly commenting and uncommenting code, weâ€™re going to build a smart demo selection system. This will let you easily run any example from the series with a simple command.</p><p>Replace the contents of <code>src/main.rs</code> with this code:</p><pre><code class="language-rust">mod demos;
mod materials;

use std::env;

struct Demo {
    number: &amp;&#39;static str,
    title: &amp;&#39;static str,
    run: fn(),
}

impl Demo {
    fn matches(&amp;self, query: &amp;str) -&gt; bool {
        let query_lower = query.to_lowercase();
        self.number.contains(&amp;query_lower) || self.title.to_lowercase().contains(&amp;query_lower)
    }

    fn display(&amp;self) -&gt; String {
        format!(&quot;{} - {}&quot;, self.number, self.title)
    }
}

fn main() {
    // Registry of all available demos
    let demos = vec![
        Demo {
            number: &quot;0.0&quot;,
            title: &quot;Basic Scene Setup&quot;,
            run: demos::basic_scene::run,
        },
        // More demos will be added as we progress through the series
    ];

    let args: Vec&lt;String&gt; = env::args().skip(1).collect();

    let demo = if args.is_empty() {
        select_demo_interactive(&amp;demos)
    } else {
        let query = args.join(&quot; &quot;);
        find_and_select_demo(&amp;demos, &amp;query)
    };

    match demo {
        Some(d) =&gt; {
            println!(&quot;\nğŸš€ Running: {}\n&quot;, d.display());
            (d.run)();
        }
        None =&gt; {
            println!(&quot;No demo selected. Exiting.&quot;);
            std::process::exit(0);
        }
    }
}

fn find_and_select_demo&lt;&#39;a&gt;(demos: &amp;&#39;a [Demo], query: &amp;str) -&gt; Option&lt;&amp;&#39;a Demo&gt; {
    let matches: Vec&lt;&amp;Demo&gt; = demos.iter().filter(|d| d.matches(query)).collect();

    match matches.len() {
        0 =&gt; {
            eprintln!(&quot;âŒ No demos match &#39;{}&#39;\n&quot;, query);
            show_available_demos(demos);
            println!();
            select_demo_interactive(demos)
        }
        1 =&gt; Some(matches[0]),
        _ =&gt; {
            eprintln!(&quot;âš ï¸  Multiple demos match &#39;{}&#39;:\n&quot;, query);
            select_from_list(&amp;matches)
        }
    }
}

fn select_demo_interactive&lt;&#39;a&gt;(demos: &amp;&#39;a [Demo]) -&gt; Option&lt;&amp;&#39;a Demo&gt; {
    println!(&quot;Available demos:&quot;);
    show_available_demos(demos);
    println!();

    let demo_refs: Vec&lt;&amp;Demo&gt; = demos.iter().collect();
    select_from_list(&amp;demo_refs)
}

fn show_available_demos(demos: &amp;[Demo]) {
    for demo in demos {
        println!(&quot;  â€¢ {}&quot;, demo.display());
    }
}

fn select_from_list&lt;&#39;a&gt;(demos: &amp;[&amp;&#39;a Demo]) -&gt; Option&lt;&amp;&#39;a Demo&gt; {
    use inquire::Select;

    let options: Vec&lt;String&gt; = demos.iter().map(|d| d.display()).collect();
    let selected = Select::new(&quot;Select a demo to run:&quot;, options).prompt();

    match selected {
        Ok(selected_text) =&gt; demos.iter().find(|d| d.display() == selected_text).copied(),
        Err(_) =&gt; {
            println!(&quot;Selection cancelled.&quot;);
            None
        }
    }
}
</code></pre><p><strong>What does this do?</strong> This system lets you run any demo from the series with intuitive commands:</p><pre><code class="language-rust"># Run by article number
cargo run 1.1

# Run by partial title match
cargo run pipeline

# Multiple matches? You&#39;ll get an interactive menu with arrow keys
cargo run shader

# No arguments? See all available demos and select with arrow keys
cargo run
</code></pre><p>As you progress through the series, youâ€™ll simply add new demos to the <code>demos</code> vector in <code>main.rs</code>, and theyâ€™ll automatically be available through this selection system. No managing multiple example files or hunting through code!</p><h3 id="step-5-create-your-first-demo-module">Step 5: Create Your First Demo Module</h3><p>Now letâ€™s create the first demo that we registered in our system. Create <code>src/demos/basic_scene.rs</code>:</p><pre><code class="language-rust">use bevy::prelude::*;

pub fn run() {
    App::new()
        .add_plugins(DefaultPlugins.set(AssetPlugin {
            // Enable hot reloading
            watch_for_changes_override: Some(true),
            ..default()
        }))
        .add_systems(Startup, setup)
        .add_systems(Update, rotate_camera)
        .run();
}

fn setup(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;StandardMaterial&gt;&gt;,
) {
    // Add a simple scene we can apply our shaders to
    commands.spawn((
        Mesh3d(meshes.add(Cuboid::new(2.0, 2.0, 2.0))),
        MeshMaterial3d(materials.add(Color::srgb(0.8, 0.7, 0.6))),
    ));

    // Light
    commands.spawn((
        PointLight {
            shadows_enabled: true,
            ..default()
        },
        Transform::from_xyz(4.0, 8.0, 4.0),
    ));

    // Camera
    commands.spawn((
        Camera3d::default(),
        Transform::from_xyz(-2.5, 4.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y),
    ));
}

// Simple camera rotation to see our shaders from different angles
fn rotate_camera(time: Res&lt;Time&gt;, mut camera_query: Query&lt;&amp;mut Transform, With&lt;Camera3d&gt;&gt;) {
    for mut transform in camera_query.iter_mut() {
        let radius = 9.0;
        let angle = time.elapsed_secs() * 0.5;
        transform.translation.x = angle.cos() * radius;
        transform.translation.z = angle.sin() * radius;
        transform.look_at(Vec3::ZERO, Vec3::Y);
    }
}
</code></pre><p>And register it in <code>src/demos/mod.rs</code>:</p><pre><code class="language-rust">pub mod basic_scene;
</code></pre><p><strong>The pattern youâ€™ll follow for every article:</strong></p><ol><li>Create a new module in <code>src/demos/</code> (e.g., <code>first_shader.rs</code>)</li><li>Implement a <code>pub fn run()</code> function that starts a Bevy app</li><li>Add the module to <code>src/demos/mod.rs</code></li><li>Register it in the <code>demos</code> vector in <code>main.rs</code></li></ol><p>Thatâ€™s it! The demo selection system handles the rest.</p><h3 id="step-5-test-your-setup">Step 5: Test Your Setup</h3><p>Youâ€™re all set! Letâ€™s make sure everything works:</p><p>bash</p><pre><code class="language-bash"># Run the basic scene demo directly
cargo run 0.0

# Or try the interactive selection
cargo run
</code></pre><p>You should see a simple scene with a rotating camera orbiting around a cube.</p><p><strong>Try experimenting with the selection system:</strong></p><pre><code class="language-bash">cargo run basic     # Matches &quot;Basic Scene Setup&quot;
cargo run scene     # Same result
cargo run xyz       # No match - shows all demos and lets you select
</code></pre><p><strong>Congratulations!</strong> You now have a robust development environment with:</p><ul><li>Fast iteration with hot-reloading for shader changes</li><li>An intuitive demo selection system for jumping between examples</li><li>A clean project structure that will scale as you learn</li></ul><p>When you save changes to a shader file in the <code>assets</code> directory, Bevy will automatically detect the change and reload it in real-time. This instant feedback is the key to learning and experimenting with shaders effectively.</p><h2 id="understanding-the-project-structure">Understanding the Project Structure</h2><p>Hereâ€™s how everything fits together:</p><pre><code class="language-plaintext">bevy-shader-journey/
â”œâ”€â”€ assets/
â”‚   â””â”€â”€ shaders/              # Your .wgsl shader files
â”‚       â””â”€â”€ first_shader.wgsl # (We&#39;ll create these as we go)
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs               # Demo selection system
â”‚   â”œâ”€â”€ demos/                # One module per article
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ basic_scene.rs    # Article 0.0
â”‚   â”‚   â””â”€â”€ first_shader.rs   # (Article 1.1, etc.)
â”‚   â””â”€â”€ materials/            # Custom material definitions
â”‚       â””â”€â”€ mod.rs
â””â”€â”€ Cargo.toml
</code></pre><p><strong>The workflow:</strong></p><ol><li>Read an article to understand the concepts</li><li>Run the demo: <code>cargo run [article-number]</code></li><li>Look at the code in <code>src/demos/[name].rs</code></li><li>Examine the shader in <code>assets/shaders/[name].wgsl</code></li><li>Experiment - change values, break things, see what happens!</li><li>Move to the next article when ready</li></ol><h2 id="a-mindset-for-success">A Mindset for Success</h2><p>You are now ready to begin. As you dive into the world of shaders, keeping a few practical tips in mind will make the learning process smoother and more enjoyable.</p><ul><li><strong>Start Simple, Then Iterate.</strong>Â The golden rule of shader development. Always begin with the absolute most basic version of an effect that works, even if itâ€™s just a solid color. Once you have a working baseline, add complexity one small step at a time. This makes debugging infinitely easier.</li><li><strong>Embrace the Visual Debugging Loop.</strong>Â Your primary debugging tool is the screen itself. Is the effect too bright? Multiply byÂ 0.5. Is it upside down? Multiply a coordinate byÂ <code>-1.0</code>. Get comfortable making small, incremental changes and immediately observing the visual result.</li><li><strong>Use Descriptive Variable Names.</strong>Â Shaders can quickly become a maze of vector math. A variable namedÂ <code>surfaceToLightDirection</code>Â is a thousand times clearer thanÂ <code>vecL</code>. Your future self, trying to debug the code, will thank you.</li><li><strong>Save Your Progress Frequently.</strong>Â Shader development is highly experimental. Youâ€™ll often go down a path that leads to a visual mess. Using a version control system like Git to commit frequently after each small success will give you the freedom to experiment without fear of losing your working code.</li><li><strong>Jump Between Examples Freely.</strong> One of the beauties of our demo selection system is that you can easily revisit previous techniques. Forgot how normal mapping works? Just <code>cargo run normal</code> and refresh your memory. Want to compare two approaches? Run them side by side!</li></ul><h2 id="lets-get-started">Letâ€™s Get Started!</h2><p>Your development environment is configured, your mindset is right, and the path is laid out before you. That blank <code>.wgsl</code> file is no longer an intimidating obstacle - itâ€™s a canvas waiting for your creativity.</p><p>The demo selection system gives you the freedom to explore at your own pace, jumping between concepts and building your understanding incrementally. Each article in this series adds a new demo to your toolkit, and by the end, youâ€™ll have a comprehensive library of shader techniques at your fingertips.</p><p>Itâ€™s time to dive in and learn how to speak directly to the GPU.</p><p>Next up: [1.1 - Understanding the Graphics Pipeline]</p><hr><h2 id="quick-reference">Quick Reference</h2><p><strong>Running Demos:</strong></p><pre><code class="language-bash">cargo run 1.1              # By article number
cargo run pipeline         # By keyword
cargo run                  # Interactive selection
</code></pre><p><strong>Project Structure:</strong></p><ul><li><code>src/main.rs</code> - Demo selection system</li><li><code>src/demos/</code> - One module per article (each exports <code>pub fn run()</code>)</li><li><code>src/materials/</code> - Custom material definitions</li><li><code>assets/shaders/</code> - WGSL shader files</li></ul><p><strong>Development Tips:</strong></p><ul><li>Save a shader file â†’ Bevy auto-reloads it</li><li>Small changes â†’ Immediate visual feedback</li><li>Commit working code frequently</li><li>Use descriptive names in shader code</li></ul></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on December 9, 2025</p><div class="post__share"></div></footer><nav class="pagination"><div class="pagination__title"><span>Read other posts</span></div><div class="pagination__buttons"><a href="https://xav.github.io/11-understanding-the-graphics-pipeline/" class="btn next" rel="next" aria-label="[MISSING TRANSLATION]:  1.1 - Understanding the Graphics Pipeline "><span class="btn__text">1.1 - Understanding the Graphics Pipeline</span> <span class="btn__icon">â†’</span></a></div></nav></article></main><footer class="footer"><div class="footer__inner"><div class="footer__copyright"><p>Â© 2024 Powered by Publii CMS :: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank" rel="noopener">Theme</a> ported by the <a href="https://getpublii.com/customization-service/" target="_blank" rel="noopener">Publii Team</a></p></div></div></footer></div><script defer="defer" src="https://xav.github.io/assets/js/scripts.min.js?v=c2232aa7558e9517946129d2a1b8c770"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script><script defer="defer" src="https://xav.github.io/media/plugins/syntaxHighlighter/prism.js"></script></body></html>