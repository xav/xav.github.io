<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>Hexbee&#x27;s Dev Journal</title>
    <link href="https://xav.github.io/feed.xml" rel="self" />
    <link href="https://xav.github.io" />
    <updated>2025-12-10T18:56:56+01:00</updated>
    <author>
        <name>Xavier Basty Kjellberg</name>
    </author>
    <id>https://xav.github.io</id>

    <entry>
        <title>1.1 - Understanding the Graphics Pipeline</title>
        <author>
            <name>Xavier Basty Kjellberg</name>
        </author>
        <link href="https://xav.github.io/11-understanding-the-graphics-pipeline/"/>
        <id>https://xav.github.io/11-understanding-the-graphics-pipeline/</id>
        <media:content url="https://xav.github.io/media/posts/3/cover.png" medium="image" />
            <category term="wgsl"/>
            <category term="shaders"/>
            <category term="rust"/>
            <category term="bevy"/>

        <updated>2025-08-30T22:42:00+02:00</updated>
            <summary type="html">
                <![CDATA[
                        <img src="https://xav.github.io/media/posts/3/cover.png" alt="" />
                    What We’re Learning Welcome to the start of your shader programming journey! Before we can write a single line of WGSL code to create shimmering&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://xav.github.io/media/posts/3/cover.png" class="type:primaryImage" alt="" /></p>
                <h2 id="what-were-learning">What We’re Learning</h2>
<p>Welcome to the start of your shader programming journey! Before we can write a single line of WGSL code to create shimmering water or a glowing sword, we must first answer a fundamental question: <strong>what exactly is a shader?</strong></p><p>At its core, a shader is a small, highly-focused program that you, the developer, write. Unlike the Rust code that runs on your computer’s main processor (the CPU), a shader runs directly on the thousands of parallel cores of your Graphics Processing Unit (GPU). This gives you direct, low-level control over how your game’s graphics are rendered. Shaders are the modern key to controlling the look, feel, and performance of everything you see in a real-time 3D application.</p><p>This first chapter pulls back the curtain on the rendering process. We will build a complete mental model of the <strong>graphics pipeline</strong> - the step-by-step assembly line a GPU uses to turn the raw data of your 3D models into the final, vibrant pixels on your screen.</p><p>Understanding this pipeline is the single most important foundation for shader programming. Without it, writing shader code is like trying to assemble a car without knowing what an engine or a wheel does. With it, every new concept will have a clear place to belong.</p><p>By the end of this chapter, you’ll understand:</p><ul>
<li><strong>The Big Picture:</strong> The journey of your 3D model data from the CPU (your Bevy app) to the GPU (the rendering factory).</li>
<li><strong>The “Why” of GPUs:</strong> Why we need a specialized processor for graphics and how its parallel design is perfect for rendering.</li>
<li><strong>The Vertex’s Journey:</strong> How a single point in your 3D model travels through a series of “coordinate spaces” - from its local origin to its final position on your screen.</li>
<li><strong>The Two Programmable Stages:</strong> The specific jobs of the <strong>Vertex Shader</strong> (controlling shape and position) and the <strong>Fragment Shader</strong> (controlling color and appearance), and how your WGSL code fits into this process.</li>
</ul>
<h2 id="the-big-picture-cpu-to-screen">The Big Picture: CPU to Screen</h2>
<p>Let’s start with the fundamental question: <strong>How does a 3D model in your Bevy game become the final, colored pixels on your screen?</strong></p><p>The process is a hand-off of instructions and data from a general-purpose processor (the CPU) to a highly specialized one (the GPU). The CPU decides <em>what</em> needs to be drawn, while the GPU figures out how to draw it at incredible speed. The GPU performs this task using a dedicated assembly line called the <strong>graphics pipeline</strong>.</p><p>Here is a simplified map of that journey:</p><pre><code class="language-plaintext">┌───────────────────────────────────────────┐
│              CPU: The Director            │
│          (Your Bevy / Rust Code)          │
│                                           │
│  - Runs game logic, physics, AI, etc.     │
│  - Decides WHAT to draw this frame.       │
│  - Packages all necessary data for GPU.   │
└───────────────────────────────────────────┘
                       │
                       │ Sends a &quot;Draw Command&quot; with all required data
                       ↓
  ═════════════════════ GPU BOUNDARY ═════════════════════
                       ↓
┌───────────────────────────────────────────┐
│             GPU: The Factory              │
│       (Massively Parallel Hardware)       │
└───────────────────────────────────────────┘
                       │
                       ▼
┌───────────────────────────────────────────┐
│            1. VERTEX SHADER               │ «── [ YOUR WGSL CODE RUNS HERE ]
├───────────────────────────────────────────┤
│ INPUT:  A single vertex from a mesh       │
│         (e.g., its local position, UVs).  │
│                                           │
│ JOB:    Calculate the vertex&#39;s final      │
│         position on the screen.           │
│                                           │
│ OUTPUT: The vertex&#39;s position in          │
│         &quot;Clip Space&quot; &amp; other data         │
│         (like normals) for the next stage.│
└───────────────────────────────────────────┘
                       │
                       │ (GPU groups 3 processed vertices into a triangle)
                       ↓
┌───────────────────────────────────────────┐
│            2. RASTERIZATION               │ «── [ AUTOMATIC HARDWARE STAGE ]
├───────────────────────────────────────────┤
│ INPUT:  A triangle in screen space.       │
│                                           │
│ JOB:    Determine which pixels the        │
│         triangle covers.                  │
│                                           │
│ OUTPUT: A stream of &quot;Fragments.&quot;          │
│         (A fragment is a potential pixel  │
│         with smoothly interpolated data). │
└───────────────────────────────────────────┘
                       │
                       ↓
┌───────────────────────────────────────────┐
│           3. FRAGMENT SHADER              │ «── [ YOUR WGSL CODE RUNS HERE ]
├───────────────────────────────────────────┤
│ INPUT:  A single fragment with its        │
│         interpolated data (e.g., UVs).    │
│                                           │
│ JOB:    Calculate the final color for     │
│         that specific fragment.           │
│                                           │
│ OUTPUT: A single RGBA color.              │
└───────────────────────────────────────────┘
                       │
                       ↓
┌───────────────────────────────────────────┐
│           4. OUTPUT MERGER                │ «── [ AUTOMATIC HARDWARE STAGE ]
├───────────────────────────────────────────┤
│ JOB:    Take the colored fragment and     │
│         merge it into the final image.    │
│                                           │
│       - Performs Depth Test (is this      │
│         fragment behind something else?). │
│       - Performs Blending (for            │
│         transparency effects).            │
│       - Writes the final color.           │
└───────────────────────────────────────────┘
                       │
                       ▼
            ▓▓▓ PIXELS ON SCREEN ▓▓▓
</code></pre>
<p>This process spans two distinct worlds, each with a specific job.</p><h3 id="the-cpu-side-bevyrust-the-director">The CPU Side (Bevy/Rust): The Director</h3>
<p>Think of your CPU and your Bevy code as the <strong>director of a film</strong>. It’s smart, flexible, and responsible for all the high-level decision-making. For every single frame (60 times a second!), it runs your game logic, updates physics, handles input, and determines what needs to be on screen and where it should be.</p><p>Its final job for rendering is to prepare a detailed set of instructions and data for the GPU. This “frame package” includes:</p><ul>
<li><strong>Mesh Data</strong>: The raw vertex information (positions, normals, UV coordinates) for each model.</li>
<li><strong>Material Data</strong>: Your shader’s settings, like colors, roughness values, and which textures to use.</li>
<li><strong>Transformation Data</strong>: The matrices that define each object’s position, rotation, and scale in the world.</li>
<li><strong>Global Data</strong>: Information about the entire scene, like the camera’s position (View Matrix), its lens settings (Projection Matrix), and the location of lights.</li>
</ul>
<p>Once this package is assembled, the CPU sends it across the bus to the GPU and effectively says, “Here, render this.” The CPU’s main rendering job for this frame is now complete.</p><h3 id="the-gpu-side-shaders-the-vfx-studio">The GPU Side (Shaders): The VFX Studio</h3>
<p>Think of the GPU as a state-of-the-art <strong>VFX studio</strong> with an army of digital artists, each with a very specific job. This studio is built for one purpose: turning the director’s brief into a final, beautifully rendered image with incredible speed. Their process is the graphics pipeline.</p><p>When the brief arrives at the studio:</p><ol>
<li><strong>The Geometry &amp; Layout Artists (Vertex Shader):</strong> The first team gets the brief. This team consists of thousands of artists. Each artist is assigned a single corner (a <strong>vertex</strong>) of an actor or prop. Their only job is to calculate exactly where that specific corner will appear in the final camera shot, based on the actor’s position and the camera’s lens. They don’t color anything; they just map out the structure of the scene from the camera’s perspective.</li>
<li><strong>The Rendering Artists (Fragment Shader):</strong> After the layout is done, a second, even larger army of artists takes over. There are millions of them - one for every pixel of the final image. Each artist is assigned a single pixel to paint (a <strong>fragment</strong>). They look at the director’s notes for that surface (the material, the textures) and the lighting setup. Then, they calculate and apply the final, precise color for their one tiny pixel.</li>
</ol>
<p>This analogy directly maps to the GPU’s strengths:</p><ul>
<li><strong>Specialization:</strong> The geometry artists only do positioning; the rendering artists only do coloring.</li>
<li><strong>Parallelism:</strong> Millions of rendering artists can paint their individual pixels all at the exact same time, without needing to talk to each other. This is what makes the GPU so fast.</li>
</ul>
<p>Your WGSL shader code is the set of instructions - the “artistic direction” - you give to these two teams of digital artists.</p><h2 id="why-the-gpu-understanding-parallelism">Why the GPU? Understanding Parallelism</h2>
<p>It’s a fair question: your computer’s Central Processing Unit (CPU) is an incredibly powerful and fast processor. Why can’t it just draw the triangles? Why do we need a separate, specialized piece of hardware like a Graphics Processing Unit (GPU)?</p><p>The answer lies not in raw clock speed, but in a fundamentally different architectural philosophy: <strong>Serial vs. Parallel processing</strong>.</p><h3 id="the-cpu-a-master-chef">The CPU: A Master Chef</h3>
<p>Think of your CPU as a <strong>master chef in a world-class kitchen</strong>.</p><ul>
<li><strong>It is brilliant and versatile.</strong> It can follow any recipe (run any program), handle complex sequential steps, improvise when needed (handle interrupts and varied tasks), and manage the entire kitchen (the operating system).</li>
<li><strong>It has a few, very powerful cores.</strong> Like having 8 or 16 highly trained sous-chefs, it can work on a handful of complex, different dishes at once.</li>
</ul>
<p>If you asked this master chef to prepare a single, elaborate seven-course meal, they would excel. But if you asked them to make ten million identical hamburgers, the entire restaurant would grind to a halt. The chef’s genius is wasted on such a simple, repetitive task; its strength is in complexity and flexibility, not mass production.</p><h3 id="the-gpu-a-hyper-efficient-assembly-line">The GPU: A Hyper-Efficient Assembly Line</h3>
<p>Now, think of your GPU as a <strong>massive hamburger assembly line that stretches for miles</strong>.</p><ul>
<li><strong>It is highly specialized.</strong> It’s not designed to create new recipes. It’s designed to execute one simple recipe over and over again with breathtaking speed.</li>
<li><strong>It has thousands of simple cores.</strong> Instead of a few master chefs, you have thousands of line cooks. Each cook is trained for just one or two simple tasks - place the patty, add the cheese - but they all work at the exact same time.</li>
</ul>
<p>This factory can’t prepare a seven-course meal, but it can produce those ten million identical hamburgers in the blink of an eye. This is what we call <strong>“pleasingly parallel”</strong> work.</p><h3 id="graphics-is-a-pleasingly-parallel-problem">Graphics is a “Pleasingly Parallel” Problem</h3>
<p>Rendering a 3D scene is the ultimate assembly-line task. The core operations are simple, repetitive, and most importantly, <strong>independent</strong>.</p><ul>
<li>The calculation for vertex A’s final position does not depend on vertex B’s position.</li>
<li>The calculation for pixel #1’s color does not depend on pixel #2’s color.</li>
</ul>
<p>They can all be processed simultaneously.</p><p>Let’s put this into perspective. When rendering a moderately complex scene with 100,000 triangles on a standard 1080p display, for a single frame, you are asking the hardware to perform approximately:</p><ul>
<li><strong>300,000 vertex shader executions</strong> (one for each vertex)</li>
<li><strong>Millions of fragment shader executions</strong> (one for each pixel covered by a triangle)</li>
</ul>
<p>And this has to happen <strong>60 times every second</strong> for smooth gameplay.</p><p>This is the “ten million hamburgers” problem. A CPU, with its few brilliant cores, would be overwhelmed trying to handle these tasks one by one. But a GPU, with its thousands of simple cores, can process huge batches of vertices and pixels all at once.</p><p>This is why we write shaders for the GPU. We are providing the “recipe” for the assembly line workers. The GPU’s architecture is not just “more cores”; it’s a completely different philosophy of computation, one that is perfectly and beautifully matched to the massive, repetitive, and parallel nature of computer graphics.</p><h2 id="the-rendering-pipeline-in-detail">The Rendering Pipeline in Detail</h2>
<p>Let’s zoom in on the VFX studio’s assembly line. Each stage has a specific responsibility, taking a particular kind of data as input and producing a new kind of data for the next stage to work on.</p><h3 id="stage-1-the-application-stage-cpu---the-directors-brief">Stage 1: The Application Stage (CPU - The Director’s Brief)</h3>
<p>This stage isn’t on the GPU at all - it’s your Bevy application running on the CPU. Think of it as the “pre-production” step where the director prepares the detailed brief. Before any rendering can happen, your application needs to tell the GPU everything it needs to know about the world for the upcoming frame. Bevy’s renderer orchestrates this for you.</p><p>For every frame, Bevy traverses your scene’s Entity-Component-System (ECS) world and gathers all the necessary information:</p><pre><code class="language-rust">// You write this in Bevy, describing the &quot;what&quot; and &quot;where&quot;
commands.spawn((
 Mesh3d(meshes.add(Sphere::new(1.0))),
 MeshMaterial3d(materials.add(my_custom_material)),
));
</code></pre>
<p>From code like this, Bevy assembles the “shot list”:</p><ul>
<li><strong>What to draw</strong>: A list of meshes (the sphere’s vertices and triangles).</li>
<li><strong>How to draw it</strong>: The material to use and its properties (colors, textures).</li>
<li><strong>Where it is</strong>: The object’s world position, rotation, and scale (the Transform).</li>
<li><strong>From where to view it</strong>: The camera’s position and perspective settings.</li>
</ul>
<p>The final output of this stage is a highly-organized package of data and commands, which Bevy then sends over to the GPU to begin the actual rendering process.</p><h3 id="stage-2-the-vertex-shader-gpu---the-layout-artists">Stage 2: The Vertex Shader (GPU - The Layout Artists)</h3>
<p>This is the <strong>first programmable stage</strong> on the GPU, where your first piece of WGSL code runs. The vertex shader’s fundamental job is to answer one question for every single vertex of a mesh: <strong>“Where on the screen does this vertex end up?”</strong></p><ul>
<li><strong>Input</strong>: It receives the data for a <strong>single vertex</strong> at a time (its position in local model space, its normal vector, its UV coordinates, etc.).</li>
<li><strong>The Job</strong>: Its one mandatory task is to perform mathematical operations (usually matrix multiplications) to transform the vertex’s 3D position into a final 4D “clip space” position. This clip space coordinate is what the GPU hardware needs to figure out the 2D location on your monitor.</li>
<li><strong>Output</strong>: It must output that final clip space position. It can also pass along any other data it received or calculated (like colors, normals, or UVs) to be used later by the fragment shader.</li>
</ul>
<p>Here’s a conceptual view of what your WGSL code will do:</p><pre><code class="language-wgsl">@vertex
fn vertex(input: VertexInput) -&gt; VertexOutput {
    var output: VertexOutput;

    // The primary job: Transform the 3D local position into a final 2D screen position.
    output.position = project_to_screen(view_matrix * model_matrix * input.position);

    // A secondary job: Pass necessary data to the next stage.
    // Here, we&#39;re just passing the vertex&#39;s normal along for lighting calculations later.
    output.normal = input.normal;
    return output;
}
</code></pre>
<p><strong>Key Insight</strong>: Because this shader runs on every vertex, it gives you the power to manipulate the shape and position of your geometry in real-time. This is not just about moving objects around (which is best done by changing the Transform in Bevy); it’s about deforming the mesh itself. This is how you create dynamic effects like:</p><ul>
<li>Waving flags</li>
<li>Rippling water surfaces</li>
<li>Procedurally animated grass swaying in the wind</li>
</ul>
<h3 id="stage-3-the-rasterizer-gpu---automatic-hardware">Stage 3: The Rasterizer (GPU - Automatic Hardware)</h3>
<p>This stage is a piece of dedicated, non-programmable hardware on the GPU. It’s an automatic, incredibly fast process that you don’t write code for. The rasterizer takes the processed vertices from the vertex shader (three at a time to form a triangle) and figures out which pixels on the screen that triangle covers.</p><p>For every single pixel it covers, it generates a <strong>“fragment.”</strong> A fragment is a “potential pixel” - it contains all the information needed to calculate a final color.</p><p>This is also where the magic of <strong>interpolation</strong> happens. The rasterizer looks at the data you passed out of the vertex shader for each of the triangle’s three vertices and smoothly blends it across the surface of the triangle for each fragment.</p><p>Think of it like this:</p><figure class="post__image"><img loading="lazy" src="rasterizer" alt="media/files/1.1 - figure - Rasterizer.png" data-is-external-image="true"></figure><ul>
<li>A fragment near the top will receive a reddish color.</li>
<li>A fragment on the left edge will get a purplish color (red + blue).</li>
<li>A fragment right in the middle will get a muddy, grayish color, which is the mathematical average of red, green, and blue.</li>
</ul>
<p>The rasterizer does this for every single piece of data you passed along - colors, UV coordinates, normals, etc. The output is a massive stream of fragments, each one “pre-loaded” with its own unique, interpolated data, ready to be colored.</p><h3 id="stage-4-the-fragment-shader-gpu---the-rendering-artists">Stage 4: The Fragment Shader (GPU - The Rendering Artists)</h3>
<p>This is the <strong>second programmable stage</strong>, and it’s where most of the visual artistry happens. The fragment shader’s job is to answer one simple question for every single fragment generated by the rasterizer: <strong>“What color is this pixel?”</strong></p><ul>
<li><strong>Input</strong>: It receives the interpolated data for a <strong>single fragment</strong>. This includes its position on the screen and the smoothly blended values (like normals and UVs) that were passed from the vertex shader.</li>
<li><strong>The Job</strong>: To use this input data to perform calculations and return a single, final color.</li>
<li><strong>Output</strong>: It must output a <code>vec4&lt;f33&gt;</code> representing an RGBA color. This is the color that will be written to the screen (assuming it passes final tests like depth testing).</li>
</ul>
<p>Here’s a conceptual view of what your WGSL code will do:</p><pre><code class="language-wgsl">@fragment
fn fragment(input: FragmentInput) -&gt; @location(0) vec4&lt;f32&gt; {
    // The input data (e.g., input.normal) has already been smoothly interpolated for us.
    // We can use it to calculate lighting for this specific pixel.
    let lighting = calculate_light(input.normal, light_direction);

    // We could also sample a texture using the interpolated UVs.
    let surface_color = sample_texture(input.uv);

    // Combine them to get the final color.
    let final_color = surface_color * lighting;
    return vec4&lt;f32&gt;(final_color, 1.0); // Return the final RGBA value
}
</code></pre>
<p><strong>Key Insight</strong>: The fragment shader runs for potentially millions of pixels every frame. This is your chance to define the appearance of your object’s surface with incredible detail. This is where you:</p><ul>
<li>Apply lighting calculations to create highlights and shadows.</li>
<li>Sample textures to give a surface detail and color.</li>
<li>Create procedural patterns like stripes, checkerboards, or noise.</li>
<li>Implement special effects like glowing, outlines, or distortion.</li>
</ul>
<h2 id="the-coordinate-space-journey">The Coordinate Space Journey</h2>
<p>One of the most initially confusing, but ultimately powerful, concepts in graphics programming is the journey a vertex takes through different <strong>coordinate spaces</strong>. Each space is a different frame of reference, like describing a location from a different point of view. The vertex shader’s main job is to transform a vertex from one space to the next, like a series of conversions, until it lands in the right spot on the screen.</p><p>Think of it like giving directions to a friend:</p><ol>
<li>“The book is on the second shelf of the bookcase.” (<strong>Local Space</strong>: The position is relative to the bookcase).</li>
<li>“The bookcase is against the north wall of the living room.” (<strong>World Space</strong>: Now the bookcase’s position is relative to the entire house).</li>
<li>“Stand in the doorway and look towards the fireplace.” (<strong>View Space</strong>: Now everything is described from your friend’s point of view).</li>
<li>“The book you’re looking for should be in the upper-left part of your vision.” (<strong>Clip Space</strong>: This is what’s in their field of view).</li>
</ol>
<p>In 3D graphics, we perform these transformations using matrix mathematics.</p><p><strong>Note</strong>: Don’t worry if the matrix math looks intimidating right now. We have a dedicated chapter later that explains how matrices work. For now, just focus on the purpose of each transformation - what question it answers.</p><h3 id="1-local-space-or-model-space">1. Local Space (or Model Space)</h3>
<p><strong>The Question:</strong> “What does this object look like by itself?”</p><p>This is the object’s blueprint. When an artist creates a 3D model of a car, they don’t care where it will be in your game world. They model it at the center of its own universe, the origin <code>(0, 0, 0)</code>. The coordinates of every vertex are relative only to the car’s own center point.</p><pre><code class="language-plaintext">A car&#39;s front-right tire vertex in Local Space might be:
(0.8, 0.3, 1.5)
</code></pre>
<h3 id="2-world-space">2. World Space</h3>
<p><strong>The Question:</strong> “Where is this object in the game world?”</p><p>This is the shared, global coordinate system of your entire scene. It’s the common frame of reference where all your objects, lights, and the camera coexist. When you give an entity a Transform in Bevy, you are defining its position, rotation, and scale within this World Space.</p><pre><code class="language-rust">// This Transform moves the object from its local origin to a specific spot in the world.
Transform::from_xyz(10.0, 0.0, -20.0)
</code></pre>
<p>The <strong>Model Matrix</strong>, which Bevy derives from this <code>Transform</code>, is the mathematical tool that converts vertices from <strong>Local Space</strong> to <strong>World Space</strong>. Your vertex shader applies it to every vertex.</p><pre><code class="language-plaintext">Local Position × Model Matrix = World Position
</code></pre>
<h3 id="3-view-space-or-camera-space">3. View Space (or Camera Space)</h3>
<p><strong>The Question:</strong> “How does the world look from the camera’s perspective?”</p><p>Once everything is placed in the world, we need to view it. To make the math simpler for the next step, we transform the entire world so that the camera is at the origin <code>(0, 0, 0)</code> and looking down a specific axis (typically negative Z). Everything in the world is now positioned relative to the camera. An object in front of the camera will have a negative Z coordinate, an object to the camera’s left will have a negative X, and so on.</p><p>The <strong>View Matrix</strong> performs this transformation. It’s calculated from the camera’s own world-space transform.</p><pre><code class="language-plaintext">World Position × View Matrix = View Position
</code></pre>
<h3 id="4-clip-space">4. Clip Space</h3>
<p><strong>The Question:</strong> “Is this vertex inside the viewable area, and if so, where?”</p><p>This is the final and most abstract space that the vertex shader is responsible for creating. It’s a standardized, cube-like volume that represents everything the camera can see. The transformation into this space, performed by the <strong>Projection Matrix</strong>, does two magical things:</p><ol>
<li><strong>It applies perspective.</strong> It mathematically squishes the 3D scene so that objects farther away from the camera appear smaller than objects that are closer. This is what creates the illusion of depth.</li>
<li><strong>It normalizes the coordinates.</strong> Everything that will be visible on screen is mapped into a neat box where the X and Y coordinates range from -1 to 1. The Z coordinate is also remapped (usually to a <code>[0, 1]</code> range) to represent depth.</li>
</ol>
<p>The GPU now has a simple job: any vertex with X or Y coordinates outside of this <code>[-1, 1]</code> range is “clipped” and discarded, as it is off-screen. The Z coordinate will be used in a later stage for depth testing (figuring out if one object is in front of another).</p><pre><code class="language-plaintext">View Position × Projection Matrix = Clip Position
</code></pre>
<p>The mandatory output of your vertex shader is this final Clip Space position.</p><h3 id="5-screen-space">5. Screen Space</h3>
<p><strong>The Question:</strong> “Which specific pixel on my monitor does this correspond to?”</p><p>This final step is handled <strong>automatically by the GPU</strong> after the vertex shader is done. The hardware takes the <code>[-1, 1]</code> Clip Space coordinates and maps them to the actual pixel coordinates of your window (e.g., from <code>(0, 0)</code> in the top-left to <code>(1920, 1080)</code> in the bottom-right). This is not something you calculate in your shaders; it’s the final output of the fixed-function part of the pipeline before the fragment shader runs.</p><h2 id="putting-it-all-together-the-life-of-a-single-vertex">Putting It All Together: The Life of a Single Vertex</h2>
<p>Let’s trace the complete life of a single vertex, from its creation in a modeling tool to its final appearance as a colored pixel on your screen. We’ll follow a vertex at the very top of a sphere model.</p><h3 id="1-the-blueprint-cpu---local-space">1. The Blueprint (CPU - Local Space)</h3>
<p>It begins its life in a 3D modeling program. An artist defines a sphere, and our vertex is created at the very top. Relative to the sphere’s own center, its position is simply (0.0, 1.0, 0.0). This is its <strong>Local Space</strong> position. This data is loaded into Bevy as part of a Mesh asset.</p><h3 id="2-setting-the-scene-cpu---the-directors-brief">2. Setting the Scene (CPU - The Director’s Brief)</h3>
<p>Your Bevy application decides where this sphere belongs in the game world. You assign it a <code>Transform</code> to place it, for example, at world coordinates <code>(5.0, 2.0, -3.0)</code>. The CPU doesn’t move the vertex itself; instead, it calculates a <strong>Model Matrix</strong> from this transform and packages it up, ready to be sent to the GPU’s VFX studio.</p><h3 id="3-the-great-transformation-gpu---vertex-shader">3. The Great Transformation (GPU - Vertex Shader)</h3>
<p>Now the director’s brief is uploaded to the GPU, and our programmable <strong>Vertex Shader</strong> takes over. This is where the “Layout Artists” get to work. The shader receives our vertex’s original local position, <code>(0, 1, 0)</code>, along with the Model, View, and Projection matrices. It then performs the crucial sequence of multiplications to find the vertex’s final on-screen position:</p><ul>
<li><strong>To World Space</strong>: The shader multiplies the local position by the Model Matrix. This moves the vertex into the shared <strong>World Space</strong>. Our vertex at <code>(0, 1, 0)</code> is now effectively at <code>(5.0, 3.0, -3.0)</code> in the game world (position + model’s height).</li>
<li><strong>To View Space</strong>: Next, it multiplies the new world position by the View Matrix. This transforms the vertex into <strong>View Space</strong>, making its coordinates relative to the camera’s perspective. Its position might now be something like <code>(-2.0, 1.0, -5.0)</code>, meaning it’s slightly to the camera’s left, above its center, and some distance in front of it.</li>
<li><strong>To Clip Space</strong>: Finally, it multiplies the view position by the Projection Matrix. This applies perspective and transforms the vertex into the final, required <strong>Clip Space</strong>. The position might now be <code>(-0.4, 0.2, 0.8)</code>. This tells the GPU the vertex is on-screen (since X and Y are between <code>-1</code> and <code>1</code>) and provides its depth. This <code>vec4</code> is the mandatory output of the vertex shader.</li>
</ul>
<p>Simultaneously, the vertex shader also prepares any other data needed for coloring, like the vertex’s color or normal vector, and passes it along.</p><h3 id="4-the-triangle-factory-gpu---rasterizer">4. The Triangle Factory (GPU - Rasterizer)</h3>
<p>The vertex, now just a point in Clip Space, is grouped by the GPU with two other processed vertices to form a triangle. The hardware <strong>Rasterizer</strong> takes over, calculating exactly which screen pixels this triangle covers. For each covered pixel, it generates a “fragment” and <strong>interpolates</strong> all the data that the vertex shaders passed out (like colors or UVs), creating a smooth gradient of values across the triangle’s face.</p><h3 id="5-the-coloring-book-gpu---fragment-shader">5. The Coloring Book (GPU - Fragment Shader)</h3>
<p>A single fragment, born from the rasterizer, arrives at our programmable <strong>Fragment Shader</strong>. Now the “Rendering Artists” do their job. The fragment carries its own unique, interpolated data (e.g., a color that is a blend of the three corner vertices’ colors). The fragment shader’s sole job is to use this information to calculate a final RGBA color. It might sample a texture, calculate lighting, or perform any number of other operations.</p><h3 id="6-the-final-pixel-gpu---output-merger">6. The Final Pixel (GPU - Output Merger)</h3>
<p>The fragment shader outputs its calculated color. This color, along with the fragment’s depth, is sent to the final hardware stage. The GPU performs a <strong>depth test</strong> to see if this fragment is in front of whatever is already on the screen at that pixel. If it is, its color is written to the framebuffer, becoming one of the millions of pixels that form the final image you see. Our vertex has completed its journey.</p><h2 id="a-mental-model-for-your-shaders">A Mental Model for Your Shaders</h2>
<p>The rendering pipeline can seem complex, but by holding on to our “Director and VFX Studio” analogy, we can assign a clear, relatable job to each programmable stage.</p><h3 id="1-the-vertex-shader-the-vfx-layout-artist">1. The Vertex Shader: The VFX Layout Artist</h3>
<p>Your WGSL code in the vertex shader provides the instructions for the layout artists at the VFX studio.</p><table>
<thead>
<tr>
<th>Analogy</th>
<th>Role</th>
<th>Shader Code Focus</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Staging the scene for the camera.</strong></td>
<td>Your job is to take the 3D models (defined in their own local space) and <strong>place them correctly in the world and frame them perfectly in the camera’s shot.</strong></td>
<td><strong>Transformation.</strong> You use matrix math to move each vertex of a model from its origin to its final position relative to the camera’s view. You can also dynamically move vertices here to create animations like waving flags or rippling water.</td>
</tr>
<tr>
<td><strong>Defining the final composition.</strong></td>
<td>You must output the final projected position of each vertex. This is the main deliverable for this stage.</td>
<td><code>output.position = projection * view * model * local_pos;</code></td>
</tr>
<tr>
<td><strong>Prepping for the colorists.</strong></td>
<td>You pass along any surface information that the next team will need, like texture coordinates (uv) or which way the surface is facing (normal).</td>
<td><code>output.world_normal = ..., output.uv = ...</code></td>
</tr>
</tbody></table>
<h3 id="2-the-rasterizer-the-digital-render-farm">2. The Rasterizer: The Digital Render Farm</h3>
<p>This is an automated, non-programmable hardware stage. You don’t write code for it, but you need to know what it does.</p><table>
<thead>
<tr>
<th>Analogy</th>
<th>Role</th>
<th>Shader Code Focus</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Automated rendering setup.</strong></td>
<td>The GPU’s hardware takes the 3D triangles you’ve positioned in the previous step…</td>
<td><strong>None.</strong> This is a fixed, non-programmable step.</td>
</tr>
<tr>
<td><strong>…and projects them onto a 2D grid.</strong></td>
<td>The hardware determines exactly which pixels on the screen are covered by each triangle. For each covered pixel, it creates a “fragment” and <strong>interpolates</strong> (smoothly blends) the data from the triangle’s corners.</td>
<td>A fragment in the middle of a triangle gets a perfectly blended uv coordinate and normal vector, ready for the next stage.</td>
</tr>
</tbody></table>
<h3 id="3-the-fragment-shader-the-vfx-coloring--lighting-artist">3. The Fragment Shader: The VFX Coloring &amp; Lighting Artist</h3>
<p>Your WGSL code in the fragment shader provides the instructions for the massive team of coloring and lighting artists.</p><table>
<thead>
<tr>
<th>Analogy</th>
<th>Role</th>
<th>Shader Code Focus</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Painting one pixel at a time.</strong></td>
<td>Your job is to look at a single, uncolored pixel (a fragment) and <strong>decide what its final color should be.</strong> This is where all the visual artistry happens.</td>
<td><strong>Color Calculation.</strong> You have complete control over the pixel’s final RGBA value.</td>
</tr>
<tr>
<td><strong>Using the prepped materials.</strong></td>
<td>You use the interpolated data from the previous stage to perform your work.</td>
<td><code>return vec4&lt;f32&gt;(final_color, alpha);</code></td>
</tr>
<tr>
<td><strong>Applying textures and lighting.</strong></td>
<td>You can sample <strong>textures</strong> using the interpolated uv coordinates and use the interpolated normal vector to calculate realistic <strong>lighting</strong> and shadows.</td>
<td><code>textureSample(...)</code>, <code>dot(normal, light_dir)</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="complete-example-visualizing-the-pipeline">Complete Example: Visualizing the Pipeline</h2>
<p>Theory is essential, but seeing is believing. To make these abstract concepts concrete, we’ll build a simple, interactive shader in Bevy. This shader won’t create a realistic object; instead, it will act as a diagnostic tool, allowing us to “see” the data at different stages of the pipeline.</p><p><strong>A Note Before We Begin:</strong> You will see new WGSL syntax (@location, @group, etc.) and Bevy patterns (AsBindGroup, MaterialPlugin) in the code below. <strong>Do not worry about understanding every line right now.</strong> We will break down all of these concepts in detail in the upcoming articles.</p><p>The goal of this example is to <strong>observe the visual output</strong> of each mode and connect it back to the high-level pipeline concepts we just learned:</p><ul>
<li>How data is <strong>interpolated</strong> across a surface (the smooth normal colors).</li>
<li>How the fragment shader runs for <strong>every pixel</strong> (the sharp checkerboard).</li>
<li>How data from the <strong>vertex stage</strong> is used in the <strong>fragment stage</strong> (the height gradient).</li>
</ul>
<p>Focus on the “what you’re seeing” part, and treat the code as a preview of what you’ll soon master.</p><h3 id="our-goal">Our Goal</h3>
<p>We will create a custom material for a sphere that can cycle through three different visualization modes by pressing a key. Each mode will highlight a different core concept of the rendering pipeline that we’ve just discussed.</p><h3 id="what-this-project-demonstrates">What This Project Demonstrates</h3>
<ul>
<li><strong>Data Flow and Interpolation:</strong> How data (like normal vectors) passed from the vertex shader is smoothly interpolated by the rasterizer before reaching the fragment shader.</li>
<li><strong>Per-Fragment Processing:</strong> Proof that the fragment shader runs independently for every single pixel, allowing it to create complex patterns based on a fragment’s world position.</li>
<li><strong>Vertex Data in Fragment Shaders:</strong> How to use data prepared by the vertex shader (like the final world position) to drive calculations in the fragment shader.</li>
</ul>
<h3 id="the-shader-assetsshadersdebug_pipelinewgsl">The Shader (<code>assets/shaders/debug_pipeline.wgsl</code>)</h3>
<p>This single WGSL file contains both our vertex and fragment shaders. The key element is the material.mode uniform, a number we can change from our Rust code to switch the logic inside the fragment shader.</p><ul>
<li>The <strong>vertex shader</strong> is standard: it transforms the vertex position into clip space and also passes the vertex’s world position and world normal along to the fragment stage.</li>
<li>The <strong>fragment shader</strong> uses an <code>if/else if</code> chain based on material.mode to decide how to color the current pixel.</li>
</ul>
<pre><code class="language-wgsl">#import bevy_pbr::mesh_functions
#import bevy_pbr::view_transformations::position_world_to_clip
#import bevy_pbr::forward_io::VertexOutput

struct DebugMaterial {
    mode: u32,
}

@group(2) @binding(0)
var&lt;uniform&gt; material: DebugMaterial;

@vertex
fn vertex(
    @builtin(instance_index) instance_index: u32,
    @location(0) position: vec3&lt;f32&gt;,
    @location(1) normal: vec3&lt;f32&gt;,
) -&gt; VertexOutput {
    var out: VertexOutput;
    
    // Get the model transformation matrix
    let world_from_local = mesh_functions::get_world_from_local(instance_index);
    
    // Transform position to world space
    let world_position = mesh_functions::mesh_position_local_to_world(
        world_from_local,
        vec4&lt;f32&gt;(position, 1.0)
    );
    
    // Transform to clip space (final vertex shader output)
    out.position = position_world_to_clip(world_position.xyz);
    
    // Transform normal to world space
    out.world_normal = mesh_functions::mesh_normal_local_to_world(
        normal,
        instance_index
    );
    
    // Pass world position to fragment shader
    out.world_position = world_position;
    
    return out;
}

@fragment
fn fragment(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    // Mode 0: Show normals (demonstrates interpolation between vertices)
    if material.mode == 0u {
        // Normals range from -1 to 1, convert to 0-1 for RGB color
        // Red = X direction, Green = Y direction, Blue = Z direction
        let color = (in.world_normal + 1.0) * 0.5;
        return vec4&lt;f32&gt;(color, 1.0);
    }
    
    // Mode 1: Checkerboard pattern (demonstrates per-pixel fragment shader work)
    if material.mode == 1u {
        // Create a 3D checkerboard pattern
        let scale = 3.0;
        let x = i32(floor(in.world_position.x * scale));
        let y = i32(floor(in.world_position.y * scale));
        let z = i32(floor(in.world_position.z * scale));
        
        // Use bitwise AND to alternate between 0 and 1
        let checker = (x + y + z) &amp; 1;
        
        if checker == 0 {
            return vec4&lt;f32&gt;(0.9, 0.9, 0.9, 1.0); // Light gray
        } else {
            return vec4&lt;f32&gt;(0.2, 0.2, 0.8, 1.0); // Blue
        }
    }
    
    // Mode 2: Height-based gradient (demonstrates math in fragment shader)
    if material.mode == 2u {
        // Color based on Y position (height) in world space
        // Map from -2 to 2 range to 0-1 range for color
        let height = (in.world_position.y + 2.0) / 4.0;
        let color = vec3&lt;f32&gt;(height, 0.5, 1.0 - height);
        return vec4&lt;f32&gt;(color, 1.0);
    }
    
    // Default: Solid color
    return vec4&lt;f32&gt;(1.0, 0.0, 0.0, 1.0);
}
</code></pre>
<h3 id="the-rust-material-srcmaterialsdebug_pipeliners">The Rust Material (<code>src/materials/debug_pipeline.rs</code>)</h3>
<p>This is the Rust-side definition of our material. It’s a simple struct that mirrors the DebugMaterial struct in our shader, allowing Bevy’s rendering engine to send our chosen mode value to the GPU.</p><pre><code class="language-rust">use bevy::prelude::*;
use bevy::render::render_resource::{AsBindGroup, ShaderRef};

#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
pub struct DebugPipelineMaterial {
    #[uniform(0)]
    pub mode: u32,
}

impl Material for DebugPipelineMaterial {
    fn fragment_shader() -&gt; ShaderRef {
        &quot;shaders/debug_pipeline.wgsl&quot;.into()
    }

    fn vertex_shader() -&gt; ShaderRef {
        &quot;shaders/debug_pipeline.wgsl&quot;.into()
    }
}
</code></pre>
<p>Don’t forget to add it to <code>src/materials/mod.rs</code>:</p><pre><code class="language-rust">// ... other materials
pub mod debug_pipeline;
</code></pre>
<h3 id="the-demo-module-srcdemosdebug_pipeliners">The Demo Module (<code>src/demos/debug_pipeline.rs</code>)</h3>
<p>This Rust module sets up our Bevy scene. It spawns a sphere with our custom <code>DebugPipelineMaterial</code>, adds a camera and light, and sets up the UI text. Most importantly, it contains the <code>cycle_debug_mode</code> system, which listens for the spacebar press and updates the mode field on our material, triggering the change in the shader.</p><pre><code class="language-rust">use crate::materials::debug_pipeline::DebugPipelineMaterial;
use bevy::prelude::*;

pub fn run() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(MaterialPlugin::&lt;DebugPipelineMaterial&gt;::default())
        .add_systems(Startup, setup)
        .add_systems(Update, (rotate_camera, cycle_debug_mode))
        .run();
}

fn setup(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;DebugPipelineMaterial&gt;&gt;,
) {
    // Spawn a sphere with our debug material (better for showing interpolation)
    commands.spawn((
        Mesh3d(meshes.add(Sphere::new(1.0))),
        MeshMaterial3d(materials.add(DebugPipelineMaterial { mode: 0 })),
    ));

    // Light
    commands.spawn((
        PointLight {
            shadows_enabled: true,
            ..default()
        },
        Transform::from_xyz(4.0, 8.0, 4.0),
    ));

    // Camera
    commands.spawn((
        Camera3d::default(),
        Transform::from_xyz(-2.5, 4.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y),
    ));

    // UI to show current mode
    commands.spawn((
        Text::new(&quot;Press SPACE to cycle debug modes\nMode 0: Normals (shows interpolation)&quot;),
        Node {
            position_type: PositionType::Absolute,
            top: Val::Px(10.0),
            left: Val::Px(10.0),
            ..default()
        },
    ));
}

fn rotate_camera(time: Res&lt;Time&gt;, mut camera_query: Query&lt;&amp;mut Transform, With&lt;Camera3d&gt;&gt;) {
    for mut transform in camera_query.iter_mut() {
        let radius = 9.0;
        let angle = time.elapsed_secs() * 0.5;
        transform.translation.x = angle.cos() * radius;
        transform.translation.z = angle.sin() * radius;
        transform.look_at(Vec3::ZERO, Vec3::Y);
    }
}

fn cycle_debug_mode(
    keyboard: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;DebugPipelineMaterial&gt;&gt;,
    mut text_query: Query&lt;&amp;mut Text&gt;,
) {
    if keyboard.just_pressed(KeyCode::Space) {
        for (_, material) in materials.iter_mut() {
            material.mode = (material.mode + 1) % 3;

            for mut text in text_query.iter_mut() {
                **text = match material.mode {
                    0 =&gt; &quot;Press SPACE to cycle debug modes\nMode 0: Normals (shows interpolation)&quot;.to_string(),
                    1 =&gt; &quot;Press SPACE to cycle debug modes\nMode 1: Checkerboard (per-pixel processing)&quot;.to_string(),
                    2 =&gt; &quot;Press SPACE to cycle debug modes\nMode 2: Height Gradient (fragment math)&quot;.to_string(),
                    _ =&gt; &quot;Unknown mode&quot;.to_string(),
                };
            }
        }
    }
}
</code></pre>
<p>Don’t forget to add it to <code>src/demos/mod.rs</code>:</p><pre><code class="language-rust">// ... other demoss
pub mod debug_pipeline;
</code></pre>
<p>And register it in <code>src/main.rs</code>:</p><pre><code class="language-rust">Demo {
    number: &quot;1.1&quot;,
    title: &quot;Understanding the Graphics Pipeline&quot;,
    run: demos::debug_pipeline::run,
},
</code></pre>
<h3 id="running-the-demo">Running the Demo</h3>
<p>When you run the project, you will see a sphere. Pressing the spacebar will cycle through the three different debug visualizations, each revealing a different aspect of the pipeline’s inner workings.</p><h4 id="controls">Controls</h4>
<table>
<thead>
<tr>
<th>Control</th>
<th>Action</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SPACE</strong></td>
<td>Cycle to the next visualization mode (0 -&gt; 1 -&gt; 2 -&gt; 0).</td>
</tr>
</tbody></table>
<h4 id="what-youre-seeing">What You’re Seeing</h4>
<p>![[screenshot - 1.png]]
![[screenshot - 2.png]]
![[screenshot - 3.png]]</p><table>
<thead>
<tr>
<th>Mode</th>
<th>Description</th>
<th>What It Proves</th>
</tr>
</thead>
<tbody><tr>
<td><strong>0 - Normals</strong></td>
<td>The sphere is colored based on the direction its surface is facing. Red points right (+X), Green points up (+Y), and Blue points forward (+Z). You see smooth gradients of color across the entire surface.</td>
<td>This demonstrates <strong>interpolation</strong>. The normals are defined only at the vertices, but the rasterizer smoothly blends them between those points, giving every single pixel its own unique normal vector to use for coloring.</td>
</tr>
<tr>
<td><strong>1 - Checkerboard</strong></td>
<td>The sphere is covered in a 3D checkerboard pattern that appears fixed in the world as the sphere rotates through it. The pattern is sharp and blocky.</td>
<td>This demonstrates <strong>per-fragment processing</strong>. The fragment shader calculates which color to be (light gray or blue) for every single pixel independently, based on that pixel’s position in world space.</td>
</tr>
<tr>
<td><strong>2 - Height Gradient</strong></td>
<td>The sphere is colored with a gradient based on its height in the world. The bottom is magenta, and the top is cyan.</td>
<td>This demonstrates using <strong>vertex shader data in the fragment shader</strong>. The vertex shader calculates the world_position for each vertex. The rasterizer interpolates it, and the fragment shader uses the Y-component of that position to calculate a color.</td>
</tr>
</tbody></table>
<h2 id="key-takeaways">Key Takeaways</h2>
<p>This chapter covered a lot of ground. Before moving on, take a moment to solidify these five core concepts. They are the foundation for everything that follows.</p><ol>
<li><strong>The Pipeline is a CPU-to-GPU Process.</strong><br> Rendering is a collaboration. Your Bevy code on the CPU acts as the <strong>Director</strong>, preparing the scene’s data (meshes, materials, transforms). It then hands this “shot list” to the GPU, a specialized <strong>VFX Studio</strong> that executes the rendering process through a hardware assembly line.</li>
<li><strong>Shaders are Your Instructions for the VFX Artists.</strong><br> You cannot change the hardware pipeline itself, but you can write small, highly focused programs called <strong>shaders</strong> that run at critical, programmable stages. The GPU’s massively parallel architecture executes your shader code for millions of vertices and pixels per second, which is what makes real-time 3D graphics possible.</li>
<li><strong>The Vertex Shader’s Job is to POSITION Geometry.</strong><br> This is your “Layout Artist” stage. The vertex shader runs once for every vertex in your mesh. Its primary responsibility is to take that vertex’s 3D position from the original model and transform it through a series of coordinate spaces until it has its final, correct position on the 2D screen.</li>
<li><strong>The Fragment Shader’s Job is to COLOR Pixels.</strong><br> This is your “Coloring &amp; Lighting Artist” stage. After the hardware rasterizer determines which pixels a triangle covers, the fragment shader runs once for every single one of those “fragments.” Its sole responsibility is to calculate and return the final RGBA color for that specific spot on the screen. This is where you apply textures, lighting, and visual effects.</li>
<li><strong>Data Flows and is Interpolated from Vertex to Fragment.</strong><br> The two shaders are connected. The vertex shader can pass data (like UV coordinates or normal vectors) to the next stage. The hardware <strong>Rasterizer</strong> automatically <strong>interpolates</strong> (smoothly blends) this data across the face of the triangle, making a unique version of it available to the fragment shader for every single pixel.</li>
</ol>
<h2 id="whats-next">What’s Next?</h2>
<p>You now have the essential mental model for the rendering pipeline - you understand where your shader code runs and the specific job of each stage. With this “map” in hand, we are finally ready to learn the language of the GPU’s artists themselves.</p><p>In the next article, we will dive into the fundamental building blocks of the WGSL language: its data types and variables. You’ll learn how to represent positions, colors, and transformations in your code using scalars, vectors, and matrices.</p><p><em>Next up:</em> <a href="https://hexbee.hashnode.dev/12-wgsl-fundamentals-data-types-and-variables"><strong><em>1.2 - WGSL Fundamentals - Data Types &amp; Variables</em></strong></a></p><hr>
<h2 id="quick-reference">Quick Reference</h2>
<p>A summary of the core concepts for quick lookup.</p><h3 id="the-pipeline-stages--their-jobs">The Pipeline Stages &amp; Their Jobs</h3>
<table>
<thead>
<tr>
<th>Stage</th>
<th>Analogy</th>
<th>Role (What it does)</th>
<th>Programmable?</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1. Application (CPU)</strong></td>
<td>The Director</td>
<td>Prepares all scene data: meshes, materials, transforms, camera info.</td>
<td>Yes (Rust)</td>
</tr>
<tr>
<td><strong>2. Vertex Shader</strong></td>
<td>The Layout Artist</td>
<td>Runs <strong>per-vertex</strong> to calculate its final on-screen position (in Clip Space).</td>
<td><strong>Yes (WGSL)</strong></td>
</tr>
<tr>
<td><strong>3. Rasterizer</strong></td>
<td>The Render Farm</td>
<td><strong>Automatic hardware</strong> step that turns 3D triangles into a 2D grid of fragments.</td>
<td>No</td>
</tr>
<tr>
<td><strong>4. Fragment Shader</strong></td>
<td>The Coloring Artist</td>
<td>Runs <strong>per-fragment</strong> to calculate its final RGBA color.</td>
<td><strong>Yes (WGSL)</strong></td>
</tr>
<tr>
<td><strong>5. Output Merger</strong></td>
<td>The Final Print</td>
<td><strong>Automatic hardware</strong> step that performs depth tests and writes the final color.</td>
<td>No</td>
</tr>
</tbody></table>
<h3 id="the-coordinate-space-journey-1">The Coordinate Space Journey</h3>
<p>This is the required path a single vertex position takes through the Vertex Shader.</p><pre><code class="language-plaintext">Local Space → World Space → View Space → Clip Space
</code></pre>
<p>(The GPU then automatically handles the final conversion to Screen Space)</p><h3 id="core-concepts">Core Concepts</h3>
<ul>
<li><strong>Parallelism</strong>: The GPU’s core strength. It processes thousands of vertices and millions of fragments simultaneously. Your shader code is the instruction set for this parallel work.</li>
<li><strong>Interpolation</strong>: The process by which the <strong>Rasterizer</strong> automatically and smoothly blends data (like colors, UVs, or normals) that was output by the <strong>Vertex Shader</strong> at the corners of a triangle. This provides a unique value for that data to the <strong>Fragment Shader</strong> for every pixel the triangle covers.</li>
</ul>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Learning WGSL Shaders with Bevy 0.16: A Practical Journey</title>
        <author>
            <name>Xavier Basty Kjellberg</name>
        </author>
        <link href="https://xav.github.io/learning-wgsl-shaders-with-bevy-016-a-practical-journey/"/>
        <id>https://xav.github.io/learning-wgsl-shaders-with-bevy-016-a-practical-journey/</id>
        <media:content url="https://xav.github.io/media/posts/2/cover.png" medium="image" />
            <category term="wgsl"/>
            <category term="shaders"/>
            <category term="rust"/>
            <category term="bevy"/>

        <updated>2025-08-29T22:38:00+02:00</updated>
            <summary type="html">
                <![CDATA[
                        <img src="https://xav.github.io/media/posts/2/cover.png" alt="" />
                    Does This Sound Familiar? You’re a Bevy developer. You love Rust’s power and safety, and you’ve started to feel comfortable building scenes and game logic.
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://xav.github.io/media/posts/2/cover.png" class="type:primaryImage" alt="" /></p>
                <h2 id="does-this-sound-familiar">Does This Sound Familiar?</h2>
<p>You’re a Bevy developer. You love Rust’s power and safety, and you’ve started to feel comfortable building scenes and game logic. But now you want to create something truly unique - a shimmering shield, a stylized water surface, a custom lighting model - and you realize you need to write a shader.</p><p>So you open a <code>.wgsl</code> file… and you hit a wall.</p><p>You look for tutorials, but they’re almost all for GLSL or Unity, using a different language and a different engine. You look at the official Bevy examples, but they seem to assume you already know how shaders work. You’re stuck in a frustrating gap: you know the engine, you know the language, but you don’t know how to bridge the two to speak directly to the GPU.</p><p><strong>I created this series because I was that developer.</strong></p><p>This is not a theoretical textbook or a high-level overview. It is the practical, step-by-step guide I wish I had when I was starting. It’s the result of systematically navigating that gap, figuring out the fundamentals, hitting the common pitfalls, and documenting what finally made the concepts “click.”</p><p>My goal is to provide a clear, linear path that takes you from the absolute basics of the graphics pipeline all the way to advanced techniques, with every single concept explained and demonstrated inside a working Bevy project. This is the journey of learning how to think in shaders, and I’m thrilled to share it with you.</p><h2 id="our-approach-a-practical-incremental-journey">Our Approach: A Practical, Incremental Journey</h2>
<p>This is a <strong>practical, hands-on series</strong>. We will learn by building, not just by reading. Every single article is built around a working Bevy project that you can run, modify, and experiment with. Our philosophy is that you don’t truly understand a concept until you’ve seen it work, broken it, and fixed it again.</p><p>Our journey is structured to build your knowledge from the ground up, ensuring you have a solid foundation before moving on to more complex topics. Here’s the path we’ll take:</p><ol>
<li><p><strong>First, we’ll build the foundation.</strong> We will demystify the <strong>Graphics Pipeline</strong> and learn the fundamental “alphabet” of WGSL - its data types, variables, and functions. You’ll understand where your code runs and the language it speaks.</p></li>
<li><p><strong>Then, we’ll take control of geometry.</strong> We’ll dive deep into the <strong>Vertex Shader</strong>, where you will learn to manipulate the very shape of your 3D models. You’ll create waving flags, rippling water, and fields of animated grass, learning how to breathe life into static meshes.</p></li>
<li><p><strong>Next, we’ll learn to paint those shapes with light and color.</strong> We’ll master the <strong>Fragment Shader</strong>, moving beyond simple colors to create procedural patterns, sample textures, and implement our own lighting models. This is where you’ll define the unique visual identity of your projects.</p></li>
<li><p><strong>Finally, we’ll explore the advanced frontier.</strong> With the fundamentals in place, we’ll unlock the true power of the GPU, exploring post-processing effects, compute shaders, performance optimization, and how to achieve specific artistic styles.</p></li>
</ol>
<p>By the end of this series, you won’t just know how to copy and paste shader code - you will have the confidence and the deep understanding to create your own custom rendering effects from scratch.</p><h2 id="who-this-series-is-for-and-what-youll-need">Who This Series Is For (And What You’ll Need)</h2>
<p>This series is designed for the curious Bevy developer who is ready to take the next step in their creative journey. If you’re comfortable with the basics of Rust and Bevy but feel like the GPU is still a “black box,” you’re in the perfect place.</p><h3 id="the-prerequisites">The Prerequisites</h3>
<p>This is not a “from zero” programming course. We’ll be moving at a steady pace, and I’ll assume you have a solid footing in the following areas:</p><ul>
<li><p><strong>A Good Grasp of Rust:</strong> You don’t need to be a systems-level expert, but you should be comfortable with core concepts like structs, traits, ownership, and the module system.</p></li>
<li><p><strong>Bevy Fundamentals:</strong> You should have worked through the official Bevy book or built a small project. You know what Components, Systems, and Resources are, and you feel comfortable setting up a basic scene.</p></li>
<li><p><strong>Basic Vector Math Intuition:</strong> You don’t need a math degree, but you should know what a vector is (<code>Vec3</code>) and have a general idea of what operations like adding, subtracting, or normalizing them mean. We’ll review the more complex math (like dot products and matrices) as we need it, focusing on intuition over raw proofs.</p></li>
</ul>
<h3 id="what-you-dont-need">What You Don’t Need</h3>
<p>This is just as important. You <strong>do not</strong> need:</p><ul>
<li>Any prior shader programming experience (that’s what we’re here to learn!).</li>
<li>A deep background in low-level graphics APIs like OpenGL, Vulkan, or DirectX.</li>
<li>To be a math wizard. A willingness to engage with the concepts is far more important than a formal education in linear algebra.</li>
</ul>
<p>Our goal is to build up your knowledge from first principles, right here in the Bevy ecosystem.</p><h2 id="setting-up-your-development-playground">Setting Up Your Development Playground</h2>
<p>A fast, smooth iteration loop is the secret to enjoying shader development. You want to be able to make a small change to your shader code and see the result instantly, without fighting with long compile times. Let’s create a Bevy project specifically configured for this rapid, creative workflow.</p><h3 id="recommended-tools">Recommended Tools</h3>
<p>While you can use any text editor, this series is written with a specific, highly effective setup in mind:</p><ul>
<li><ul>
<li><strong>Editor</strong>: <strong>Visual Studio Code (VS Code)</strong> is strongly recommended. Its rust-analyzer extension provides top-tier support for Rust, and there are excellent extensions that add syntax highlighting for WGSL, making your shader code much easier to read.</li>
</ul>
</li>
<li><p><strong>Graphics Debugger (Optional but Powerful)</strong>: For advanced debugging, a dedicated tool that can capture and inspect a single frame is invaluable. We won’t need this for the early articles, but knowing it exists is important.</p><ul>
<li><strong>Windows / Linux</strong>: <strong>RenderDoc</strong> is the open-source industry standard.</li>
<li><strong>macOS</strong>: Apple’s <strong>Metal GPU Debugger and Frame Capture</strong>, which is built directly into <strong>Xcode</strong>, is the essential tool for debugging Metal applications.</li>
</ul>
</li>
</ul>
<h3 id="step-1-install-the-essentials">Step 1: Install the Essentials</h3>
<p>First, ensure you have the Rust toolchain installed. If you’re already a Rust developer, you can likely skip this.</p><pre><code class="language-bash"># Install Rust if you don&#39;t have it
curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<h3 id="step-2-create-the-project-and-configure-cargotoml">Step 2: Create the Project and Configure <code>Cargo.toml</code></h3>
<p>Let’s create a new Bevy project that will be our home for this entire series.</p><pre><code class="language-bash">mkdir bevy-shader-journey
cd bevy-shader-journey
cargo init
</code></pre>
<p>Now, replace the contents of your <code>Cargo.toml</code> file with the following configuration. We’re adding a few key dependencies and settings to optimize our development experience.</p><pre><code class="language-toml">[package]
name = &quot;bevy-shader-journey&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot; # Sticking with the 2021 edition for maximum compatibility

[dependencies]
# The core Bevy engine, version 0.16
bevy = { version = &quot;0.16&quot;, features = [&quot;file_watcher&quot;] }
# For faster compile times in debug builds, you can enable this feature.
# It doesn&#39;t work on Windows though :(
# bevy = { version = &quot;0.16&quot;, features = [&quot;dynamic_linking&quot;, &quot;file_watcher&quot;] }

# Interactive demo selection - makes it easy to jump between examples
inquire = &quot;0.7&quot;

# An incredibly useful debugging tool we&#39;ll use in later articles
# to tweak shader values in real-time.
bevy-inspector-egui = &quot;0.23&quot;

# This section makes our local code compile faster (opt-level = 1)
# while keeping our dependencies fully optimized (opt-level = 3).
# It&#39;s a great trick for improving Bevy&#39;s debug build times.
[profile.dev]
opt-level = 1

[profile.dev.package.&quot;*&quot;]
opt-level = 3
</code></pre>
<h3 id="step-3-create-the-project-directory-structure">Step 3: Create the Project Directory Structure</h3>
<p>A good project organization will make life much easier as we add more examples. Create the necessary directories and files with this command:</p><pre><code class="language-bash">mkdir -p assets/shaders src/demos src/materials

# Create the module files
touch src/demos/mod.rs
touch src/materials/mod.rs
</code></pre>
<p>This gives us:</p><ul>
<li><code>assets/shaders/</code>: Where all our <code>.wgsl</code> shader files will live.</li>
<li><code>src/demos/</code>: Where each article’s interactive example will go.</li>
<li><code>src/materials/</code>: Where the Rust “glue” code for our custom materials will go.</li>
</ul>
<h3 id="step-4-set-up-the-demo-selection-system">Step 4: Set Up the Demo Selection System</h3>
<p>Here’s where things get interesting. Instead of creating separate example files or constantly commenting and uncommenting code, we’re going to build a smart demo selection system. This will let you easily run any example from the series with a simple command.</p><p>Replace the contents of <code>src/main.rs</code> with this code:</p><pre><code class="language-rust">mod demos;
mod materials;

use std::env;

struct Demo {
    number: &amp;&#39;static str,
    title: &amp;&#39;static str,
    run: fn(),
}

impl Demo {
    fn matches(&amp;self, query: &amp;str) -&gt; bool {
        let query_lower = query.to_lowercase();
        self.number.contains(&amp;query_lower) || self.title.to_lowercase().contains(&amp;query_lower)
    }

    fn display(&amp;self) -&gt; String {
        format!(&quot;{} - {}&quot;, self.number, self.title)
    }
}

fn main() {
    // Registry of all available demos
    let demos = vec![
        Demo {
            number: &quot;0.0&quot;,
            title: &quot;Basic Scene Setup&quot;,
            run: demos::basic_scene::run,
        },
        // More demos will be added as we progress through the series
    ];

    let args: Vec&lt;String&gt; = env::args().skip(1).collect();

    let demo = if args.is_empty() {
        select_demo_interactive(&amp;demos)
    } else {
        let query = args.join(&quot; &quot;);
        find_and_select_demo(&amp;demos, &amp;query)
    };

    match demo {
        Some(d) =&gt; {
            println!(&quot;\n🚀 Running: {}\n&quot;, d.display());
            (d.run)();
        }
        None =&gt; {
            println!(&quot;No demo selected. Exiting.&quot;);
            std::process::exit(0);
        }
    }
}

fn find_and_select_demo&lt;&#39;a&gt;(demos: &amp;&#39;a [Demo], query: &amp;str) -&gt; Option&lt;&amp;&#39;a Demo&gt; {
    let matches: Vec&lt;&amp;Demo&gt; = demos.iter().filter(|d| d.matches(query)).collect();

    match matches.len() {
        0 =&gt; {
            eprintln!(&quot;❌ No demos match &#39;{}&#39;\n&quot;, query);
            show_available_demos(demos);
            println!();
            select_demo_interactive(demos)
        }
        1 =&gt; Some(matches[0]),
        _ =&gt; {
            eprintln!(&quot;⚠️  Multiple demos match &#39;{}&#39;:\n&quot;, query);
            select_from_list(&amp;matches)
        }
    }
}

fn select_demo_interactive&lt;&#39;a&gt;(demos: &amp;&#39;a [Demo]) -&gt; Option&lt;&amp;&#39;a Demo&gt; {
    println!(&quot;Available demos:&quot;);
    show_available_demos(demos);
    println!();

    let demo_refs: Vec&lt;&amp;Demo&gt; = demos.iter().collect();
    select_from_list(&amp;demo_refs)
}

fn show_available_demos(demos: &amp;[Demo]) {
    for demo in demos {
        println!(&quot;  • {}&quot;, demo.display());
    }
}

fn select_from_list&lt;&#39;a&gt;(demos: &amp;[&amp;&#39;a Demo]) -&gt; Option&lt;&amp;&#39;a Demo&gt; {
    use inquire::Select;

    let options: Vec&lt;String&gt; = demos.iter().map(|d| d.display()).collect();
    let selected = Select::new(&quot;Select a demo to run:&quot;, options).prompt();

    match selected {
        Ok(selected_text) =&gt; demos.iter().find(|d| d.display() == selected_text).copied(),
        Err(_) =&gt; {
            println!(&quot;Selection cancelled.&quot;);
            None
        }
    }
}
</code></pre>
<p><strong>What does this do?</strong> This system lets you run any demo from the series with intuitive commands:</p><pre><code class="language-rust"># Run by article number
cargo run 1.1

# Run by partial title match
cargo run pipeline

# Multiple matches? You&#39;ll get an interactive menu with arrow keys
cargo run shader

# No arguments? See all available demos and select with arrow keys
cargo run
</code></pre>
<p>As you progress through the series, you’ll simply add new demos to the <code>demos</code> vector in <code>main.rs</code>, and they’ll automatically be available through this selection system. No managing multiple example files or hunting through code!</p><h3 id="step-5-create-your-first-demo-module">Step 5: Create Your First Demo Module</h3>
<p>Now let’s create the first demo that we registered in our system. Create <code>src/demos/basic_scene.rs</code>:</p><pre><code class="language-rust">use bevy::prelude::*;

pub fn run() {
    App::new()
        .add_plugins(DefaultPlugins.set(AssetPlugin {
            // Enable hot reloading
            watch_for_changes_override: Some(true),
            ..default()
        }))
        .add_systems(Startup, setup)
        .add_systems(Update, rotate_camera)
        .run();
}

fn setup(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;StandardMaterial&gt;&gt;,
) {
    // Add a simple scene we can apply our shaders to
    commands.spawn((
        Mesh3d(meshes.add(Cuboid::new(2.0, 2.0, 2.0))),
        MeshMaterial3d(materials.add(Color::srgb(0.8, 0.7, 0.6))),
    ));

    // Light
    commands.spawn((
        PointLight {
            shadows_enabled: true,
            ..default()
        },
        Transform::from_xyz(4.0, 8.0, 4.0),
    ));

    // Camera
    commands.spawn((
        Camera3d::default(),
        Transform::from_xyz(-2.5, 4.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y),
    ));
}

// Simple camera rotation to see our shaders from different angles
fn rotate_camera(time: Res&lt;Time&gt;, mut camera_query: Query&lt;&amp;mut Transform, With&lt;Camera3d&gt;&gt;) {
    for mut transform in camera_query.iter_mut() {
        let radius = 9.0;
        let angle = time.elapsed_secs() * 0.5;
        transform.translation.x = angle.cos() * radius;
        transform.translation.z = angle.sin() * radius;
        transform.look_at(Vec3::ZERO, Vec3::Y);
    }
}
</code></pre>
<p>And register it in <code>src/demos/mod.rs</code>:</p><pre><code class="language-rust">pub mod basic_scene;
</code></pre>
<p><strong>The pattern you’ll follow for every article:</strong></p><ol>
<li>Create a new module in <code>src/demos/</code> (e.g., <code>first_shader.rs</code>)</li>
<li>Implement a <code>pub fn run()</code> function that starts a Bevy app</li>
<li>Add the module to <code>src/demos/mod.rs</code></li>
<li>Register it in the <code>demos</code> vector in <code>main.rs</code></li>
</ol>
<p>That’s it! The demo selection system handles the rest.</p><h3 id="step-5-test-your-setup">Step 5: Test Your Setup</h3>
<p>You’re all set! Let’s make sure everything works:</p><p>bash</p><pre><code class="language-bash"># Run the basic scene demo directly
cargo run 0.0

# Or try the interactive selection
cargo run
</code></pre>
<p>You should see a simple scene with a rotating camera orbiting around a cube.</p><p><strong>Try experimenting with the selection system:</strong></p><pre><code class="language-bash">cargo run basic     # Matches &quot;Basic Scene Setup&quot;
cargo run scene     # Same result
cargo run xyz       # No match - shows all demos and lets you select
</code></pre>
<p><strong>Congratulations!</strong> You now have a robust development environment with:</p><ul>
<li>Fast iteration with hot-reloading for shader changes</li>
<li>An intuitive demo selection system for jumping between examples</li>
<li>A clean project structure that will scale as you learn</li>
</ul>
<p>When you save changes to a shader file in the <code>assets</code> directory, Bevy will automatically detect the change and reload it in real-time. This instant feedback is the key to learning and experimenting with shaders effectively.</p><h2 id="understanding-the-project-structure">Understanding the Project Structure</h2>
<p>Here’s how everything fits together:</p><pre><code class="language-plaintext">bevy-shader-journey/
├── assets/
│   └── shaders/              # Your .wgsl shader files
│       └── first_shader.wgsl # (We&#39;ll create these as we go)
├── src/
│   ├── main.rs               # Demo selection system
│   ├── demos/                # One module per article
│   │   ├── mod.rs
│   │   ├── basic_scene.rs    # Article 0.0
│   │   └── first_shader.rs   # (Article 1.1, etc.)
│   └── materials/            # Custom material definitions
│       └── mod.rs
└── Cargo.toml
</code></pre>
<p><strong>The workflow:</strong></p><ol>
<li>Read an article to understand the concepts</li>
<li>Run the demo: <code>cargo run [article-number]</code></li>
<li>Look at the code in <code>src/demos/[name].rs</code></li>
<li>Examine the shader in <code>assets/shaders/[name].wgsl</code></li>
<li>Experiment - change values, break things, see what happens!</li>
<li>Move to the next article when ready</li>
</ol>
<h2 id="a-mindset-for-success">A Mindset for Success</h2>
<p>You are now ready to begin. As you dive into the world of shaders, keeping a few practical tips in mind will make the learning process smoother and more enjoyable.</p><ul>
<li><strong>Start Simple, Then Iterate.</strong> The golden rule of shader development. Always begin with the absolute most basic version of an effect that works, even if it’s just a solid color. Once you have a working baseline, add complexity one small step at a time. This makes debugging infinitely easier.</li>
<li><strong>Embrace the Visual Debugging Loop.</strong> Your primary debugging tool is the screen itself. Is the effect too bright? Multiply by 0.5. Is it upside down? Multiply a coordinate by <code>-1.0</code>. Get comfortable making small, incremental changes and immediately observing the visual result.</li>
<li><strong>Use Descriptive Variable Names.</strong> Shaders can quickly become a maze of vector math. A variable named <code>surfaceToLightDirection</code> is a thousand times clearer than <code>vecL</code>. Your future self, trying to debug the code, will thank you.</li>
<li><strong>Save Your Progress Frequently.</strong> Shader development is highly experimental. You’ll often go down a path that leads to a visual mess. Using a version control system like Git to commit frequently after each small success will give you the freedom to experiment without fear of losing your working code.</li>
<li><strong>Jump Between Examples Freely.</strong> One of the beauties of our demo selection system is that you can easily revisit previous techniques. Forgot how normal mapping works? Just <code>cargo run normal</code> and refresh your memory. Want to compare two approaches? Run them side by side!</li>
</ul>
<h2 id="lets-get-started">Let’s Get Started!</h2>
<p>Your development environment is configured, your mindset is right, and the path is laid out before you. That blank <code>.wgsl</code> file is no longer an intimidating obstacle - it’s a canvas waiting for your creativity.</p><p>The demo selection system gives you the freedom to explore at your own pace, jumping between concepts and building your understanding incrementally. Each article in this series adds a new demo to your toolkit, and by the end, you’ll have a comprehensive library of shader techniques at your fingertips.</p><p>It’s time to dive in and learn how to speak directly to the GPU.</p><p>Next up: [1.1 - Understanding the Graphics Pipeline]</p><hr>
<h2 id="quick-reference">Quick Reference</h2>
<p><strong>Running Demos:</strong></p><pre><code class="language-bash">cargo run 1.1              # By article number
cargo run pipeline         # By keyword
cargo run                  # Interactive selection
</code></pre>
<p><strong>Project Structure:</strong></p><ul>
<li><code>src/main.rs</code> - Demo selection system</li>
<li><code>src/demos/</code> - One module per article (each exports <code>pub fn run()</code>)</li>
<li><code>src/materials/</code> - Custom material definitions</li>
<li><code>assets/shaders/</code> - WGSL shader files</li>
</ul>
<p><strong>Development Tips:</strong></p><ul>
<li>Save a shader file → Bevy auto-reloads it</li>
<li>Small changes → Immediate visual feedback</li>
<li>Commit working code frequently</li>
<li>Use descriptive names in shader code</li>
</ul>

            ]]>
        </content>
    </entry>
</feed>
