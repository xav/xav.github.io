<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>Hexbee&#x27;s Dev Journal</title>
    <link href="https://xav.github.io/feed.xml" rel="self" />
    <link href="https://xav.github.io" />
    <updated>2025-12-13T19:29:46+01:00</updated>
    <author>
        <name>Xavier Basty Kjellberg</name>
    </author>
    <id>https://xav.github.io</id>

    <entry>
        <title>1.2 - WGSL Fundamentals - Data Types &amp; Variables</title>
        <author>
            <name>Xavier Basty Kjellberg</name>
        </author>
        <link href="https://xav.github.io/12-wgsl-fundamentals-data-types-and-variables/"/>
        <id>https://xav.github.io/12-wgsl-fundamentals-data-types-and-variables/</id>
            <category term="wgsl"/>
            <category term="shaders"/>
            <category term="rust"/>
            <category term="bevy"/>

        <updated>2025-12-13T19:27:36+01:00</updated>
            <summary type="html">
                <![CDATA[
                    ## What We're Learning In our last article, we built a mental model of the graphics pipeline: a VFX studio where "Layout Artists" (Vertex Shaders)&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                
  <p>
    ## What We're Learning<br><br>In our last article, we built a mental model of the graphics pipeline: a VFX studio where "Layout Artists" (Vertex Shaders) position geometry and "Coloring Artists" (Fragment Shaders) paint the final pixels. But what materials do these artists work with? How do we hand them a 3D coordinate to transform, a surface direction for lighting, or a final color to paint? How do we describe the data that flows through their assembly line?<br><br>This is where WGSL's data types come in. These aren't generic programming types; they are the fundamental vocabulary of the GPU - the digital clay, paint, and transformation tools our artists use to build a visual world. Learning them is like learning the alphabet before you can write a story.<br><br>At the lowest level, we have&nbsp;**scalar**&nbsp;types - the individual numbers that form the atoms of our data. But the real power comes from combining these into&nbsp;**vectors**, the workhorse of every shader, representing everything from a&nbsp;`vec3<f32>`&nbsp;position to a&nbsp;`vec4<f32>`&nbsp;RGBA color. And to manipulate these vectors - to move, rotate, and project them - we use&nbsp;**matrices**, the mathematical machines of transformation.<br><br>By the end of this article, you'll understand:<br><br>- The atomic building blocks of all shader data:&nbsp;`f32`,&nbsp;`i32`,&nbsp;`u32`, and&nbsp;`bool`.<br>- The workhorse of all shaders: how&nbsp;**vectors**&nbsp;(`vec2`,&nbsp;`vec3`,&nbsp;`vec4`) represent everything from 3D positions to RGBA colors.<br>- The language of transformation: how&nbsp;**matrices**&nbsp;(`mat4x4`) are the machines that move, rotate, and scale your geometry.<br>- The crucial difference between an immutable&nbsp;`let`&nbsp;(a constant) and a mutable&nbsp;`var`&nbsp;(a variable), and why you should almost always prefer&nbsp;`let`.<br>- Powerful GPU-native shortcuts like&nbsp;**constructors**&nbsp;for building vectors and&nbsp;**swizzling**&nbsp;for efficiently accessing and rearranging their components.<br><br>## Scalar Types: The Basics<br><br>At the heart of all shader calculations are&nbsp;**scalar**&nbsp;types. A scalar is simply a single value, like one number or a boolean state. WGSL provides four fundamental scalar types that serve as the atoms for all the more complex data we will build.<br><br>### Floating-Point Numbers:&nbsp;`f32`<br><br>This is the single most important type in WGSL and your absolute workhorse for graphics programming. It represents a 32-bit floating-point number, which is essential for describing any data that is continuous and requires precision.<br><br>```wgsl<br>let pi: f32 = 3.14159;<br>let half: f32 = 0.5;<br>let negative_one_point_five: f32 = -1.5;<br>```<br><br>**Key Rule:**&nbsp;WGSL is very strict about types. A number literal without a decimal point is treated as an integer. To create an&nbsp;`f32`, you&nbsp;**must**&nbsp;include a decimal point, even for whole numbers.<br><br>```wgsl<br>let correct_float: f32 = 1.0; // ✓ Correct, this is a float.<br>let wrong: f32 = 1;           // ✗ COMPILE ERROR: Cannot assign an integer to an f32.<br>```<br><br>You will use&nbsp;`f32`&nbsp;for almost everything, including:<br><br>- Positions (X, Y, Z coordinates)<br>- Colors (R, G, B channels)<br>- Texture Coordinates (U, V)<br>- Time, opacity, and any fractional value<br><br>### Signed Integers:&nbsp;`i32`<br><br>This is a standard 32-bit signed integer, meaning it can represent both positive and negative whole numbers.<br><br>```wgsl<br>let count: i32 = 42;<br>let negative_ten: i32 = -10;<br>let zero: i32 = 0;<br>```<br><br>Use `i32` when you need whole numbers and the possibility of a negative value is meaningful, such as for:<br><br>- Loop counters that might count down<br>- Calculations involving differences or offsets<br>- Bitwise operations<br><br>### Unsigned Integers: `u32`<br><br>This is a 32-bit unsigned integer, meaning it can only represent non-negative whole numbers (zero and positive values).<br><br>```wgsl<br>let index: u32 = 0u;<br>let size: u32 = 256u;<br>```<br><br>**Key Rule:**&nbsp;To distinguish an unsigned integer literal from a signed one, you&nbsp;**must**&nbsp;add a&nbsp;`u`&nbsp;suffix.<br><br>Use&nbsp;u32&nbsp;when a value can never logically be negative. This is both a safety feature and a way to signal intent. Common uses include:<br><br>- Array indices and lengths<br>- Bevy's&nbsp;`@builtin(instance_index)`<br>- Identifiers or flags packed into an integer<br><br>### Booleans:&nbsp;`bool`<br><br>The&nbsp;`bool`&nbsp;type represents a simple&nbsp;`true`&nbsp;or&nbsp;`false`&nbsp;value.<br><br>```wgsl<br>let is_visible: bool = true;<br>let has_texture: bool = false;<br>```<br><br>Booleans are the foundation of all logic and control flow in your shaders. You'll use them for:<br><br>- `if/else`&nbsp;statements and other conditional logic<br>- Storing the result of a comparison (e.g.,&nbsp;`let is_close = distance &lt; 1.0;`)<br>- Flags passed in from your Rust code to enable or disable shader features<br><br>## Vector Types: Your New Best Friends<br><br>If scalars are the atoms of our data,&nbsp;**vectors**&nbsp;are the molecules. They are the heart and soul of shader programming. A vector is an ordered collection of scalars, but in graphics, it's a powerful tool for representing multi-dimensional data like positions, colors, and directions.<br><br>The GPU is a parallel processing beast. It is specifically designed to perform the same mathematical operation on large batches of data all at once. Vectors are the native language of this architecture. When you add two&nbsp;`vec3`&nbsp;values together, the GPU can perform all three additions (x+x, y+y, z+z) simultaneously. Using vectors effectively is the key to unlocking the GPU's performance and writing elegant shader code.<br><br>### Vector Syntax<br><br>WGSL defines vectors with a simple, clear syntax:&nbsp;`vecN<t>`, where&nbsp;`N`&nbsp;is the number of components (2, 3, or 4) and&nbsp;`T`&nbsp;is the scalar type of those components. While you can create vectors of any scalar type, floating-point vectors are used in over 99% of graphics operations.<br><br>| Type        | Common Usage                                                                                                                                  |<br>| ----------- | --------------------------------------------------------------------------------------------------------------------------------------------- |<br>| `vec2<f32>` | 2D positions, and especially texture coordinates (UVs).                                                                                       |<br>| `vec3<f32>` | The workhorse for 3D graphics: 3D positions, RGB colors, surface normals, direction vectors.                                                  |<br>| `vec4<f32>` | RGBA colors (with an alpha channel for transparency) and homogeneous coordinates, such as the final clip-space position from a vertex shader. |<br>| `vec2<i32>` | Less common, but useful for things like integer grid coordinates or texture dimensions in pixels.                                             |<br><br>### Creating Vectors (Constructors)<br><br>WGSL provides a flexible set of "constructors" to build vectors in whatever way is most convenient. This lets you write clean, readable code without needing to manually handle every single component.<br><br>```wgsl<br>// 1. From individual scalar components: The most direct method.<br>let pos = vec3<f32>(1.0, 2.0, 3.0);<br>let red = vec4<f32>(1.0, 0.0, 0.0, 1.0); // Red with full alpha<br><br>// 2. From a single value (a "splat"): A useful shortcut.<br>// This creates a vector where all components have the same value.<br>let gray = vec3<f32>(0.5); // Equivalent to vec3<f32>(0.5, 0.5, 0.5)<br><br>// 3. Combining smaller vectors and scalars: Extremely common and powerful.<br>// The components are simply concatenated in order to form the new vector.<br>let xy = vec2<f32>(1.0, 2.0);<br>let xyz = vec3<f32>(xy, 3.0);       // -&gt; Creates vec3(1.0, 2.0, 3.0)<br>let xyzw = vec4<f32>(xy, 3.0, 4.0); // -&gt; Creates vec4(1.0, 2.0, 3.0, 4.0)<br><br>// 4. From another vector and a scalar: The classic way to add a dimension.<br>// A common example is adding an alpha channel to an existing RGB color.<br>let rgb_color = vec3<f32>(1.0, 0.5, 0.0); // An orange color<br>let rgba_color = vec4<f32>(rgb_color, 1.0); // -&gt; Creates vec4(1.0, 0.5, 0.0, 1.0)<br>```<br><br>### Accessing Vector Components<br><br>To work with vectors, you need to access their individual components. WGSL gives you several accessor "schemes" which are aliases for each other. Using the right scheme is a best practice that makes your code much more readable by signaling your intent.<br><br>```wgsl<br>let my_vector = vec4<f32>(1.0, 0.5, 0.0, 1.0);<br><br>// The "spatial" or "geometric" scheme: x, y, z, w<br>// Use this when the vector represents a position, direction, or texture coordinate.<br>let x_pos = my_vector.x; // 1.0<br><br>// The "color" scheme: r, g, b, a<br>// Use this when the vector represents a color. This makes the code self-documenting.<br>let green_channel = my_vector.g; // 0.5<br><br>// By index (0-based array-style access)<br>// This is less common for direct access but is useful for programmatic access,<br>// for instance, if you were iterating through a vector's components in a loop.<br>let first_component = my_vector[0]; // 1.0<br>```<br><br>### Vector Swizzling: A GPU Superpower<br><br>"Swizzling" is a powerful and highly efficient GPU feature that lets you create a&nbsp;new&nbsp;vector by rearranging, duplicating, or selecting components from an existing vector. It's not just a syntax shortcut; it compiles to a single, incredibly fast hardware instruction.<br><br>```wgsl<br>let color = vec4<f32>(1.0, 0.5, 0.0, 1.0); // A bright orange color<br><br>// 1. Extract a subset of components<br>// A very common use is to get the RGB part of an RGBA color.<br>let rgb = color.rgb; // -&gt; Creates a new vec3<f32> with (1.0, 0.5, 0.0)<br>let rg = color.rg;   // -&gt; Creates a new vec2<f32> with (1.0, 0.5)<br><br>// 2. Reorder components<br>// Useful for converting between different data layouts (e.g., from an image format).<br>let bgr = color.bgr; // -&gt; Creates vec3(0.0, 0.5, 1.0). The components are reversed!<br><br>// 3. Duplicate components<br>// A great way to create grayscale values or fill a vector from a single channel.<br>let grayscale_from_red = color.rrr; // -&gt; Creates vec3(1.0, 1.0, 1.0)<br><br>// 4. Mix and match to build new vectors<br>// This is where swizzling shines for geometric operations.<br>let pos = vec3<f32>(1.0, 2.0, 3.0);<br>let yxz = pos.yxz; // -&gt; Creates vec3(2.0, 1.0, 3.0)<br><br>// A classic use case: using the X and Z components of a 3D position<br>// for 2D calculations, like looking up a texture for a ground plane.<br>let ground_coords = pos.xz; // -&gt; Creates vec2(1.0, 3.0)<br>```<br><br>You can use the accessor schemes&nbsp;`xyzw`,&nbsp;`rgba`, or&nbsp;`stpq`&nbsp;(a convention for texture coordinates) for swizzling. They all access the same underlying components (0, 1, 2, 3), but you&nbsp;**cannot mix schemes**&nbsp;in a single swizzle (e.g.,&nbsp;`color.xb`&nbsp;is illegal).<br><br>### Vector Arithmetic<br><br>Arithmetic operations on vectors are performed&nbsp;**component-wise**. This means the operation is applied independently to each pair of corresponding components. This is a fundamental concept for everything from blending colors to manipulating positions.<br><br>```wgsl<br>let a = vec3<f32>(1.0, 2.0, 3.0);<br>let b = vec3<f32>(4.0, 5.0, 6.0);<br><br>// Addition: result.x = a.x + b.x, result.y = a.y + b.y, etc.<br>// Use case: Combining light sources, offsetting a position.<br>let sum = a + b; // -&gt; Result: vec3(5.0, 7.0, 9.0)<br><br>// Subtraction: result.x = a.x - b.x, etc.<br>// Use case: Finding the direction vector from point A to point B (B - A).<br>let diff = b - a; // -&gt; Result: vec3(3.0, 3.0, 3.0)<br><br>// Multiplication (component-wise!): result.x = a.x * b.x, etc.<br>// Use case: Tinting. Multiplying a base color by a texture color.<br>let product = a * b; // -&gt; Result: vec3(4.0, 10.0, 18.0)<br><br>// Operations with a scalar: The scalar is applied to every component.<br>// Use case: Uniform scaling an object or changing the brightness of a color.<br>let scaled_up = a * 2.0;   // -&gt; Result: vec3(2.0, 4.0, 6.0)<br>let scaled_down = b / 2.0; // -&gt; Result: vec3(2.0, 2.5, 3.0)<br>```<br><br>**CRITICAL:**&nbsp;Standard vector multiplication (`*`) is&nbsp;**component-wise multiplication**, often called the [Hadamard product](https://en.wikipedia.org/wiki/Hadamard_product_\(matrices\)). It is&nbsp;**NOT**&nbsp;a dot product or a cross product! WGSL provides separate built-in functions (`dot()`,&nbsp;`cross()`) for those, which we will cover in a later article. This is one of the most common points of confusion for beginners.<br><br>## Matrix Types: For Transformations<br><br>If vectors represent points and directions, then a&nbsp;**matrix**&nbsp;is the machine that transforms them. Matrices are the mathematical tool we use to perform all the essential 3D operations we discussed in the graphics pipeline: moving (translation), rotating, and scaling objects. They are the engine that powers the journey of a vertex through different coordinate spaces.<br><br>A matrix is a grid of numbers arranged in columns and rows. In WGSL, the syntax is&nbsp;`matCxR<t>`, where&nbsp;`C`&nbsp;is the number of columns,&nbsp;`R`&nbsp;is the number of rows, and&nbsp;`T`&nbsp;is the scalar type (almost always&nbsp;`f32`).<br><br>### Common Matrix Types<br><br>While various sizes exist, you will primarily work with&nbsp;`mat4x4<f32>`&nbsp;in 3D graphics.<br><br>| Type          | Common Usage                                                                                                                                                                                       |<br>| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |<br>| `mat4x4<f32>` | The cornerstone of 3D graphics. A single 4x4 matrix can store a combination of translation, rotation, and scale for a 3D object. Bevy's Model, View, and Projection matrices are all of this type. |<br>| `mat3x3<f32>` | Often used for transforming 3D direction vectors like normals, where translation information should be ignored.                                                                                    |<br>| `mat2x2<f32>` | Used for 2D transformations, for example, rotating or scaling UV coordinates in a fragment shader.                                                                                                 |<br><br>In your Bevy shaders, you'll mostly receive&nbsp;`mat4x4<f32>`&nbsp;matrices from the engine and use them to transform your vertex positions.<br><br>### Creating Matrices and Column-Major Order<br><br>You will rarely build transformation matrices from scratch inside a shader - Bevy's&nbsp;`Transform`&nbsp;component does that complex work for you on the CPU. However, it's crucial to understand how they are constructed. The constructor takes the values for each&nbsp;**column**, one after the other.<br><br>**Key Concept:**&nbsp;WGSL matrices, like those in most modern graphics APIs, are&nbsp;**column-major**. This defines how the numbers you provide are stored in memory. It means you provide all the data for the first column, then all for the second, and so on.<br><br>Think of it as filling the matrix grid vertically, one column at a time:<br><br>```wgsl<br>// A 4x4 identity matrix (which represents "no transformation").<br>let identity = mat4x4<f32>(<br>//  Col 0     Col 1     Col 2     Col 3<br>    1.0, 0.0, 0.0, 0.0,  // Row 0<br>    0.0, 1.0, 0.0, 0.0,  // Row 1<br>    0.0, 0.0, 1.0, 0.0,  // Row 2<br>    0.0, 0.0, 0.0, 1.0   // Row 3<br>);<br><br>// This is wrong! The constructor takes columns, not rows.<br>// let wrong = mat4x4<f32>(row0, row1, row2, row3); // ✗<br><br>// You can also construct a matrix from column vectors. This is often clearer.<br>let col0 = vec4<f32>(1.0, 0.0, 0.0, 0.0);<br>let col1 = vec4<f32>(0.0, 1.0, 0.0, 0.0);<br>let col2 = vec4<f32>(0.0, 0.0, 1.0, 0.0);<br>let col3 = vec4<f32>(0.0, 0.0, 0.0, 1.0);<br>let from_vectors = mat4x4<f32>(col0, col1, col2, col3);<br>```<br><br>### Accessing Matrix Elements<br><br>Accessing matrix data follows this column-major logic. The most important rule to remember is: **column-first, then row**.<br><br>```wgsl<br>let m = ... // some mat4x4<f32><br><br>// Get an entire column as a vector<br>let second_column: vec4<f32> = m[1]; // Index 1 gives you the second column.<br><br>// Access a specific element: matrix[column_index][row_index]<br>let element_c1_r2 = m[1][2]; // Get the element in Column 1, Row 2.<br>```<br><br>### The Magic: Matrix-Vector Multiplication<br><br>The real power of a matrix is revealed when you multiply it by a vector. This operation&nbsp;**applies the transformation**&nbsp;stored in the matrix to the vector, producing a new, transformed vector.<br><br>This is&nbsp;**NOT**&nbsp;component-wise multiplication! It's a special mathematical operation that correctly rotates, scales, and translates the vector. We will dive deep into the math in a later article. For now, just focus on the syntax and the result.<br><br>```wgsl<br>// Conceptual vertex shader code<br>// These matrices are provided by Bevy's renderer.<br>let model_matrix: mat4x4<f32> = ...;<br>let view_matrix: mat4x4<f32> = ...;<br>let projection_matrix: mat4x4<f32> = ...;<br><br>// The original vertex position from the mesh.<br>// We use a vec4 with w=1.0 for positions so that translation works correctly.<br>let local_position = vec4<f32>(1.0, 2.0, 3.0, 1.0);<br><br>// Apply the transformations in sequence.<br>// Note the order: Projection * View * Model * Position<br>let world_position = model_matrix * local_position;<br>let view_position = view_matrix * world_position;<br>let clip_position = projection_matrix * view_position;<br>```<br><br>This sequence of multiplications is the absolute core of every 3D vertex shader. It's the code that executes the "Coordinate Space Journey" we learned about previously, taking a vertex from its local blueprint all the way to its final place on the screen.<br><br>## Variables:&nbsp;`var`&nbsp;vs&nbsp;`let`<br><br>WGSL provides two keywords for declaring a named value:&nbsp;`let`&nbsp;and&nbsp;var`.` The choice between them is one of the most important you'll make, as it signals your intent and has major consequences for safety and performance. The core difference is&nbsp;**mutability**: can the value change after it's been declared?<br><br>### `let`: Immutable Constants<br><br>The&nbsp;`let`&nbsp;keyword declares a&nbsp;**runtime constant**. Once you assign a value to a&nbsp;`let`&nbsp;binding, it is frozen and&nbsp;**cannot be changed**&nbsp;for the rest of its scope. You should think of it as a named placeholder for a fixed value.<br><br>```wgsl<br>let pi = 3.14159;<br>let base_color = vec3<f32>(1.0, 0.5, 0.2); // An orange color<br><br>// The following lines would cause a compilation error:<br>// pi = 3.14;                 // ✗ ERROR: Cannot reassign a `let` constant.<br>// base_color.r = 0.8;        // ✗ ERROR: Cannot modify a component of a `let` constant.<br>```<br><br>#### Why You Should Prefer&nbsp;`let`<br><br>As a best practice,&nbsp;**you should use&nbsp;`let`&nbsp;for every value you declare by default**.&nbsp;This habit makes your code safer, more readable, and often more performant.<br><br>1. **Safety and Readability**: When you see&nbsp;let, you have a guarantee that the value will never change within that part of the code. This makes shaders much easier to read and reason about, as you don't need to track potential modifications. It prevents a whole class of bugs caused by accidental reassignment.<br>2. **Performance and Optimization**: Declaring a value as immutable gives the shader compiler critical information. The compiler&nbsp;knows&nbsp;the value is constant, which allows for powerful optimizations. It might perform calculations at compile time ("constant folding"), store the value more efficiently in a register, or remove entire branches of code. In a highly parallel environment like a GPU, working with immutable data is fundamentally more efficient.<br><br>### `var`: Mutable Variables<br><br>For situations where a value&nbsp;must&nbsp;change after it has been declared, WGSL provides the&nbsp;var&nbsp;keyword. This declares a&nbsp;**mutable variable**, the traditional variable type you might be used to from other languages. Its value can be changed at any time.<br><br>```wgsl<br>// Declare a mutable variable for a counter<br>var counter = 0;<br>counter = counter + 1; // ✓ This is perfectly valid.<br><br>// Declare a mutable color to be modified<br>var color = vec3<f32>(1.0, 0.0, 0.0);<br>color.r = 0.5; // Modify the red component<br>color.gb = vec2<f32>(0.2, 0.8); // Modify the green and blue components with a swizzle<br>```<br><br>#### When to Use&nbsp;`var`<br><br>You should only resort to using&nbsp;`var`&nbsp;when immutability is not an option. Legitimate scenarios include:<br><br>- **Accumulators**: When you are summing up values in a loop, such as calculating the total light contribution from multiple light sources.<br><br>```wgsl<br>var total_light = vec3<f32>(0.0);<br>for (var i = 0; i &lt; 4; i = i + 1) {<br>    total_light = total_light + calculate_light_contribution(i);<br>}<br>```<br><br>- **Loop Counters**: The counter in a&nbsp;for&nbsp;loop must be a&nbsp;`var`.<br>- **Step-by-Step Modification**: When you start with a base value and apply a series of complex, conditional modifications to it.<br><br>```wgsl<br>var final_color = texture_color;<br>if (is_in_shadow) {<br>    final_color = final_color * 0.5;<br>}<br>final_color = apply_fog(final_color, distance);<br>```<br><br>Even in this case, it's often possible (and clearer) to rewrite the logic using `let` for each stage, as it forces a more explicit data flow.<br><br>### Type Inference<br><br>WGSL's compiler is smart and can often infer a variable's type from the value you assign to it.<br><br>```wgsl<br>let x = 1.0;                    // Inferred as f32<br>let pos = vec3(1.0, 2.0, 3.0);  // Components are f32, so inferred as vec3<f32><br>let count = 0;                  // Inferred as i32<br>let flag = true;                // Inferred as bool<br>```<br><br>Technically, number literals like&nbsp;`1`&nbsp;or&nbsp;`1.0`&nbsp;start as "abstract" integers or floats. The compiler gives them a concrete type (`i32`,&nbsp;`f32`, etc.) the first time they are used in a context that requires one. For&nbsp;`let count = 0;`, the default concrete type for an abstract integer is&nbsp;`i32`. This is why type inference works so smoothly.<br><br>While inference is convenient, being explicit about types can sometimes make your code clearer and prevent subtle bugs, especially when you intend to use a less common type like&nbsp;`u32`.<br><br>```wgsl<br>// Explicit types for clarity<br>let x: f32 = 1.0;<br>let pos: vec3<f32> = vec3(1.0, 2.0, 3.0);<br>let frame_index: u32 = 0u; // Explicitly an unsigned integer<br>```<br><br>## Putting It All Together: A Common Workflow<br><br>We've learned about scalars, vectors, and the&nbsp;let&nbsp;keyword as separate concepts. Now, let's put them all together. The following snippet demonstrates a common and powerful workflow you'll use constantly in your shaders: starting with base values and creating new ones in a series of clear, immutable steps.<br><br>This isn't a runnable demo, but rather a perfect illustration of how the pieces fit together to achieve a result.<br><br>```wgsl<br>@fragment<br>fn fragment(in: VertexOutput) -&gt; @location(0) vec4<f32> {<br>    // Step 1: Define our starting point with `let` and a vector constructor.<br>    // This base value itself won't change; we will create new constants based on it.<br>    let base_color = vec3<f32>(1.0, 0.5, 0.2);<br><br>    // Step 2: Adjust brightness with scalar-vector multiplication.<br>    // In a real shader, this could be a shadow calculation. We're just making<br>    // the base color 50% darker via component-wise multiplication.<br>    let darker_orange = base_color * 0.5;<br><br>    // Step 3: Blend with another color using vector arithmetic.<br>    // We create a final color that is 70% our `darker_orange` and 30% a<br>    // cool blue accent color. This is a manual linear interpolation.<br>    let accent_color = vec3<f32>(0.2, 0.3, 0.8);<br>    let blended_color = darker_orange * 0.7 + accent_color * 0.3;<br><br>    // Step 4: Construct the final `vec4` output.<br>    // The fragment shader must return an RGBA color. We construct this<br>    // by combining our final `vec3` result with a scalar `f32` for the alpha.<br>    let final_output = vec4<f32>(blended_color, 1.0);<br><br>    return final_output;<br>}<br>```<br><br>### Deconstructing the Process<br><br>This short example is a microcosm of everyday shader programming, demonstrating several key concepts in a practical flow:<br><br>1. **Immutability by Default**: We use&nbsp;`let`&nbsp;to define each stage of the color. This makes the code easy to follow - `base_color`&nbsp;is always the original orange,&nbsp;`darker_orange`&nbsp;is always the half-bright version, and so on. There are no surprise mutations, which makes the logic simple to debug.<br>2. **Vector as a Unit**: We treat&nbsp;`base_color`&nbsp;and&nbsp;`accent_color`&nbsp;as single entities, even though they contain three separate&nbsp;`f32`&nbsp;values. All our math (`*`&nbsp;and&nbsp;`+`) operates on them as a whole, which is clean and intuitive.<br>3. **Component-Wise Math in Action**: The multiplication&nbsp;`darker_orange * 0.7`&nbsp;isn't a dot product; it's a scaling of each color channel (R, G, and B) independently. This component-wise behavior is exactly what we need for tinting and blending colors.<br>4. **Vector Construction Flexibility**: We see two kinds of construction:&nbsp;`vec3<f32>(r, g, b)`&nbsp;to define the initial colors from scalars, and the powerful&nbsp;`vec4<f32>(vec3, a)`&nbsp;to compose the final output by combining an existing&nbsp;`vec3`&nbsp;with a new scalar alpha channel.<br><br>By following this pattern - starting with base values, applying a series of transformations and blends to create new&nbsp;`let`&nbsp;constants, and finally constructing the required output - you can build complex visual effects in a clean, readable, and performant way.<br><br>---<br><br>## Complete Example: Vector Operations Visualizer<br><br>Theory is essential, but seeing is believing. To make these abstract concepts concrete, we'll build a simple, interactive shader in Bevy. This shader won't create a realistic object; instead, it will act as a diagnostic tool, allowing us to "see" vector operations in real-time.<br><br>### Our Goal<br><br>We will create a custom material for a sphere that can cycle through five different visualization modes by pressing a key. Each mode will apply a different vector operation to the sphere's base color, visually demonstrating concepts like component access, swizzling, and arithmetic.<br><br>### What This Project Demonstrates<br><br>- **Component Access**: How to isolate and use a single component of a vector (e.g.,&nbsp;`.r`).<br>- **Swizzling**: The power of rearranging vector components on the fly (e.g.,&nbsp;`.bgr`).<br>- **Vector Arithmetic**: The visual result of component-wise addition and multiplication.<br>- **Vector Construction**: How to build new vectors by combining smaller vectors and scalars.<br>- **Bevy Integration**: The basic structure of a custom&nbsp;`Material`&nbsp;in Bevy 0.16 and how to pass data (our&nbsp;`demo_mode`) from Rust to a WGSL shader.<br><br>### The Shader (`assets/shaders/vector_demo.wgsl`)<br><br>This single WGSL file contains both our vertex and fragment shaders. The vertex shader is standard; it calculates the world position and normal for each vertex and passes them to the next stage.<br><br>The fragment shader is where the magic happens. It first calculates a&nbsp;`base`&nbsp;color from the interpolated world normal. Then, using an&nbsp;`if`&nbsp;chain, it checks the&nbsp;`material.demo_mode`&nbsp;uniform (sent from our Rust code) to decide which vector operation to perform, altering the final color of the pixel accordingly.<br><br>```wgsl<br>#import bevy_pbr::mesh_functions<br>#import bevy_pbr::view_transformations::position_world_to_clip<br>#import bevy_pbr::forward_io::VertexOutput<br><br>struct VectorDemoMaterial {<br>    demo_mode: u32,<br>}<br><br>@group(2) @binding(0)<br>var<uniform> material: VectorDemoMaterial;<br><br>@vertex<br>fn vertex(<br>    @builtin(instance_index) instance_index: u32,<br>    @location(0) position: vec3<f32>,<br>    @location(1) normal: vec3<f32>,<br>) -&gt; VertexOutput {<br>    var out: VertexOutput;<br><br>    let world_from_local = mesh_functions::get_world_from_local(instance_index);<br>    let world_position = mesh_functions::mesh_position_local_to_world(<br>        world_from_local,<br>        vec4<f32>(position, 1.0)<br>    );<br><br>    out.position = position_world_to_clip(world_position.xyz);<br>    out.world_normal = mesh_functions::mesh_normal_local_to_world(normal, instance_index);<br>    out.world_position = world_position;<br><br>    return out;<br>}<br><br>@fragment<br>fn fragment(in: VertexOutput) -&gt; @location(0) vec4<f32> {<br>    // Create a base color from the normal<br>    let base = (in.world_normal + 1.0) * 0.5;<br><br>    // Mode 0: RGB channels separately<br>    if material.demo_mode == 0u {<br>        // Show only red channel<br>        return vec4<f32>(base.r, 0.0, 0.0, 1.0);<br>    }<br><br>    // Mode 1: Swizzling demonstration<br>    if material.demo_mode == 1u {<br>        // Reverse the RGB channels (BGR)<br>        let swizzled = base.bgr;<br>        return vec4<f32>(swizzled, 1.0);<br>    }<br><br>    // Mode 2: Vector arithmetic<br>    if material.demo_mode == 2u {<br>        // Add a constant color<br>        let added = base + vec3<f32>(0.0, 0.3, 0.0);  // Add green<br>        return vec4<f32>(added, 1.0);<br>    }<br><br>    // Mode 3: Vector multiplication<br>    if material.demo_mode == 3u {<br>        // Multiply by a color (component-wise)<br>        let tinted = base * vec3<f32>(1.0, 0.5, 0.5);  // Reduce green and blue<br>        return vec4<f32>(tinted, 1.0);<br>    }<br><br>    // Mode 4: Component extraction and reconstruction<br>    if material.demo_mode == 4u {<br>        // Extract xy, ignore z, add new z<br>        let xy = base.xy;<br>        let reconstructed = vec3<f32>(xy, 0.5);  // Force z to 0.5<br>        return vec4<f32>(reconstructed, 1.0);<br>    }<br><br>    // Default: Original<br>    return vec4<f32>(base, 1.0);<br>}<br>```<br><br>### The Rust Material (`src/materials/vector_demo.rs`)<br><br>This is the Rust-side definition of our material. It's a simple struct that mirrors the&nbsp;`VectorDemoMaterial`&nbsp;struct in our shader, allowing Bevy's rendering engine to send our chosen&nbsp;`demo_mode`&nbsp;value to the GPU.<br><br>```rust<br>use bevy::prelude::*;<br>use bevy::render::render_resource::{AsBindGroup, ShaderRef};<br><br>#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]<br>pub struct VectorDemoMaterial {<br>    #[uniform(0)]<br>    pub demo_mode: u32,<br>}<br><br>impl Material for VectorDemoMaterial {<br>    fn fragment_shader() -&gt; ShaderRef {<br>        "shaders/vector_demo.wgsl".into()<br>    }<br><br>    fn vertex_shader() -&gt; ShaderRef {<br>        "shaders/vector_demo.wgsl".into()<br>    }<br>}<br>```<br><br>Don't forget to add it to `src/materials/mod.rs`:<br><br>```rust<br>// ... other materials<br>pub mod vector_demo;<br>```<br><br>### The Demo Module (`src/demos/vector_demo.rs`)<br><br>This Rust module sets up our Bevy scene. It spawns a sphere with our custom material, adds a camera and light, and sets up the UI text. Most importantly, it contains the&nbsp;`cycle_demo_mode`&nbsp;system, which listens for the spacebar press and updates the&nbsp;`demo_mode`&nbsp;field on our material, triggering the change in the shader.<br><br>```rust<br>use crate::materials::vector_demo::VectorDemoMaterial;<br>use bevy::prelude::*;<br><br>pub fn run() {<br>    App::new()<br>        .add_plugins(DefaultPlugins)<br>        .add_plugins(MaterialPlugin::<vectordemomaterial>::default())<br>        .add_systems(Startup, setup)<br>        .add_systems(Update, (rotate_camera, cycle_demo_mode))<br>        .run();<br>}<br><br>fn setup(<br>    mut commands: Commands,<br>    mut meshes: ResMut<assets<mesh>&gt;,<br>    mut materials: ResMut<assets<vectordemomaterial>&gt;,<br>) {<br>    // Spawn a sphere<br>    commands.spawn((<br>        Mesh3d(meshes.add(Sphere::new(1.0).mesh().uv(32, 18))),<br>        MeshMaterial3d(materials.add(VectorDemoMaterial { demo_mode: 0 })),<br>    ));<br><br>    // Light<br>    commands.spawn((<br>        PointLight {<br>            shadows_enabled: true,<br>            ..default()<br>        },<br>        Transform::from_xyz(4.0, 8.0, 4.0),<br>    ));<br><br>    // Camera<br>    commands.spawn((<br>        Camera3d::default(),<br>        Transform::from_xyz(-2.5, 4.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y),<br>    ));<br><br>    // UI<br>    commands.spawn((<br>        Text::new("Press SPACE to cycle modes\nMode 0: Red channel only"),<br>        Node {<br>            position_type: PositionType::Absolute,<br>            top: Val::Px(10.0),<br>            left: Val::Px(10.0),<br>            ..default()<br>        },<br>    ));<br>}<br><br>fn rotate_camera(time: Res<time>, mut camera_query: Query&lt;&amp;mut Transform, With<camera3d>&gt;) {<br>    for mut transform in camera_query.iter_mut() {<br>        let radius = 9.0;<br>        let angle = time.elapsed_secs() * 0.5;<br>        transform.translation.x = angle.cos() * radius;<br>        transform.translation.z = angle.sin() * radius;<br>        transform.look_at(Vec3::ZERO, Vec3::Y);<br>    }<br>}<br><br>fn cycle_demo_mode(<br>    keyboard: Res<buttoninput<keycode>&gt;,<br>    mut materials: ResMut<assets<vectordemomaterial>&gt;,<br>    mut text_query: Query&lt;&amp;mut Text&gt;,<br>) {<br>    if keyboard.just_pressed(KeyCode::Space) {<br>        for (_, material) in materials.iter_mut() {<br>            material.demo_mode = (material.demo_mode + 1) % 5;<br><br>            for mut text in text_query.iter_mut() {<br>                **text = match material.demo_mode {<br>                    0 =&gt; "Press SPACE to cycle modes\nMode 0: Red channel only".to_string(),<br>                    1 =&gt; "Press SPACE to cycle modes\nMode 1: BGR swizzle (reversed)".to_string(),<br>                    2 =&gt; "Press SPACE to cycle modes\nMode 2: Add green (vector addition)"<br>                        .to_string(),<br>                    3 =&gt; "Press SPACE to cycle modes\nMode 3: Color tint (vector multiplication)"<br>                        .to_string(),<br>                    4 =&gt; "Press SPACE to cycle modes\nMode 4: XY extraction with new Z".to_string(),<br>                    _ =&gt; "Unknown mode".to_string(),<br>                };<br>            }<br>        }<br>    }<br>}<br>```<br><br>Don't forget to add it to `src/demos/mod.rs`:<br><br>```rust<br>// ... other demoss<br>pub mod vector_demo;<br>```<br><br>And register it in `src/main.rs`:<br><br>```rust<br>Demo {<br>    number: "1.2",<br>    title: "WGSL Fundamentals - Data Types &amp; Variables",<br>    run: demos::vector_demo::run,<br>},<br>```<br><br>### Running the Demo<br><br>When you run the project, you will see a multi-colored sphere. Pressing the spacebar will cycle through the five different debug visualizations, each revealing how a different vector operation affects the final color.<br><br>#### Controls<br><br>| Control   | Action                                                             |<br>| --------- | ------------------------------------------------------------------ |<br>| **SPACE** | Cycle to the next visualization mode (0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 0). |<br><br>#### What You're Seeing<br><br>![screenshot 1](/files/media/screenshot%201.png)<br>![screenshot 2](/files/media/screenshot%202.png)<br>![screenshot 3](/files/media/screenshot%203.png)<br>![screenshot 4](/files/media/screenshot%204.png)<br>![screenshot 5](/files/media/screenshot%205.png)<br><br>Each mode corresponds to a different branch in our fragment shader's logic.<br><br>| Mode                      | Description                                                                                                 | What It Proves                                                                                                                    |<br>| ------------------------- | ----------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |<br>| **0 - Red Channel Only**  | The sphere is colored only with the red component of the base color.                                        | Demonstrates&nbsp;**component access**&nbsp;(`base.r`). We've isolated a single&nbsp;`f32`&nbsp;from a&nbsp;`vec3`.                                        |<br>| **1 - BGR Swizzle**       | The colors are reversed. Areas that were red are now blue, and vice-versa.                                  | Demonstrates&nbsp;**swizzling**&nbsp;(`base.bgr`). We created a new&nbsp;`vec3`&nbsp;by reordering the components of the original.                    |<br>| **2 - Vector Addition**   | The entire sphere appears brighter and greener.                                                             | Demonstrates&nbsp;**component-wise addition**. We added&nbsp;`(0.0, 0.3, 0.0)`&nbsp;to every single pixel's color, increasing its green channel. |<br>| **3 - Color Tint**        | The sphere appears more reddish-orange, with the greens and blues muted.                                    | Demonstrates&nbsp;**component-wise multiplication**. We scaled the G and B channels by&nbsp;`0.5`, effectively tinting the entire result.   |<br>| **4 - XY Reconstruction** | The color is now only composed of red and green, with a constant blue value of 0.5 across the whole sphere. | Demonstrates&nbsp;**construction and extraction**. We extracted a&nbsp;`vec2&nbsp;(base.xy)` and used it to construct a new&nbsp;`vec3`.              |<br><br>## Key Takeaways<br><br>This article introduced you to the alphabet of the WGSL language. Before moving on, ensure you have a solid grasp of these core concepts, as they are the foundation upon which all shader logic is built.<br><br>1. **Scalars are the Atomic Units, with&nbsp;`f32`&nbsp;Being King**.<br>    WGSL provides the basic building blocks of&nbsp;`f32`&nbsp;(floats),&nbsp;`i32`/`u32`&nbsp;(integers), and&nbsp;bool&nbsp;(booleans). Remember that nearly all graphics math is done with&nbsp;`f32`, and you must be explicit with literals (use&nbsp;`1.0`&nbsp;for a float,&nbsp;`1u`&nbsp;for an unsigned integer).<br>2. **Vectors are the Workhorse for All Graphics Data.**  <br>    Positions, colors, directions, texture coordinates - everything is represented by vectors (`vec2`,&nbsp;`vec3`,&nbsp;`vec4`). Learning to think in terms of vectors is the most important step in becoming a shader programmer. They are not just data containers; they are the native language of the GPU.<br>3. **Vector Operations are Fast, Powerful, and Component-Wise.**  <br>    The GPU is optimized to perform math on vectors. Operations like addition, subtraction, and multiplication are applied to each component independently. This is perfect for tasks like blending colors or offsetting positions.&nbsp;**Swizzling**&nbsp;(`.rgba`,&nbsp;`.xy`,&nbsp;`.bgr`) is a zero-cost hardware feature that lets you efficiently rearrange and create new vectors from existing ones.<br>4. **Matrices are the Machines of Transformation.**  <br>    While we'll cover the deep math later, understand now that matrices (especially&nbsp;`mat4x4<f32>`) are the tools used to move, rotate, scale, and project your vectors from one coordinate space to another. The core of a vertex shader is applying matrix transformations to vertex positions.<br>5. **Prefer Immutable&nbsp;let&nbsp;for Safety and Performance.**  <br>    Use&nbsp;let&nbsp;to declare constants by default. This makes your code safer, easier to reason about, and provides crucial information to the shader compiler, enabling powerful optimizations. Only use&nbsp;var&nbsp;for mutable variables when you have a specific need to change a value after its initial declaration, such as an accumulator in a loop.<br><br>## What's Next?<br><br>You have now learned the "nouns" of the WGSL language - the fundamental data types and variables used to represent all the data in your shader, from a single boolean flag to a complex transformation matrix. You know how to create, store, and perform basic math on this data.<br><br>But data on its own is static. To bring our shaders to life, we need to create logic. In the next article, we will learn the "verbs" and "grammar" of WGSL. We will explore how to organize your code into reusable&nbsp;**functions**&nbsp;and how to make decisions and repeat operations using&nbsp;**control flow**&nbsp;structures like&nbsp;`if/else`&nbsp;and&nbsp;`for`&nbsp;loops.<br><br>_Next up:_&nbsp;[**_1.3 - WGSL Fundamentals - Functions &amp; Control Flow_**](https://hexbee.hashnode.dev/13-wgsl-fundamentals-functions-and-control-flow)<br><br>---<br><br>## Quick Reference<br><br>A cheat sheet for the fundamental building blocks of the WGSL language.<br><br>### Scalar Types<br><br>| Type   | Description                                              | Example Literal       |<br>| ------ | -------------------------------------------------------- | --------------------- |<br>| `f32`  | 32-bit floating-point number. The default for most math. | `1.0`,&nbsp;`-0.5`,&nbsp;`3.14` |<br>| `i32`  | 32-bit signed integer. The default for integers.         | `42`,&nbsp;`-10`,&nbsp;`0`      |<br>| `u32`  | 32-bit unsigned integer (non-negative).                  | `0u`,&nbsp;`255u`,&nbsp;`100u`  |<br>| `bool` | A boolean value.                                         | `true`,&nbsp;`false`       |<br><br>### Variable Declaration<br><br>- `let name = value;`: Declares an&nbsp;**immutable constant**. Its value cannot be changed.&nbsp;**Use this by default.**<br>- `var name = value;`: Declares a&nbsp;**mutable variable**. Its value can be reassigned. Use only when necessary (e.g., accumulators, loop counters).<br><br>### Vector Types<br><br>The workhorse of shader programming.&nbsp;`T`&nbsp;can be&nbsp;`f32`,&nbsp;`i32`,&nbsp;`u32`, or&nbsp;bool.<br><br>**Syntax:**&nbsp;`vecN<t>`&nbsp;(e.g.,&nbsp;`vec3<f32>`)<br><br>#### Construction<br><br>```wgsl<br>// From components<br>let v3 = vec3<f32>(1.0, 2.0, 3.0);<br><br>// From a single value ("splat")<br>let v3 = vec3<f32>(0.5); // -&gt; vec3(0.5, 0.5, 0.5)<br><br>// Combining smaller types<br>let xy = vec2<f32>(1.0, 2.0);<br>let v3 = vec3<f32>(xy, 3.0); // -&gt; vec3(1.0, 2.0, 3.0)<br>let v4 = vec4<f32>(v3, 1.0); // -&gt; vec4(1.0, 2.0, 3.0, 1.0)<br>```<br><br>#### Access &amp; Swizzling<br><br>```wgsl<br>let v = vec4<f32>(1.0, 2.0, 3.0, 4.0);<br><br>// Access (all are equivalent for the first component)<br>let c0_a = v.x; // -&gt; 1.0<br>let c0_b = v.r; // -&gt; 1.0<br>let c0_c = v[0]; // -&gt; 1.0<br><br>// Swizzling (creating new vectors)<br>let v2 = v.xy;      // -&gt; vec2(1.0, 2.0)<br>let v3 = v.bgr;     // -&gt; vec3(3.0, 2.0, 1.0) (reordered)<br>let v3 = v.rrr;     // -&gt; vec3(1.0, 1.0, 1.0) (duplicated)<br>let v2 = v.wz;      // -&gt; vec2(4.0, 3.0)<br>```<br><br>#### Arithmetic (Component-Wise)<br><br>```wgsl<br>let a = vec2<f32>(1.0, 2.0);<br>let b = vec2<f32>(3.0, 4.0);<br><br>let sum = a + b;    // -&gt; vec2(4.0, 6.0)<br>let prod = a * b;   // -&gt; vec2(3.0, 8.0)<br>let scaled = a * 2.0; // -&gt; vec2(2.0, 4.0)<br>```<br><br>### Matrix Types<br><br>Used for transformations.&nbsp;`C`=Columns,&nbsp;`R`=Rows.<br><br>**Syntax:**&nbsp;`matCxR<t>`&nbsp;(e.g.,&nbsp;`mat4x4<f32>`)<br><br>- **Column-Major**: Data is organized by columns.<br>- **Access**:&nbsp;`matrix[column_index][row_index]`<br>- **Multiplication**:&nbsp;`transformed_vector = matrix * vector`&nbsp;(This is a mathematical transformation, not component-wise).<br></f32></t></f32></f32></f32></f32></f32></f32></f32></f32></f32></t></f32></assets<vectordemomaterial></buttoninput<keycode></camera3d></time></assets<vectordemomaterial></assets<mesh></vectordemomaterial></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></uniform></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></t></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></f32></i32></f32></f32></f32></t></f32></f32>
  </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>1.1 - Understanding the Graphics Pipeline</title>
        <author>
            <name>Xavier Basty Kjellberg</name>
        </author>
        <link href="https://xav.github.io/11-understanding-the-graphics-pipeline/"/>
        <id>https://xav.github.io/11-understanding-the-graphics-pipeline/</id>
        <media:content url="https://xav.github.io/media/posts/3/cover.png" medium="image" />
            <category term="wgsl"/>
            <category term="shaders"/>
            <category term="rust"/>
            <category term="bevy"/>

        <updated>2025-08-30T22:42:00+02:00</updated>
            <summary type="html">
                <![CDATA[
                        <img src="https://xav.github.io/media/posts/3/cover.png" alt="" />
                    What We’re Learning Welcome to the start of your shader programming journey! Before we can write a single line of WGSL code to create shimmering&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://xav.github.io/media/posts/3/cover.png" class="type:primaryImage" alt="" /></p>
                <h2 id="what-were-learning">What We’re Learning</h2>
<p>Welcome to the start of your shader programming journey! Before we can write a single line of WGSL code to create shimmering water or a glowing sword, we must first answer a fundamental question: <strong>what exactly is a shader?</strong></p><p>At its core, a shader is a small, highly-focused program that you, the developer, write. Unlike the Rust code that runs on your computer’s main processor (the CPU), a shader runs directly on the thousands of parallel cores of your Graphics Processing Unit (GPU). This gives you direct, low-level control over how your game’s graphics are rendered. Shaders are the modern key to controlling the look, feel, and performance of everything you see in a real-time 3D application.</p><p>This first chapter pulls back the curtain on the rendering process. We will build a complete mental model of the <strong>graphics pipeline</strong> - the step-by-step assembly line a GPU uses to turn the raw data of your 3D models into the final, vibrant pixels on your screen.</p><p>Understanding this pipeline is the single most important foundation for shader programming. Without it, writing shader code is like trying to assemble a car without knowing what an engine or a wheel does. With it, every new concept will have a clear place to belong.</p><p>By the end of this chapter, you’ll understand:</p><ul>
<li><strong>The Big Picture:</strong> The journey of your 3D model data from the CPU (your Bevy app) to the GPU (the rendering factory).</li>
<li><strong>The “Why” of GPUs:</strong> Why we need a specialized processor for graphics and how its parallel design is perfect for rendering.</li>
<li><strong>The Vertex’s Journey:</strong> How a single point in your 3D model travels through a series of “coordinate spaces” - from its local origin to its final position on your screen.</li>
<li><strong>The Two Programmable Stages:</strong> The specific jobs of the <strong>Vertex Shader</strong> (controlling shape and position) and the <strong>Fragment Shader</strong> (controlling color and appearance), and how your WGSL code fits into this process.</li>
</ul>
<h2 id="the-big-picture-cpu-to-screen">The Big Picture: CPU to Screen</h2>
<p>Let’s start with the fundamental question: <strong>How does a 3D model in your Bevy game become the final, colored pixels on your screen?</strong></p><p>The process is a hand-off of instructions and data from a general-purpose processor (the CPU) to a highly specialized one (the GPU). The CPU decides <em>what</em> needs to be drawn, while the GPU figures out how to draw it at incredible speed. The GPU performs this task using a dedicated assembly line called the <strong>graphics pipeline</strong>.</p><p>Here is a simplified map of that journey:</p><pre><code class="language-plaintext">┌───────────────────────────────────────────┐
│              CPU: The Director            │
│          (Your Bevy / Rust Code)          │
│                                           │
│  - Runs game logic, physics, AI, etc.     │
│  - Decides WHAT to draw this frame.       │
│  - Packages all necessary data for GPU.   │
└───────────────────────────────────────────┘
                       │
                       │ Sends a &quot;Draw Command&quot; with all required data
                       ↓
  ═════════════════════ GPU BOUNDARY ═════════════════════
                       ↓
┌───────────────────────────────────────────┐
│             GPU: The Factory              │
│       (Massively Parallel Hardware)       │
└───────────────────────────────────────────┘
                       │
                       ▼
┌───────────────────────────────────────────┐
│            1. VERTEX SHADER               │ «── [ YOUR WGSL CODE RUNS HERE ]
├───────────────────────────────────────────┤
│ INPUT:  A single vertex from a mesh       │
│         (e.g., its local position, UVs).  │
│                                           │
│ JOB:    Calculate the vertex&#39;s final      │
│         position on the screen.           │
│                                           │
│ OUTPUT: The vertex&#39;s position in          │
│         &quot;Clip Space&quot; &amp; other data         │
│         (like normals) for the next stage.│
└───────────────────────────────────────────┘
                       │
                       │ (GPU groups 3 processed vertices into a triangle)
                       ↓
┌───────────────────────────────────────────┐
│            2. RASTERIZATION               │ «── [ AUTOMATIC HARDWARE STAGE ]
├───────────────────────────────────────────┤
│ INPUT:  A triangle in screen space.       │
│                                           │
│ JOB:    Determine which pixels the        │
│         triangle covers.                  │
│                                           │
│ OUTPUT: A stream of &quot;Fragments.&quot;          │
│         (A fragment is a potential pixel  │
│         with smoothly interpolated data). │
└───────────────────────────────────────────┘
                       │
                       ↓
┌───────────────────────────────────────────┐
│           3. FRAGMENT SHADER              │ «── [ YOUR WGSL CODE RUNS HERE ]
├───────────────────────────────────────────┤
│ INPUT:  A single fragment with its        │
│         interpolated data (e.g., UVs).    │
│                                           │
│ JOB:    Calculate the final color for     │
│         that specific fragment.           │
│                                           │
│ OUTPUT: A single RGBA color.              │
└───────────────────────────────────────────┘
                       │
                       ↓
┌───────────────────────────────────────────┐
│           4. OUTPUT MERGER                │ «── [ AUTOMATIC HARDWARE STAGE ]
├───────────────────────────────────────────┤
│ JOB:    Take the colored fragment and     │
│         merge it into the final image.    │
│                                           │
│       - Performs Depth Test (is this      │
│         fragment behind something else?). │
│       - Performs Blending (for            │
│         transparency effects).            │
│       - Writes the final color.           │
└───────────────────────────────────────────┘
                       │
                       ▼
            ▓▓▓ PIXELS ON SCREEN ▓▓▓
</code></pre>
<p>This process spans two distinct worlds, each with a specific job.</p><h3 id="the-cpu-side-bevyrust-the-director">The CPU Side (Bevy/Rust): The Director</h3>
<p>Think of your CPU and your Bevy code as the <strong>director of a film</strong>. It’s smart, flexible, and responsible for all the high-level decision-making. For every single frame (60 times a second!), it runs your game logic, updates physics, handles input, and determines what needs to be on screen and where it should be.</p><p>Its final job for rendering is to prepare a detailed set of instructions and data for the GPU. This “frame package” includes:</p><ul>
<li><strong>Mesh Data</strong>: The raw vertex information (positions, normals, UV coordinates) for each model.</li>
<li><strong>Material Data</strong>: Your shader’s settings, like colors, roughness values, and which textures to use.</li>
<li><strong>Transformation Data</strong>: The matrices that define each object’s position, rotation, and scale in the world.</li>
<li><strong>Global Data</strong>: Information about the entire scene, like the camera’s position (View Matrix), its lens settings (Projection Matrix), and the location of lights.</li>
</ul>
<p>Once this package is assembled, the CPU sends it across the bus to the GPU and effectively says, “Here, render this.” The CPU’s main rendering job for this frame is now complete.</p><h3 id="the-gpu-side-shaders-the-vfx-studio">The GPU Side (Shaders): The VFX Studio</h3>
<p>Think of the GPU as a state-of-the-art <strong>VFX studio</strong> with an army of digital artists, each with a very specific job. This studio is built for one purpose: turning the director’s brief into a final, beautifully rendered image with incredible speed. Their process is the graphics pipeline.</p><p>When the brief arrives at the studio:</p><ol>
<li><strong>The Geometry &amp; Layout Artists (Vertex Shader):</strong> The first team gets the brief. This team consists of thousands of artists. Each artist is assigned a single corner (a <strong>vertex</strong>) of an actor or prop. Their only job is to calculate exactly where that specific corner will appear in the final camera shot, based on the actor’s position and the camera’s lens. They don’t color anything; they just map out the structure of the scene from the camera’s perspective.</li>
<li><strong>The Rendering Artists (Fragment Shader):</strong> After the layout is done, a second, even larger army of artists takes over. There are millions of them - one for every pixel of the final image. Each artist is assigned a single pixel to paint (a <strong>fragment</strong>). They look at the director’s notes for that surface (the material, the textures) and the lighting setup. Then, they calculate and apply the final, precise color for their one tiny pixel.</li>
</ol>
<p>This analogy directly maps to the GPU’s strengths:</p><ul>
<li><strong>Specialization:</strong> The geometry artists only do positioning; the rendering artists only do coloring.</li>
<li><strong>Parallelism:</strong> Millions of rendering artists can paint their individual pixels all at the exact same time, without needing to talk to each other. This is what makes the GPU so fast.</li>
</ul>
<p>Your WGSL shader code is the set of instructions - the “artistic direction” - you give to these two teams of digital artists.</p><h2 id="why-the-gpu-understanding-parallelism">Why the GPU? Understanding Parallelism</h2>
<p>It’s a fair question: your computer’s Central Processing Unit (CPU) is an incredibly powerful and fast processor. Why can’t it just draw the triangles? Why do we need a separate, specialized piece of hardware like a Graphics Processing Unit (GPU)?</p><p>The answer lies not in raw clock speed, but in a fundamentally different architectural philosophy: <strong>Serial vs. Parallel processing</strong>.</p><h3 id="the-cpu-a-master-chef">The CPU: A Master Chef</h3>
<p>Think of your CPU as a <strong>master chef in a world-class kitchen</strong>.</p><ul>
<li><strong>It is brilliant and versatile.</strong> It can follow any recipe (run any program), handle complex sequential steps, improvise when needed (handle interrupts and varied tasks), and manage the entire kitchen (the operating system).</li>
<li><strong>It has a few, very powerful cores.</strong> Like having 8 or 16 highly trained sous-chefs, it can work on a handful of complex, different dishes at once.</li>
</ul>
<p>If you asked this master chef to prepare a single, elaborate seven-course meal, they would excel. But if you asked them to make ten million identical hamburgers, the entire restaurant would grind to a halt. The chef’s genius is wasted on such a simple, repetitive task; its strength is in complexity and flexibility, not mass production.</p><h3 id="the-gpu-a-hyper-efficient-assembly-line">The GPU: A Hyper-Efficient Assembly Line</h3>
<p>Now, think of your GPU as a <strong>massive hamburger assembly line that stretches for miles</strong>.</p><ul>
<li><strong>It is highly specialized.</strong> It’s not designed to create new recipes. It’s designed to execute one simple recipe over and over again with breathtaking speed.</li>
<li><strong>It has thousands of simple cores.</strong> Instead of a few master chefs, you have thousands of line cooks. Each cook is trained for just one or two simple tasks - place the patty, add the cheese - but they all work at the exact same time.</li>
</ul>
<p>This factory can’t prepare a seven-course meal, but it can produce those ten million identical hamburgers in the blink of an eye. This is what we call <strong>“pleasingly parallel”</strong> work.</p><h3 id="graphics-is-a-pleasingly-parallel-problem">Graphics is a “Pleasingly Parallel” Problem</h3>
<p>Rendering a 3D scene is the ultimate assembly-line task. The core operations are simple, repetitive, and most importantly, <strong>independent</strong>.</p><ul>
<li>The calculation for vertex A’s final position does not depend on vertex B’s position.</li>
<li>The calculation for pixel #1’s color does not depend on pixel #2’s color.</li>
</ul>
<p>They can all be processed simultaneously.</p><p>Let’s put this into perspective. When rendering a moderately complex scene with 100,000 triangles on a standard 1080p display, for a single frame, you are asking the hardware to perform approximately:</p><ul>
<li><strong>300,000 vertex shader executions</strong> (one for each vertex)</li>
<li><strong>Millions of fragment shader executions</strong> (one for each pixel covered by a triangle)</li>
</ul>
<p>And this has to happen <strong>60 times every second</strong> for smooth gameplay.</p><p>This is the “ten million hamburgers” problem. A CPU, with its few brilliant cores, would be overwhelmed trying to handle these tasks one by one. But a GPU, with its thousands of simple cores, can process huge batches of vertices and pixels all at once.</p><p>This is why we write shaders for the GPU. We are providing the “recipe” for the assembly line workers. The GPU’s architecture is not just “more cores”; it’s a completely different philosophy of computation, one that is perfectly and beautifully matched to the massive, repetitive, and parallel nature of computer graphics.</p><h2 id="the-rendering-pipeline-in-detail">The Rendering Pipeline in Detail</h2>
<p>Let’s zoom in on the VFX studio’s assembly line. Each stage has a specific responsibility, taking a particular kind of data as input and producing a new kind of data for the next stage to work on.</p><h3 id="stage-1-the-application-stage-cpu---the-directors-brief">Stage 1: The Application Stage (CPU - The Director’s Brief)</h3>
<p>This stage isn’t on the GPU at all - it’s your Bevy application running on the CPU. Think of it as the “pre-production” step where the director prepares the detailed brief. Before any rendering can happen, your application needs to tell the GPU everything it needs to know about the world for the upcoming frame. Bevy’s renderer orchestrates this for you.</p><p>For every frame, Bevy traverses your scene’s Entity-Component-System (ECS) world and gathers all the necessary information:</p><pre><code class="language-rust">// You write this in Bevy, describing the &quot;what&quot; and &quot;where&quot;
commands.spawn((
 Mesh3d(meshes.add(Sphere::new(1.0))),
 MeshMaterial3d(materials.add(my_custom_material)),
));
</code></pre>
<p>From code like this, Bevy assembles the “shot list”:</p><ul>
<li><strong>What to draw</strong>: A list of meshes (the sphere’s vertices and triangles).</li>
<li><strong>How to draw it</strong>: The material to use and its properties (colors, textures).</li>
<li><strong>Where it is</strong>: The object’s world position, rotation, and scale (the Transform).</li>
<li><strong>From where to view it</strong>: The camera’s position and perspective settings.</li>
</ul>
<p>The final output of this stage is a highly-organized package of data and commands, which Bevy then sends over to the GPU to begin the actual rendering process.</p><h3 id="stage-2-the-vertex-shader-gpu---the-layout-artists">Stage 2: The Vertex Shader (GPU - The Layout Artists)</h3>
<p>This is the <strong>first programmable stage</strong> on the GPU, where your first piece of WGSL code runs. The vertex shader’s fundamental job is to answer one question for every single vertex of a mesh: <strong>“Where on the screen does this vertex end up?”</strong></p><ul>
<li><strong>Input</strong>: It receives the data for a <strong>single vertex</strong> at a time (its position in local model space, its normal vector, its UV coordinates, etc.).</li>
<li><strong>The Job</strong>: Its one mandatory task is to perform mathematical operations (usually matrix multiplications) to transform the vertex’s 3D position into a final 4D “clip space” position. This clip space coordinate is what the GPU hardware needs to figure out the 2D location on your monitor.</li>
<li><strong>Output</strong>: It must output that final clip space position. It can also pass along any other data it received or calculated (like colors, normals, or UVs) to be used later by the fragment shader.</li>
</ul>
<p>Here’s a conceptual view of what your WGSL code will do:</p><pre><code class="language-wgsl">@vertex
fn vertex(input: VertexInput) -&gt; VertexOutput {
    var output: VertexOutput;

    // The primary job: Transform the 3D local position into a final 2D screen position.
    output.position = project_to_screen(view_matrix * model_matrix * input.position);

    // A secondary job: Pass necessary data to the next stage.
    // Here, we&#39;re just passing the vertex&#39;s normal along for lighting calculations later.
    output.normal = input.normal;
    return output;
}
</code></pre>
<p><strong>Key Insight</strong>: Because this shader runs on every vertex, it gives you the power to manipulate the shape and position of your geometry in real-time. This is not just about moving objects around (which is best done by changing the Transform in Bevy); it’s about deforming the mesh itself. This is how you create dynamic effects like:</p><ul>
<li>Waving flags</li>
<li>Rippling water surfaces</li>
<li>Procedurally animated grass swaying in the wind</li>
</ul>
<h3 id="stage-3-the-rasterizer-gpu---automatic-hardware">Stage 3: The Rasterizer (GPU - Automatic Hardware)</h3>
<p>This stage is a piece of dedicated, non-programmable hardware on the GPU. It’s an automatic, incredibly fast process that you don’t write code for. The rasterizer takes the processed vertices from the vertex shader (three at a time to form a triangle) and figures out which pixels on the screen that triangle covers.</p><p>For every single pixel it covers, it generates a <strong>“fragment.”</strong> A fragment is a “potential pixel” - it contains all the information needed to calculate a final color.</p><p>This is also where the magic of <strong>interpolation</strong> happens. The rasterizer looks at the data you passed out of the vertex shader for each of the triangle’s three vertices and smoothly blends it across the surface of the triangle for each fragment.</p><p>Think of it like this:</p><figure class="post__image"><img src="/media/files/1.1%20-%20figure%20-%20Rasterizer.png" alt="rasterizer" data-is-external-image="true"></figure><ul>
<li>A fragment near the top will receive a reddish color.</li>
<li>A fragment on the left edge will get a purplish color (red + blue).</li>
<li>A fragment right in the middle will get a muddy, grayish color, which is the mathematical average of red, green, and blue.</li>
</ul>
<p>The rasterizer does this for every single piece of data you passed along - colors, UV coordinates, normals, etc. The output is a massive stream of fragments, each one “pre-loaded” with its own unique, interpolated data, ready to be colored.</p><h3 id="stage-4-the-fragment-shader-gpu---the-rendering-artists">Stage 4: The Fragment Shader (GPU - The Rendering Artists)</h3>
<p>This is the <strong>second programmable stage</strong>, and it’s where most of the visual artistry happens. The fragment shader’s job is to answer one simple question for every single fragment generated by the rasterizer: <strong>“What color is this pixel?”</strong></p><ul>
<li><strong>Input</strong>: It receives the interpolated data for a <strong>single fragment</strong>. This includes its position on the screen and the smoothly blended values (like normals and UVs) that were passed from the vertex shader.</li>
<li><strong>The Job</strong>: To use this input data to perform calculations and return a single, final color.</li>
<li><strong>Output</strong>: It must output a <code>vec4&lt;f33&gt;</code> representing an RGBA color. This is the color that will be written to the screen (assuming it passes final tests like depth testing).</li>
</ul>
<p>Here’s a conceptual view of what your WGSL code will do:</p><pre><code class="language-wgsl">@fragment
fn fragment(input: FragmentInput) -&gt; @location(0) vec4&lt;f32&gt; {
    // The input data (e.g., input.normal) has already been smoothly interpolated for us.
    // We can use it to calculate lighting for this specific pixel.
    let lighting = calculate_light(input.normal, light_direction);

    // We could also sample a texture using the interpolated UVs.
    let surface_color = sample_texture(input.uv);

    // Combine them to get the final color.
    let final_color = surface_color * lighting;
    return vec4&lt;f32&gt;(final_color, 1.0); // Return the final RGBA value
}
</code></pre>
<p><strong>Key Insight</strong>: The fragment shader runs for potentially millions of pixels every frame. This is your chance to define the appearance of your object’s surface with incredible detail. This is where you:</p><ul>
<li>Apply lighting calculations to create highlights and shadows.</li>
<li>Sample textures to give a surface detail and color.</li>
<li>Create procedural patterns like stripes, checkerboards, or noise.</li>
<li>Implement special effects like glowing, outlines, or distortion.</li>
</ul>
<h2 id="the-coordinate-space-journey">The Coordinate Space Journey</h2>
<p>One of the most initially confusing, but ultimately powerful, concepts in graphics programming is the journey a vertex takes through different <strong>coordinate spaces</strong>. Each space is a different frame of reference, like describing a location from a different point of view. The vertex shader’s main job is to transform a vertex from one space to the next, like a series of conversions, until it lands in the right spot on the screen.</p><p>Think of it like giving directions to a friend:</p><ol>
<li>“The book is on the second shelf of the bookcase.” (<strong>Local Space</strong>: The position is relative to the bookcase).</li>
<li>“The bookcase is against the north wall of the living room.” (<strong>World Space</strong>: Now the bookcase’s position is relative to the entire house).</li>
<li>“Stand in the doorway and look towards the fireplace.” (<strong>View Space</strong>: Now everything is described from your friend’s point of view).</li>
<li>“The book you’re looking for should be in the upper-left part of your vision.” (<strong>Clip Space</strong>: This is what’s in their field of view).</li>
</ol>
<p>In 3D graphics, we perform these transformations using matrix mathematics.</p><p><strong>Note</strong>: Don’t worry if the matrix math looks intimidating right now. We have a dedicated chapter later that explains how matrices work. For now, just focus on the purpose of each transformation - what question it answers.</p><h3 id="1-local-space-or-model-space">1. Local Space (or Model Space)</h3>
<p><strong>The Question:</strong> “What does this object look like by itself?”</p><p>This is the object’s blueprint. When an artist creates a 3D model of a car, they don’t care where it will be in your game world. They model it at the center of its own universe, the origin <code>(0, 0, 0)</code>. The coordinates of every vertex are relative only to the car’s own center point.</p><pre><code class="language-plaintext">A car&#39;s front-right tire vertex in Local Space might be:
(0.8, 0.3, 1.5)
</code></pre>
<h3 id="2-world-space">2. World Space</h3>
<p><strong>The Question:</strong> “Where is this object in the game world?”</p><p>This is the shared, global coordinate system of your entire scene. It’s the common frame of reference where all your objects, lights, and the camera coexist. When you give an entity a Transform in Bevy, you are defining its position, rotation, and scale within this World Space.</p><pre><code class="language-rust">// This Transform moves the object from its local origin to a specific spot in the world.
Transform::from_xyz(10.0, 0.0, -20.0)
</code></pre>
<p>The <strong>Model Matrix</strong>, which Bevy derives from this <code>Transform</code>, is the mathematical tool that converts vertices from <strong>Local Space</strong> to <strong>World Space</strong>. Your vertex shader applies it to every vertex.</p><pre><code class="language-plaintext">Local Position × Model Matrix = World Position
</code></pre>
<h3 id="3-view-space-or-camera-space">3. View Space (or Camera Space)</h3>
<p><strong>The Question:</strong> “How does the world look from the camera’s perspective?”</p><p>Once everything is placed in the world, we need to view it. To make the math simpler for the next step, we transform the entire world so that the camera is at the origin <code>(0, 0, 0)</code> and looking down a specific axis (typically negative Z). Everything in the world is now positioned relative to the camera. An object in front of the camera will have a negative Z coordinate, an object to the camera’s left will have a negative X, and so on.</p><p>The <strong>View Matrix</strong> performs this transformation. It’s calculated from the camera’s own world-space transform.</p><pre><code class="language-plaintext">World Position × View Matrix = View Position
</code></pre>
<h3 id="4-clip-space">4. Clip Space</h3>
<p><strong>The Question:</strong> “Is this vertex inside the viewable area, and if so, where?”</p><p>This is the final and most abstract space that the vertex shader is responsible for creating. It’s a standardized, cube-like volume that represents everything the camera can see. The transformation into this space, performed by the <strong>Projection Matrix</strong>, does two magical things:</p><ol>
<li><strong>It applies perspective.</strong> It mathematically squishes the 3D scene so that objects farther away from the camera appear smaller than objects that are closer. This is what creates the illusion of depth.</li>
<li><strong>It normalizes the coordinates.</strong> Everything that will be visible on screen is mapped into a neat box where the X and Y coordinates range from -1 to 1. The Z coordinate is also remapped (usually to a <code>[0, 1]</code> range) to represent depth.</li>
</ol>
<p>The GPU now has a simple job: any vertex with X or Y coordinates outside of this <code>[-1, 1]</code> range is “clipped” and discarded, as it is off-screen. The Z coordinate will be used in a later stage for depth testing (figuring out if one object is in front of another).</p><pre><code class="language-plaintext">View Position × Projection Matrix = Clip Position
</code></pre>
<p>The mandatory output of your vertex shader is this final Clip Space position.</p><h3 id="5-screen-space">5. Screen Space</h3>
<p><strong>The Question:</strong> “Which specific pixel on my monitor does this correspond to?”</p><p>This final step is handled <strong>automatically by the GPU</strong> after the vertex shader is done. The hardware takes the <code>[-1, 1]</code> Clip Space coordinates and maps them to the actual pixel coordinates of your window (e.g., from <code>(0, 0)</code> in the top-left to <code>(1920, 1080)</code> in the bottom-right). This is not something you calculate in your shaders; it’s the final output of the fixed-function part of the pipeline before the fragment shader runs.</p><h2 id="putting-it-all-together-the-life-of-a-single-vertex">Putting It All Together: The Life of a Single Vertex</h2>
<p>Let’s trace the complete life of a single vertex, from its creation in a modeling tool to its final appearance as a colored pixel on your screen. We’ll follow a vertex at the very top of a sphere model.</p><h3 id="1-the-blueprint-cpu---local-space">1. The Blueprint (CPU - Local Space)</h3>
<p>It begins its life in a 3D modeling program. An artist defines a sphere, and our vertex is created at the very top. Relative to the sphere’s own center, its position is simply (0.0, 1.0, 0.0). This is its <strong>Local Space</strong> position. This data is loaded into Bevy as part of a Mesh asset.</p><h3 id="2-setting-the-scene-cpu---the-directors-brief">2. Setting the Scene (CPU - The Director’s Brief)</h3>
<p>Your Bevy application decides where this sphere belongs in the game world. You assign it a <code>Transform</code> to place it, for example, at world coordinates <code>(5.0, 2.0, -3.0)</code>. The CPU doesn’t move the vertex itself; instead, it calculates a <strong>Model Matrix</strong> from this transform and packages it up, ready to be sent to the GPU’s VFX studio.</p><h3 id="3-the-great-transformation-gpu---vertex-shader">3. The Great Transformation (GPU - Vertex Shader)</h3>
<p>Now the director’s brief is uploaded to the GPU, and our programmable <strong>Vertex Shader</strong> takes over. This is where the “Layout Artists” get to work. The shader receives our vertex’s original local position, <code>(0, 1, 0)</code>, along with the Model, View, and Projection matrices. It then performs the crucial sequence of multiplications to find the vertex’s final on-screen position:</p><ul>
<li><strong>To World Space</strong>: The shader multiplies the local position by the Model Matrix. This moves the vertex into the shared <strong>World Space</strong>. Our vertex at <code>(0, 1, 0)</code> is now effectively at <code>(5.0, 3.0, -3.0)</code> in the game world (position + model’s height).</li>
<li><strong>To View Space</strong>: Next, it multiplies the new world position by the View Matrix. This transforms the vertex into <strong>View Space</strong>, making its coordinates relative to the camera’s perspective. Its position might now be something like <code>(-2.0, 1.0, -5.0)</code>, meaning it’s slightly to the camera’s left, above its center, and some distance in front of it.</li>
<li><strong>To Clip Space</strong>: Finally, it multiplies the view position by the Projection Matrix. This applies perspective and transforms the vertex into the final, required <strong>Clip Space</strong>. The position might now be <code>(-0.4, 0.2, 0.8)</code>. This tells the GPU the vertex is on-screen (since X and Y are between <code>-1</code> and <code>1</code>) and provides its depth. This <code>vec4</code> is the mandatory output of the vertex shader.</li>
</ul>
<p>Simultaneously, the vertex shader also prepares any other data needed for coloring, like the vertex’s color or normal vector, and passes it along.</p><h3 id="4-the-triangle-factory-gpu---rasterizer">4. The Triangle Factory (GPU - Rasterizer)</h3>
<p>The vertex, now just a point in Clip Space, is grouped by the GPU with two other processed vertices to form a triangle. The hardware <strong>Rasterizer</strong> takes over, calculating exactly which screen pixels this triangle covers. For each covered pixel, it generates a “fragment” and <strong>interpolates</strong> all the data that the vertex shaders passed out (like colors or UVs), creating a smooth gradient of values across the triangle’s face.</p><h3 id="5-the-coloring-book-gpu---fragment-shader">5. The Coloring Book (GPU - Fragment Shader)</h3>
<p>A single fragment, born from the rasterizer, arrives at our programmable <strong>Fragment Shader</strong>. Now the “Rendering Artists” do their job. The fragment carries its own unique, interpolated data (e.g., a color that is a blend of the three corner vertices’ colors). The fragment shader’s sole job is to use this information to calculate a final RGBA color. It might sample a texture, calculate lighting, or perform any number of other operations.</p><h3 id="6-the-final-pixel-gpu---output-merger">6. The Final Pixel (GPU - Output Merger)</h3>
<p>The fragment shader outputs its calculated color. This color, along with the fragment’s depth, is sent to the final hardware stage. The GPU performs a <strong>depth test</strong> to see if this fragment is in front of whatever is already on the screen at that pixel. If it is, its color is written to the framebuffer, becoming one of the millions of pixels that form the final image you see. Our vertex has completed its journey.</p><h2 id="a-mental-model-for-your-shaders">A Mental Model for Your Shaders</h2>
<p>The rendering pipeline can seem complex, but by holding on to our “Director and VFX Studio” analogy, we can assign a clear, relatable job to each programmable stage.</p><h3 id="1-the-vertex-shader-the-vfx-layout-artist">1. The Vertex Shader: The VFX Layout Artist</h3>
<p>Your WGSL code in the vertex shader provides the instructions for the layout artists at the VFX studio.</p><table>
<thead>
<tr>
<th>Analogy</th>
<th>Role</th>
<th>Shader Code Focus</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Staging the scene for the camera.</strong></td>
<td>Your job is to take the 3D models (defined in their own local space) and <strong>place them correctly in the world and frame them perfectly in the camera’s shot.</strong></td>
<td><strong>Transformation.</strong> You use matrix math to move each vertex of a model from its origin to its final position relative to the camera’s view. You can also dynamically move vertices here to create animations like waving flags or rippling water.</td>
</tr>
<tr>
<td><strong>Defining the final composition.</strong></td>
<td>You must output the final projected position of each vertex. This is the main deliverable for this stage.</td>
<td><code>output.position = projection * view * model * local_pos;</code></td>
</tr>
<tr>
<td><strong>Prepping for the colorists.</strong></td>
<td>You pass along any surface information that the next team will need, like texture coordinates (uv) or which way the surface is facing (normal).</td>
<td><code>output.world_normal = ..., output.uv = ...</code></td>
</tr>
</tbody></table>
<h3 id="2-the-rasterizer-the-digital-render-farm">2. The Rasterizer: The Digital Render Farm</h3>
<p>This is an automated, non-programmable hardware stage. You don’t write code for it, but you need to know what it does.</p><table>
<thead>
<tr>
<th>Analogy</th>
<th>Role</th>
<th>Shader Code Focus</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Automated rendering setup.</strong></td>
<td>The GPU’s hardware takes the 3D triangles you’ve positioned in the previous step…</td>
<td><strong>None.</strong> This is a fixed, non-programmable step.</td>
</tr>
<tr>
<td><strong>…and projects them onto a 2D grid.</strong></td>
<td>The hardware determines exactly which pixels on the screen are covered by each triangle. For each covered pixel, it creates a “fragment” and <strong>interpolates</strong> (smoothly blends) the data from the triangle’s corners.</td>
<td>A fragment in the middle of a triangle gets a perfectly blended uv coordinate and normal vector, ready for the next stage.</td>
</tr>
</tbody></table>
<h3 id="3-the-fragment-shader-the-vfx-coloring--lighting-artist">3. The Fragment Shader: The VFX Coloring &amp; Lighting Artist</h3>
<p>Your WGSL code in the fragment shader provides the instructions for the massive team of coloring and lighting artists.</p><table>
<thead>
<tr>
<th>Analogy</th>
<th>Role</th>
<th>Shader Code Focus</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Painting one pixel at a time.</strong></td>
<td>Your job is to look at a single, uncolored pixel (a fragment) and <strong>decide what its final color should be.</strong> This is where all the visual artistry happens.</td>
<td><strong>Color Calculation.</strong> You have complete control over the pixel’s final RGBA value.</td>
</tr>
<tr>
<td><strong>Using the prepped materials.</strong></td>
<td>You use the interpolated data from the previous stage to perform your work.</td>
<td><code>return vec4&lt;f32&gt;(final_color, alpha);</code></td>
</tr>
<tr>
<td><strong>Applying textures and lighting.</strong></td>
<td>You can sample <strong>textures</strong> using the interpolated uv coordinates and use the interpolated normal vector to calculate realistic <strong>lighting</strong> and shadows.</td>
<td><code>textureSample(...)</code>, <code>dot(normal, light_dir)</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="complete-example-visualizing-the-pipeline">Complete Example: Visualizing the Pipeline</h2>
<p>Theory is essential, but seeing is believing. To make these abstract concepts concrete, we’ll build a simple, interactive shader in Bevy. This shader won’t create a realistic object; instead, it will act as a diagnostic tool, allowing us to “see” the data at different stages of the pipeline.</p><p><strong>A Note Before We Begin:</strong> You will see new WGSL syntax (@location, @group, etc.) and Bevy patterns (AsBindGroup, MaterialPlugin) in the code below. <strong>Do not worry about understanding every line right now.</strong> We will break down all of these concepts in detail in the upcoming articles.</p><p>The goal of this example is to <strong>observe the visual output</strong> of each mode and connect it back to the high-level pipeline concepts we just learned:</p><ul>
<li>How data is <strong>interpolated</strong> across a surface (the smooth normal colors).</li>
<li>How the fragment shader runs for <strong>every pixel</strong> (the sharp checkerboard).</li>
<li>How data from the <strong>vertex stage</strong> is used in the <strong>fragment stage</strong> (the height gradient).</li>
</ul>
<p>Focus on the “what you’re seeing” part, and treat the code as a preview of what you’ll soon master.</p><h3 id="our-goal">Our Goal</h3>
<p>We will create a custom material for a sphere that can cycle through three different visualization modes by pressing a key. Each mode will highlight a different core concept of the rendering pipeline that we’ve just discussed.</p><h3 id="what-this-project-demonstrates">What This Project Demonstrates</h3>
<ul>
<li><strong>Data Flow and Interpolation:</strong> How data (like normal vectors) passed from the vertex shader is smoothly interpolated by the rasterizer before reaching the fragment shader.</li>
<li><strong>Per-Fragment Processing:</strong> Proof that the fragment shader runs independently for every single pixel, allowing it to create complex patterns based on a fragment’s world position.</li>
<li><strong>Vertex Data in Fragment Shaders:</strong> How to use data prepared by the vertex shader (like the final world position) to drive calculations in the fragment shader.</li>
</ul>
<h3 id="the-shader-assetsshadersdebug_pipelinewgsl">The Shader (<code>assets/shaders/debug_pipeline.wgsl</code>)</h3>
<p>This single WGSL file contains both our vertex and fragment shaders. The key element is the material.mode uniform, a number we can change from our Rust code to switch the logic inside the fragment shader.</p><ul>
<li>The <strong>vertex shader</strong> is standard: it transforms the vertex position into clip space and also passes the vertex’s world position and world normal along to the fragment stage.</li>
<li>The <strong>fragment shader</strong> uses an <code>if/else if</code> chain based on material.mode to decide how to color the current pixel.</li>
</ul>
<pre><code class="language-wgsl">#import bevy_pbr::mesh_functions
#import bevy_pbr::view_transformations::position_world_to_clip
#import bevy_pbr::forward_io::VertexOutput

struct DebugMaterial {
    mode: u32,
}

@group(2) @binding(0)
var&lt;uniform&gt; material: DebugMaterial;

@vertex
fn vertex(
    @builtin(instance_index) instance_index: u32,
    @location(0) position: vec3&lt;f32&gt;,
    @location(1) normal: vec3&lt;f32&gt;,
) -&gt; VertexOutput {
    var out: VertexOutput;
    
    // Get the model transformation matrix
    let world_from_local = mesh_functions::get_world_from_local(instance_index);
    
    // Transform position to world space
    let world_position = mesh_functions::mesh_position_local_to_world(
        world_from_local,
        vec4&lt;f32&gt;(position, 1.0)
    );
    
    // Transform to clip space (final vertex shader output)
    out.position = position_world_to_clip(world_position.xyz);
    
    // Transform normal to world space
    out.world_normal = mesh_functions::mesh_normal_local_to_world(
        normal,
        instance_index
    );
    
    // Pass world position to fragment shader
    out.world_position = world_position;
    
    return out;
}

@fragment
fn fragment(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    // Mode 0: Show normals (demonstrates interpolation between vertices)
    if material.mode == 0u {
        // Normals range from -1 to 1, convert to 0-1 for RGB color
        // Red = X direction, Green = Y direction, Blue = Z direction
        let color = (in.world_normal + 1.0) * 0.5;
        return vec4&lt;f32&gt;(color, 1.0);
    }
    
    // Mode 1: Checkerboard pattern (demonstrates per-pixel fragment shader work)
    if material.mode == 1u {
        // Create a 3D checkerboard pattern
        let scale = 3.0;
        let x = i32(floor(in.world_position.x * scale));
        let y = i32(floor(in.world_position.y * scale));
        let z = i32(floor(in.world_position.z * scale));
        
        // Use bitwise AND to alternate between 0 and 1
        let checker = (x + y + z) &amp; 1;
        
        if checker == 0 {
            return vec4&lt;f32&gt;(0.9, 0.9, 0.9, 1.0); // Light gray
        } else {
            return vec4&lt;f32&gt;(0.2, 0.2, 0.8, 1.0); // Blue
        }
    }
    
    // Mode 2: Height-based gradient (demonstrates math in fragment shader)
    if material.mode == 2u {
        // Color based on Y position (height) in world space
        // Map from -2 to 2 range to 0-1 range for color
        let height = (in.world_position.y + 2.0) / 4.0;
        let color = vec3&lt;f32&gt;(height, 0.5, 1.0 - height);
        return vec4&lt;f32&gt;(color, 1.0);
    }
    
    // Default: Solid color
    return vec4&lt;f32&gt;(1.0, 0.0, 0.0, 1.0);
}
</code></pre>
<h3 id="the-rust-material-srcmaterialsdebug_pipeliners">The Rust Material (<code>src/materials/debug_pipeline.rs</code>)</h3>
<p>This is the Rust-side definition of our material. It’s a simple struct that mirrors the DebugMaterial struct in our shader, allowing Bevy’s rendering engine to send our chosen mode value to the GPU.</p><pre><code class="language-rust">use bevy::prelude::*;
use bevy::render::render_resource::{AsBindGroup, ShaderRef};

#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
pub struct DebugPipelineMaterial {
    #[uniform(0)]
    pub mode: u32,
}

impl Material for DebugPipelineMaterial {
    fn fragment_shader() -&gt; ShaderRef {
        &quot;shaders/debug_pipeline.wgsl&quot;.into()
    }

    fn vertex_shader() -&gt; ShaderRef {
        &quot;shaders/debug_pipeline.wgsl&quot;.into()
    }
}
</code></pre>
<p>Don’t forget to add it to <code>src/materials/mod.rs</code>:</p><pre><code class="language-rust">// ... other materials
pub mod debug_pipeline;
</code></pre>
<h3 id="the-demo-module-srcdemosdebug_pipeliners">The Demo Module (<code>src/demos/debug_pipeline.rs</code>)</h3>
<p>This Rust module sets up our Bevy scene. It spawns a sphere with our custom <code>DebugPipelineMaterial</code>, adds a camera and light, and sets up the UI text. Most importantly, it contains the <code>cycle_debug_mode</code> system, which listens for the spacebar press and updates the mode field on our material, triggering the change in the shader.</p><pre><code class="language-rust">use crate::materials::debug_pipeline::DebugPipelineMaterial;
use bevy::prelude::*;

pub fn run() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(MaterialPlugin::&lt;DebugPipelineMaterial&gt;::default())
        .add_systems(Startup, setup)
        .add_systems(Update, (rotate_camera, cycle_debug_mode))
        .run();
}

fn setup(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;DebugPipelineMaterial&gt;&gt;,
) {
    // Spawn a sphere with our debug material (better for showing interpolation)
    commands.spawn((
        Mesh3d(meshes.add(Sphere::new(1.0))),
        MeshMaterial3d(materials.add(DebugPipelineMaterial { mode: 0 })),
    ));

    // Light
    commands.spawn((
        PointLight {
            shadows_enabled: true,
            ..default()
        },
        Transform::from_xyz(4.0, 8.0, 4.0),
    ));

    // Camera
    commands.spawn((
        Camera3d::default(),
        Transform::from_xyz(-2.5, 4.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y),
    ));

    // UI to show current mode
    commands.spawn((
        Text::new(&quot;Press SPACE to cycle debug modes\nMode 0: Normals (shows interpolation)&quot;),
        Node {
            position_type: PositionType::Absolute,
            top: Val::Px(10.0),
            left: Val::Px(10.0),
            ..default()
        },
    ));
}

fn rotate_camera(time: Res&lt;Time&gt;, mut camera_query: Query&lt;&amp;mut Transform, With&lt;Camera3d&gt;&gt;) {
    for mut transform in camera_query.iter_mut() {
        let radius = 9.0;
        let angle = time.elapsed_secs() * 0.5;
        transform.translation.x = angle.cos() * radius;
        transform.translation.z = angle.sin() * radius;
        transform.look_at(Vec3::ZERO, Vec3::Y);
    }
}

fn cycle_debug_mode(
    keyboard: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;DebugPipelineMaterial&gt;&gt;,
    mut text_query: Query&lt;&amp;mut Text&gt;,
) {
    if keyboard.just_pressed(KeyCode::Space) {
        for (_, material) in materials.iter_mut() {
            material.mode = (material.mode + 1) % 3;

            for mut text in text_query.iter_mut() {
                **text = match material.mode {
                    0 =&gt; &quot;Press SPACE to cycle debug modes\nMode 0: Normals (shows interpolation)&quot;.to_string(),
                    1 =&gt; &quot;Press SPACE to cycle debug modes\nMode 1: Checkerboard (per-pixel processing)&quot;.to_string(),
                    2 =&gt; &quot;Press SPACE to cycle debug modes\nMode 2: Height Gradient (fragment math)&quot;.to_string(),
                    _ =&gt; &quot;Unknown mode&quot;.to_string(),
                };
            }
        }
    }
}
</code></pre>
<p>Don’t forget to add it to <code>src/demos/mod.rs</code>:</p><pre><code class="language-rust">// ... other demoss
pub mod debug_pipeline;
</code></pre>
<p>And register it in <code>src/main.rs</code>:</p><pre><code class="language-rust">Demo {
    number: &quot;1.1&quot;,
    title: &quot;Understanding the Graphics Pipeline&quot;,
    run: demos::debug_pipeline::run,
},
</code></pre>
<h3 id="running-the-demo">Running the Demo</h3>
<p>When you run the project, you will see a sphere. Pressing the spacebar will cycle through the three different debug visualizations, each revealing a different aspect of the pipeline’s inner workings.</p><h4 id="controls">Controls</h4>
<table>
<thead>
<tr>
<th>Control</th>
<th>Action</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SPACE</strong></td>
<td>Cycle to the next visualization mode (0 -&gt; 1 -&gt; 2 -&gt; 0).</td>
</tr>
</tbody></table>
<h4 id="what-youre-seeing">What You’re Seeing</h4>
<p>![[screenshot - 1.png]]
![[screenshot - 2.png]]
![[screenshot - 3.png]]</p><table>
<thead>
<tr>
<th>Mode</th>
<th>Description</th>
<th>What It Proves</th>
</tr>
</thead>
<tbody><tr>
<td><strong>0 - Normals</strong></td>
<td>The sphere is colored based on the direction its surface is facing. Red points right (+X), Green points up (+Y), and Blue points forward (+Z). You see smooth gradients of color across the entire surface.</td>
<td>This demonstrates <strong>interpolation</strong>. The normals are defined only at the vertices, but the rasterizer smoothly blends them between those points, giving every single pixel its own unique normal vector to use for coloring.</td>
</tr>
<tr>
<td><strong>1 - Checkerboard</strong></td>
<td>The sphere is covered in a 3D checkerboard pattern that appears fixed in the world as the sphere rotates through it. The pattern is sharp and blocky.</td>
<td>This demonstrates <strong>per-fragment processing</strong>. The fragment shader calculates which color to be (light gray or blue) for every single pixel independently, based on that pixel’s position in world space.</td>
</tr>
<tr>
<td><strong>2 - Height Gradient</strong></td>
<td>The sphere is colored with a gradient based on its height in the world. The bottom is magenta, and the top is cyan.</td>
<td>This demonstrates using <strong>vertex shader data in the fragment shader</strong>. The vertex shader calculates the world_position for each vertex. The rasterizer interpolates it, and the fragment shader uses the Y-component of that position to calculate a color.</td>
</tr>
</tbody></table>
<h2 id="key-takeaways">Key Takeaways</h2>
<p>This chapter covered a lot of ground. Before moving on, take a moment to solidify these five core concepts. They are the foundation for everything that follows.</p><ol>
<li><strong>The Pipeline is a CPU-to-GPU Process.</strong><br> Rendering is a collaboration. Your Bevy code on the CPU acts as the <strong>Director</strong>, preparing the scene’s data (meshes, materials, transforms). It then hands this “shot list” to the GPU, a specialized <strong>VFX Studio</strong> that executes the rendering process through a hardware assembly line.</li>
<li><strong>Shaders are Your Instructions for the VFX Artists.</strong><br> You cannot change the hardware pipeline itself, but you can write small, highly focused programs called <strong>shaders</strong> that run at critical, programmable stages. The GPU’s massively parallel architecture executes your shader code for millions of vertices and pixels per second, which is what makes real-time 3D graphics possible.</li>
<li><strong>The Vertex Shader’s Job is to POSITION Geometry.</strong><br> This is your “Layout Artist” stage. The vertex shader runs once for every vertex in your mesh. Its primary responsibility is to take that vertex’s 3D position from the original model and transform it through a series of coordinate spaces until it has its final, correct position on the 2D screen.</li>
<li><strong>The Fragment Shader’s Job is to COLOR Pixels.</strong><br> This is your “Coloring &amp; Lighting Artist” stage. After the hardware rasterizer determines which pixels a triangle covers, the fragment shader runs once for every single one of those “fragments.” Its sole responsibility is to calculate and return the final RGBA color for that specific spot on the screen. This is where you apply textures, lighting, and visual effects.</li>
<li><strong>Data Flows and is Interpolated from Vertex to Fragment.</strong><br> The two shaders are connected. The vertex shader can pass data (like UV coordinates or normal vectors) to the next stage. The hardware <strong>Rasterizer</strong> automatically <strong>interpolates</strong> (smoothly blends) this data across the face of the triangle, making a unique version of it available to the fragment shader for every single pixel.</li>
</ol>
<h2 id="whats-next">What’s Next?</h2>
<p>You now have the essential mental model for the rendering pipeline - you understand where your shader code runs and the specific job of each stage. With this “map” in hand, we are finally ready to learn the language of the GPU’s artists themselves.</p><p>In the next article, we will dive into the fundamental building blocks of the WGSL language: its data types and variables. You’ll learn how to represent positions, colors, and transformations in your code using scalars, vectors, and matrices.</p><p><em>Next up:</em> <a href="https://hexbee.hashnode.dev/12-wgsl-fundamentals-data-types-and-variables"><strong><em>1.2 - WGSL Fundamentals - Data Types &amp; Variables</em></strong></a></p><hr>
<h2 id="quick-reference">Quick Reference</h2>
<p>A summary of the core concepts for quick lookup.</p><h3 id="the-pipeline-stages--their-jobs">The Pipeline Stages &amp; Their Jobs</h3>
<table>
<thead>
<tr>
<th>Stage</th>
<th>Analogy</th>
<th>Role (What it does)</th>
<th>Programmable?</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1. Application (CPU)</strong></td>
<td>The Director</td>
<td>Prepares all scene data: meshes, materials, transforms, camera info.</td>
<td>Yes (Rust)</td>
</tr>
<tr>
<td><strong>2. Vertex Shader</strong></td>
<td>The Layout Artist</td>
<td>Runs <strong>per-vertex</strong> to calculate its final on-screen position (in Clip Space).</td>
<td><strong>Yes (WGSL)</strong></td>
</tr>
<tr>
<td><strong>3. Rasterizer</strong></td>
<td>The Render Farm</td>
<td><strong>Automatic hardware</strong> step that turns 3D triangles into a 2D grid of fragments.</td>
<td>No</td>
</tr>
<tr>
<td><strong>4. Fragment Shader</strong></td>
<td>The Coloring Artist</td>
<td>Runs <strong>per-fragment</strong> to calculate its final RGBA color.</td>
<td><strong>Yes (WGSL)</strong></td>
</tr>
<tr>
<td><strong>5. Output Merger</strong></td>
<td>The Final Print</td>
<td><strong>Automatic hardware</strong> step that performs depth tests and writes the final color.</td>
<td>No</td>
</tr>
</tbody></table>
<h3 id="the-coordinate-space-journey-1">The Coordinate Space Journey</h3>
<p>This is the required path a single vertex position takes through the Vertex Shader.</p><pre><code class="language-plaintext">Local Space → World Space → View Space → Clip Space
</code></pre>
<p>(The GPU then automatically handles the final conversion to Screen Space)</p><h3 id="core-concepts">Core Concepts</h3>
<ul>
<li><strong>Parallelism</strong>: The GPU’s core strength. It processes thousands of vertices and millions of fragments simultaneously. Your shader code is the instruction set for this parallel work.</li>
<li><strong>Interpolation</strong>: The process by which the <strong>Rasterizer</strong> automatically and smoothly blends data (like colors, UVs, or normals) that was output by the <strong>Vertex Shader</strong> at the corners of a triangle. This provides a unique value for that data to the <strong>Fragment Shader</strong> for every pixel the triangle covers.</li>
</ul>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Learning WGSL Shaders with Bevy 0.16: A Practical Journey</title>
        <author>
            <name>Xavier Basty Kjellberg</name>
        </author>
        <link href="https://xav.github.io/learning-wgsl-shaders-with-bevy-016-a-practical-journey/"/>
        <id>https://xav.github.io/learning-wgsl-shaders-with-bevy-016-a-practical-journey/</id>
        <media:content url="https://xav.github.io/media/posts/2/cover.png" medium="image" />
            <category term="wgsl"/>
            <category term="shaders"/>
            <category term="rust"/>
            <category term="bevy"/>

        <updated>2025-08-29T22:38:00+02:00</updated>
            <summary type="html">
                <![CDATA[
                        <img src="https://xav.github.io/media/posts/2/cover.png" alt="" />
                    Does This Sound Familiar? You’re a Bevy developer. You love Rust’s power and safety, and you’ve started to feel comfortable building scenes and game logic.
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://xav.github.io/media/posts/2/cover.png" class="type:primaryImage" alt="" /></p>
                <h2 id="does-this-sound-familiar">Does This Sound Familiar?</h2>
<p>You’re a Bevy developer. You love Rust’s power and safety, and you’ve started to feel comfortable building scenes and game logic. But now you want to create something truly unique - a shimmering shield, a stylized water surface, a custom lighting model - and you realize you need to write a shader.</p><p>So you open a <code>.wgsl</code> file… and you hit a wall.</p><p>You look for tutorials, but they’re almost all for GLSL or Unity, using a different language and a different engine. You look at the official Bevy examples, but they seem to assume you already know how shaders work. You’re stuck in a frustrating gap: you know the engine, you know the language, but you don’t know how to bridge the two to speak directly to the GPU.</p><p><strong>I created this series because I was that developer.</strong></p><p>This is not a theoretical textbook or a high-level overview. It is the practical, step-by-step guide I wish I had when I was starting. It’s the result of systematically navigating that gap, figuring out the fundamentals, hitting the common pitfalls, and documenting what finally made the concepts “click.”</p><p>My goal is to provide a clear, linear path that takes you from the absolute basics of the graphics pipeline all the way to advanced techniques, with every single concept explained and demonstrated inside a working Bevy project. This is the journey of learning how to think in shaders, and I’m thrilled to share it with you.</p><h2 id="our-approach-a-practical-incremental-journey">Our Approach: A Practical, Incremental Journey</h2>
<p>This is a <strong>practical, hands-on series</strong>. We will learn by building, not just by reading. Every single article is built around a working Bevy project that you can run, modify, and experiment with. Our philosophy is that you don’t truly understand a concept until you’ve seen it work, broken it, and fixed it again.</p><p>Our journey is structured to build your knowledge from the ground up, ensuring you have a solid foundation before moving on to more complex topics. Here’s the path we’ll take:</p><ol>
<li><p><strong>First, we’ll build the foundation.</strong> We will demystify the <strong>Graphics Pipeline</strong> and learn the fundamental “alphabet” of WGSL - its data types, variables, and functions. You’ll understand where your code runs and the language it speaks.</p></li>
<li><p><strong>Then, we’ll take control of geometry.</strong> We’ll dive deep into the <strong>Vertex Shader</strong>, where you will learn to manipulate the very shape of your 3D models. You’ll create waving flags, rippling water, and fields of animated grass, learning how to breathe life into static meshes.</p></li>
<li><p><strong>Next, we’ll learn to paint those shapes with light and color.</strong> We’ll master the <strong>Fragment Shader</strong>, moving beyond simple colors to create procedural patterns, sample textures, and implement our own lighting models. This is where you’ll define the unique visual identity of your projects.</p></li>
<li><p><strong>Finally, we’ll explore the advanced frontier.</strong> With the fundamentals in place, we’ll unlock the true power of the GPU, exploring post-processing effects, compute shaders, performance optimization, and how to achieve specific artistic styles.</p></li>
</ol>
<p>By the end of this series, you won’t just know how to copy and paste shader code - you will have the confidence and the deep understanding to create your own custom rendering effects from scratch.</p><h2 id="who-this-series-is-for-and-what-youll-need">Who This Series Is For (And What You’ll Need)</h2>
<p>This series is designed for the curious Bevy developer who is ready to take the next step in their creative journey. If you’re comfortable with the basics of Rust and Bevy but feel like the GPU is still a “black box,” you’re in the perfect place.</p><h3 id="the-prerequisites">The Prerequisites</h3>
<p>This is not a “from zero” programming course. We’ll be moving at a steady pace, and I’ll assume you have a solid footing in the following areas:</p><ul>
<li><p><strong>A Good Grasp of Rust:</strong> You don’t need to be a systems-level expert, but you should be comfortable with core concepts like structs, traits, ownership, and the module system.</p></li>
<li><p><strong>Bevy Fundamentals:</strong> You should have worked through the official Bevy book or built a small project. You know what Components, Systems, and Resources are, and you feel comfortable setting up a basic scene.</p></li>
<li><p><strong>Basic Vector Math Intuition:</strong> You don’t need a math degree, but you should know what a vector is (<code>Vec3</code>) and have a general idea of what operations like adding, subtracting, or normalizing them mean. We’ll review the more complex math (like dot products and matrices) as we need it, focusing on intuition over raw proofs.</p></li>
</ul>
<h3 id="what-you-dont-need">What You Don’t Need</h3>
<p>This is just as important. You <strong>do not</strong> need:</p><ul>
<li>Any prior shader programming experience (that’s what we’re here to learn!).</li>
<li>A deep background in low-level graphics APIs like OpenGL, Vulkan, or DirectX.</li>
<li>To be a math wizard. A willingness to engage with the concepts is far more important than a formal education in linear algebra.</li>
</ul>
<p>Our goal is to build up your knowledge from first principles, right here in the Bevy ecosystem.</p><h2 id="setting-up-your-development-playground">Setting Up Your Development Playground</h2>
<p>A fast, smooth iteration loop is the secret to enjoying shader development. You want to be able to make a small change to your shader code and see the result instantly, without fighting with long compile times. Let’s create a Bevy project specifically configured for this rapid, creative workflow.</p><h3 id="recommended-tools">Recommended Tools</h3>
<p>While you can use any text editor, this series is written with a specific, highly effective setup in mind:</p><ul>
<li><ul>
<li><strong>Editor</strong>: <strong>Visual Studio Code (VS Code)</strong> is strongly recommended. Its rust-analyzer extension provides top-tier support for Rust, and there are excellent extensions that add syntax highlighting for WGSL, making your shader code much easier to read.</li>
</ul>
</li>
<li><p><strong>Graphics Debugger (Optional but Powerful)</strong>: For advanced debugging, a dedicated tool that can capture and inspect a single frame is invaluable. We won’t need this for the early articles, but knowing it exists is important.</p><ul>
<li><strong>Windows / Linux</strong>: <strong>RenderDoc</strong> is the open-source industry standard.</li>
<li><strong>macOS</strong>: Apple’s <strong>Metal GPU Debugger and Frame Capture</strong>, which is built directly into <strong>Xcode</strong>, is the essential tool for debugging Metal applications.</li>
</ul>
</li>
</ul>
<h3 id="step-1-install-the-essentials">Step 1: Install the Essentials</h3>
<p>First, ensure you have the Rust toolchain installed. If you’re already a Rust developer, you can likely skip this.</p><pre><code class="language-bash"># Install Rust if you don&#39;t have it
curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<h3 id="step-2-create-the-project-and-configure-cargotoml">Step 2: Create the Project and Configure <code>Cargo.toml</code></h3>
<p>Let’s create a new Bevy project that will be our home for this entire series.</p><pre><code class="language-bash">mkdir bevy-shader-journey
cd bevy-shader-journey
cargo init
</code></pre>
<p>Now, replace the contents of your <code>Cargo.toml</code> file with the following configuration. We’re adding a few key dependencies and settings to optimize our development experience.</p><pre><code class="language-toml">[package]
name = &quot;bevy-shader-journey&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot; # Sticking with the 2021 edition for maximum compatibility

[dependencies]
# The core Bevy engine, version 0.16
bevy = { version = &quot;0.16&quot;, features = [&quot;file_watcher&quot;] }
# For faster compile times in debug builds, you can enable this feature.
# It doesn&#39;t work on Windows though :(
# bevy = { version = &quot;0.16&quot;, features = [&quot;dynamic_linking&quot;, &quot;file_watcher&quot;] }

# Interactive demo selection - makes it easy to jump between examples
inquire = &quot;0.7&quot;

# An incredibly useful debugging tool we&#39;ll use in later articles
# to tweak shader values in real-time.
bevy-inspector-egui = &quot;0.23&quot;

# This section makes our local code compile faster (opt-level = 1)
# while keeping our dependencies fully optimized (opt-level = 3).
# It&#39;s a great trick for improving Bevy&#39;s debug build times.
[profile.dev]
opt-level = 1

[profile.dev.package.&quot;*&quot;]
opt-level = 3
</code></pre>
<h3 id="step-3-create-the-project-directory-structure">Step 3: Create the Project Directory Structure</h3>
<p>A good project organization will make life much easier as we add more examples. Create the necessary directories and files with this command:</p><pre><code class="language-bash">mkdir -p assets/shaders src/demos src/materials

# Create the module files
touch src/demos/mod.rs
touch src/materials/mod.rs
</code></pre>
<p>This gives us:</p><ul>
<li><code>assets/shaders/</code>: Where all our <code>.wgsl</code> shader files will live.</li>
<li><code>src/demos/</code>: Where each article’s interactive example will go.</li>
<li><code>src/materials/</code>: Where the Rust “glue” code for our custom materials will go.</li>
</ul>
<h3 id="step-4-set-up-the-demo-selection-system">Step 4: Set Up the Demo Selection System</h3>
<p>Here’s where things get interesting. Instead of creating separate example files or constantly commenting and uncommenting code, we’re going to build a smart demo selection system. This will let you easily run any example from the series with a simple command.</p><p>Replace the contents of <code>src/main.rs</code> with this code:</p><pre><code class="language-rust">mod demos;
mod materials;

use std::env;

struct Demo {
    number: &amp;&#39;static str,
    title: &amp;&#39;static str,
    run: fn(),
}

impl Demo {
    fn matches(&amp;self, query: &amp;str) -&gt; bool {
        let query_lower = query.to_lowercase();
        self.number.contains(&amp;query_lower) || self.title.to_lowercase().contains(&amp;query_lower)
    }

    fn display(&amp;self) -&gt; String {
        format!(&quot;{} - {}&quot;, self.number, self.title)
    }
}

fn main() {
    // Registry of all available demos
    let demos = vec![
        Demo {
            number: &quot;0.0&quot;,
            title: &quot;Basic Scene Setup&quot;,
            run: demos::basic_scene::run,
        },
        // More demos will be added as we progress through the series
    ];

    let args: Vec&lt;String&gt; = env::args().skip(1).collect();

    let demo = if args.is_empty() {
        select_demo_interactive(&amp;demos)
    } else {
        let query = args.join(&quot; &quot;);
        find_and_select_demo(&amp;demos, &amp;query)
    };

    match demo {
        Some(d) =&gt; {
            println!(&quot;\n🚀 Running: {}\n&quot;, d.display());
            (d.run)();
        }
        None =&gt; {
            println!(&quot;No demo selected. Exiting.&quot;);
            std::process::exit(0);
        }
    }
}

fn find_and_select_demo&lt;&#39;a&gt;(demos: &amp;&#39;a [Demo], query: &amp;str) -&gt; Option&lt;&amp;&#39;a Demo&gt; {
    let matches: Vec&lt;&amp;Demo&gt; = demos.iter().filter(|d| d.matches(query)).collect();

    match matches.len() {
        0 =&gt; {
            eprintln!(&quot;❌ No demos match &#39;{}&#39;\n&quot;, query);
            show_available_demos(demos);
            println!();
            select_demo_interactive(demos)
        }
        1 =&gt; Some(matches[0]),
        _ =&gt; {
            eprintln!(&quot;⚠️  Multiple demos match &#39;{}&#39;:\n&quot;, query);
            select_from_list(&amp;matches)
        }
    }
}

fn select_demo_interactive&lt;&#39;a&gt;(demos: &amp;&#39;a [Demo]) -&gt; Option&lt;&amp;&#39;a Demo&gt; {
    println!(&quot;Available demos:&quot;);
    show_available_demos(demos);
    println!();

    let demo_refs: Vec&lt;&amp;Demo&gt; = demos.iter().collect();
    select_from_list(&amp;demo_refs)
}

fn show_available_demos(demos: &amp;[Demo]) {
    for demo in demos {
        println!(&quot;  • {}&quot;, demo.display());
    }
}

fn select_from_list&lt;&#39;a&gt;(demos: &amp;[&amp;&#39;a Demo]) -&gt; Option&lt;&amp;&#39;a Demo&gt; {
    use inquire::Select;

    let options: Vec&lt;String&gt; = demos.iter().map(|d| d.display()).collect();
    let selected = Select::new(&quot;Select a demo to run:&quot;, options).prompt();

    match selected {
        Ok(selected_text) =&gt; demos.iter().find(|d| d.display() == selected_text).copied(),
        Err(_) =&gt; {
            println!(&quot;Selection cancelled.&quot;);
            None
        }
    }
}
</code></pre>
<p><strong>What does this do?</strong> This system lets you run any demo from the series with intuitive commands:</p><pre><code class="language-rust"># Run by article number
cargo run 1.1

# Run by partial title match
cargo run pipeline

# Multiple matches? You&#39;ll get an interactive menu with arrow keys
cargo run shader

# No arguments? See all available demos and select with arrow keys
cargo run
</code></pre>
<p>As you progress through the series, you’ll simply add new demos to the <code>demos</code> vector in <code>main.rs</code>, and they’ll automatically be available through this selection system. No managing multiple example files or hunting through code!</p><h3 id="step-5-create-your-first-demo-module">Step 5: Create Your First Demo Module</h3>
<p>Now let’s create the first demo that we registered in our system. Create <code>src/demos/basic_scene.rs</code>:</p><pre><code class="language-rust">use bevy::prelude::*;

pub fn run() {
    App::new()
        .add_plugins(DefaultPlugins.set(AssetPlugin {
            // Enable hot reloading
            watch_for_changes_override: Some(true),
            ..default()
        }))
        .add_systems(Startup, setup)
        .add_systems(Update, rotate_camera)
        .run();
}

fn setup(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;StandardMaterial&gt;&gt;,
) {
    // Add a simple scene we can apply our shaders to
    commands.spawn((
        Mesh3d(meshes.add(Cuboid::new(2.0, 2.0, 2.0))),
        MeshMaterial3d(materials.add(Color::srgb(0.8, 0.7, 0.6))),
    ));

    // Light
    commands.spawn((
        PointLight {
            shadows_enabled: true,
            ..default()
        },
        Transform::from_xyz(4.0, 8.0, 4.0),
    ));

    // Camera
    commands.spawn((
        Camera3d::default(),
        Transform::from_xyz(-2.5, 4.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y),
    ));
}

// Simple camera rotation to see our shaders from different angles
fn rotate_camera(time: Res&lt;Time&gt;, mut camera_query: Query&lt;&amp;mut Transform, With&lt;Camera3d&gt;&gt;) {
    for mut transform in camera_query.iter_mut() {
        let radius = 9.0;
        let angle = time.elapsed_secs() * 0.5;
        transform.translation.x = angle.cos() * radius;
        transform.translation.z = angle.sin() * radius;
        transform.look_at(Vec3::ZERO, Vec3::Y);
    }
}
</code></pre>
<p>And register it in <code>src/demos/mod.rs</code>:</p><pre><code class="language-rust">pub mod basic_scene;
</code></pre>
<p><strong>The pattern you’ll follow for every article:</strong></p><ol>
<li>Create a new module in <code>src/demos/</code> (e.g., <code>first_shader.rs</code>)</li>
<li>Implement a <code>pub fn run()</code> function that starts a Bevy app</li>
<li>Add the module to <code>src/demos/mod.rs</code></li>
<li>Register it in the <code>demos</code> vector in <code>main.rs</code></li>
</ol>
<p>That’s it! The demo selection system handles the rest.</p><h3 id="step-5-test-your-setup">Step 5: Test Your Setup</h3>
<p>You’re all set! Let’s make sure everything works:</p><p>bash</p><pre><code class="language-bash"># Run the basic scene demo directly
cargo run 0.0

# Or try the interactive selection
cargo run
</code></pre>
<p>You should see a simple scene with a rotating camera orbiting around a cube.</p><p><strong>Try experimenting with the selection system:</strong></p><pre><code class="language-bash">cargo run basic     # Matches &quot;Basic Scene Setup&quot;
cargo run scene     # Same result
cargo run xyz       # No match - shows all demos and lets you select
</code></pre>
<p><strong>Congratulations!</strong> You now have a robust development environment with:</p><ul>
<li>Fast iteration with hot-reloading for shader changes</li>
<li>An intuitive demo selection system for jumping between examples</li>
<li>A clean project structure that will scale as you learn</li>
</ul>
<p>When you save changes to a shader file in the <code>assets</code> directory, Bevy will automatically detect the change and reload it in real-time. This instant feedback is the key to learning and experimenting with shaders effectively.</p><h2 id="understanding-the-project-structure">Understanding the Project Structure</h2>
<p>Here’s how everything fits together:</p><pre><code class="language-plaintext">bevy-shader-journey/
├── assets/
│   └── shaders/              # Your .wgsl shader files
│       └── first_shader.wgsl # (We&#39;ll create these as we go)
├── src/
│   ├── main.rs               # Demo selection system
│   ├── demos/                # One module per article
│   │   ├── mod.rs
│   │   ├── basic_scene.rs    # Article 0.0
│   │   └── first_shader.rs   # (Article 1.1, etc.)
│   └── materials/            # Custom material definitions
│       └── mod.rs
└── Cargo.toml
</code></pre>
<p><strong>The workflow:</strong></p><ol>
<li>Read an article to understand the concepts</li>
<li>Run the demo: <code>cargo run [article-number]</code></li>
<li>Look at the code in <code>src/demos/[name].rs</code></li>
<li>Examine the shader in <code>assets/shaders/[name].wgsl</code></li>
<li>Experiment - change values, break things, see what happens!</li>
<li>Move to the next article when ready</li>
</ol>
<h2 id="a-mindset-for-success">A Mindset for Success</h2>
<p>You are now ready to begin. As you dive into the world of shaders, keeping a few practical tips in mind will make the learning process smoother and more enjoyable.</p><ul>
<li><strong>Start Simple, Then Iterate.</strong> The golden rule of shader development. Always begin with the absolute most basic version of an effect that works, even if it’s just a solid color. Once you have a working baseline, add complexity one small step at a time. This makes debugging infinitely easier.</li>
<li><strong>Embrace the Visual Debugging Loop.</strong> Your primary debugging tool is the screen itself. Is the effect too bright? Multiply by 0.5. Is it upside down? Multiply a coordinate by <code>-1.0</code>. Get comfortable making small, incremental changes and immediately observing the visual result.</li>
<li><strong>Use Descriptive Variable Names.</strong> Shaders can quickly become a maze of vector math. A variable named <code>surfaceToLightDirection</code> is a thousand times clearer than <code>vecL</code>. Your future self, trying to debug the code, will thank you.</li>
<li><strong>Save Your Progress Frequently.</strong> Shader development is highly experimental. You’ll often go down a path that leads to a visual mess. Using a version control system like Git to commit frequently after each small success will give you the freedom to experiment without fear of losing your working code.</li>
<li><strong>Jump Between Examples Freely.</strong> One of the beauties of our demo selection system is that you can easily revisit previous techniques. Forgot how normal mapping works? Just <code>cargo run normal</code> and refresh your memory. Want to compare two approaches? Run them side by side!</li>
</ul>
<h2 id="lets-get-started">Let’s Get Started!</h2>
<p>Your development environment is configured, your mindset is right, and the path is laid out before you. That blank <code>.wgsl</code> file is no longer an intimidating obstacle - it’s a canvas waiting for your creativity.</p><p>The demo selection system gives you the freedom to explore at your own pace, jumping between concepts and building your understanding incrementally. Each article in this series adds a new demo to your toolkit, and by the end, you’ll have a comprehensive library of shader techniques at your fingertips.</p><p>It’s time to dive in and learn how to speak directly to the GPU.</p><p>Next up: [1.1 - Understanding the Graphics Pipeline]</p><hr>
<h2 id="quick-reference">Quick Reference</h2>
<p><strong>Running Demos:</strong></p><pre><code class="language-bash">cargo run 1.1              # By article number
cargo run pipeline         # By keyword
cargo run                  # Interactive selection
</code></pre>
<p><strong>Project Structure:</strong></p><ul>
<li><code>src/main.rs</code> - Demo selection system</li>
<li><code>src/demos/</code> - One module per article (each exports <code>pub fn run()</code>)</li>
<li><code>src/materials/</code> - Custom material definitions</li>
<li><code>assets/shaders/</code> - WGSL shader files</li>
</ul>
<p><strong>Development Tips:</strong></p><ul>
<li>Save a shader file → Bevy auto-reloads it</li>
<li>Small changes → Immediate visual feedback</li>
<li>Commit working code frequently</li>
<li>Use descriptive names in shader code</li>
</ul>

            ]]>
        </content>
    </entry>
</feed>
